import loop
import random

```
skill_ids = []
mastery_colors = [2228479, 5570815, 7799039, 11141375, 14483711, 16711901, 16711799, 16711714, 16711680]

mastery_weapons = ["claw", "dagger", "bow", "cbow", "spear", "polearm", "sword", "axe", "blunt"]

def append_scheduler(delay_range, base_delay, skill_path):
	print("func append_scheduler()")
	print("{")
	print("		execute store result score #GLOBAL hit_distance run data get storage skill:main temp[0]")
	print("		function ARG(_PATH)schedulers/delay0/check")
	print("}")
	
	print("folder schedulers()")
	print("{")
	for i in range(delay_range):
		print(f"folder delay{i}()")
		print("	{")
		print("		func check()")
		print("		{")
		print(f"		execute if score #GLOBAL hit_distance matches {i} run function ARG(_PATH)run")
		if i < delay_range - 1:
			print(f"	execute if score #GLOBAL hit_distance matches {i+1}.. run function ARG(__PATH)delay{i+1}/check")
		print("		}")
		
		print("		func run()")
		print("		{")
		print(f"		data modify storage skill:main new_schedule append value {{delay:{i},time:0}}")
		print(f"		execute store result storage skill:main new_schedule[-1].time int 1 run schedule function {skill_path}hit_effect {base_delay+i}t append")
		if i < delay_range - 1:
			print("		data remove storage skill:main temp[0]")
			print("		execute store result score #GLOBAL hit_distance run data get storage skill:main temp[0]")
			
		print("		}")
		print("	}")
	print("}")
```

namespace attack_skill_template(skill_id) as virtual
{
	# functions to override:
	#	check => check whether to use the skill or not
	#	mark_target => tag all target
	#	cast_effect => visual and audio effects on casting skill
	#	set_numeric => calculate all numbers related to damage and write to global storage
	#	add_debuff => set all debuff numbers as the hit mob
	#	effect => visual and audio effects with display_number as damage
	#	append_scheduler => see "append_scheduler_sample"
	
	```
	skill_ids.append("ARG(skill_id)")
	```
	
	func run()
	{
		```
		# reset final attack
		if "ARG(skill_id)" != "1000006":
			print("scoreboard players reset @s f_attack_skill")
		```
		function skill:use_constraint
		
		data modify storage skill:main damage set value [{min_damage:0,max_damage:0,accuracy:0,player_level:0,crit_rate:0,crit_damage:0,base_percent:100,attribute:0}]
		data modify storage skill:main damage_info.hit_effect set value 0
		```
		if "ARG(skill_id)" not in ["3201005", "6001001", "6001003"]:
			print("function ARG(_PATH)mark_target")
		```
		function ARG(_PATH)set_numeric
		function ARG(_PATH)cast_effect
		
		execute if score #FOUND_ENEMY temp matches 1.. run function ARG(_PATH)did_hit
		```
		if "ARG(skill_id)" in ["3201005", "1000006", "2221006", "3221001"]:
			print("scoreboard players reset #AFTER_MODIFIER_NUM temp")
		```
	}
	
	func did_hit()
	{
		scoreboard players set #EXP_GAIN temp 0
		```
		# mp eater
		if "ARG(skill_id)"[0] == "2":
			print("function skill:2/1/0/0000/set_numeric")
		```
		data modify storage skill:main damage_info.attacker set from entity @s UUID
		execute store result storage skill:main damage_info.attacker_id int 1 run scoreboard players get @s number
		
		execute positioned 250.0 0.0 0.0 rotated ~ 0 run summon area_effect_cloud ^ ^ ^0.2 {Duration:0,Tags:["knockback_motion"]}
		data modify storage skill:main damage_info.knock_back set from entity @e[type=area_effect_cloud,tag=knockback_motion,limit=1] Pos
		execute store result score #GLOBAL temp run data get storage skill:main damage_info.knock_back[0] 10000
		execute store result storage skill:main damage_info.knock_back[0] double 0.0001 run scoreboard players remove #GLOBAL temp 2500000
		kill @e[type=area_effect_cloud,tag=knockback_motion,limit=1]
		
		data modify storage skill:main new_schedule set value []
		function ARG(_PATH)append_scheduler
		```
		if "ARG(skill_id)" in ["3101003","6001003"]:
			print("data modify storage skill:main damage_info.power_knock_back set from storage skill:main damage_info.knock_back")
			print("execute store result storage skill:main damage_info.power_knock_back[0] double 0.0007 run data get storage skill:main damage_info.power_knock_back[0] 10000")
			print("execute store result storage skill:main damage_info.power_knock_back[2] double 0.0007 run data get storage skill:main damage_info.power_knock_back[2] 10000")
		```
		execute as @e[type=zombified_piglin,tag=target] at @s run function ARG(_PATH)hit
		```
		# mp eater
		if "ARG(skill_id)"[0] == "2":
			print("execute if score #TOTAL_ABSORB temp matches 1.. run function skill:2/1/0/0000/cast_effect")
		```
		function skill:hunt_exp
	}
	
	func hit_effect()
	{
		execute store result score #GLOBAL ARG(skill_id)_eid run time query gametime
		execute as @e[type=zombified_piglin,tag=enemy] if score @s ARG(skill_id)_eid = #GLOBAL ARG(skill_id)_eid at @s run function ARG(_PATH)perform_effect
	}
	
	func perform_effect()
	{
		scoreboard players remove @s queuing_effect 1
		
		execute store result score @s display_number run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.number
		execute store result score @s display_num_type run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.crit
		execute store result score #NUMBER_HEIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.height
		execute store result score #HIT_EFFECT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].hit_effect
		data modify entity @s AngryAt set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker
		
		execute store result score #GLOBAL temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker_id
		execute as @a if score @s number = #GLOBAL temp run tag @s add face_target
		execute facing entity @a[tag=face_target,limit=1] feet run function ARG(_PATH)facing_effect
		tag @a[tag=face_target,limit=1] remove face_target
		
		function skill:show_num_at_height
		
		execute if score @s hp matches ..0 unless score @s queuing_effect matches 1.. run function skill:mob_effect/dead
		data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
		execute unless data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] run scoreboard players reset @s ARG(skill_id)_eid
		execute store result score #GLOBAL temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		execute if score #GLOBAL temp = @s ARG(skill_id)_eid run function ARG(_PATH)perform_effect
		execute if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] run scoreboard players operation @s ARG(skill_id)_eid = #GLOBAL temp
	}
	
	func facing_effect()
	{
		```
		if "ARG(skill_id)" in ["3101003","6001003"]:
			print("scoreboard players set #DID_KNOCKBACK temp 1")
			print("execute if score @s kb > @s display_number unless data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].force_knock run scoreboard players set #DID_KNOCKBACK temp 0")
			print("execute unless score @s pushed_time matches 0.. if score #DID_KNOCKBACK temp matches 1 run function ARG(_PATH)knock_back")
		else:
			print("execute unless score @s pushed_time matches 0.. if score @s kb <= @s display_number run function ARG(_PATH)knock_back")
		```
		scoreboard players operation #DEFAULT_SIZE temp = @s default_width
		function ARG(_PATH)forward_effect/run
	}
	
	folder forward_effect()
	{
		func run()
		{
			scoreboard players remove #DEFAULT_SIZE temp 1
			execute if score #DEFAULT_SIZE temp matches -1 run function ARG(_PATH)forward
			execute if score #DEFAULT_SIZE temp matches 0.. positioned ^ ^ ^0.4 run function ARG(_PATH)run
		}
		
		func forward()
		{
			execute if score @s display_number matches 1.. if score #HIT_EFFECT temp matches 1 positioned ^ ^ ^0.5 run function skill:afterimage/hit/mace
			execute if score @s display_number matches 1.. if score #HIT_EFFECT temp matches 2 positioned ^ ^ ^0.5 run function skill:afterimage/hit/sword
			function ARG(__PATH)effect
		}
	}
	
	func knock_back()
	{
		scoreboard players set @s pushed_time 12
		scoreboard players operation @s kb_time > @s pushed_time
		execute if score @s status matches ..3 run function skill:mob_effect/hit_model
		
		# face attacker player
		tp @s ~ ~ ~ ~ ~
		
		data modify entity @s Motion set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].knock_back
		
		attribute @s minecraft:generic.movement_speed modifier add 495407c5-10c0-4270-84ed-c566e01e6952 move_control -100.0 add
	}
	
	func hit()
	{
		function skill:calculate_damage/run
		```
		if "ARG(skill_id)" in ["3101003","6001003"]:
			print("execute if entity @s[tag=!dead] run function main:rand_rate")
		```
		execute if score #DID_HIT temp matches 1 run function ARG(_PATH)add_debuff
		```
		# mp eater
		if "ARG(skill_id)"[0] == "2":
			print("execute if score #ABSORB_RATE temp matches 1.. if score @s[tag=!boss] mp matches 1.. run function skill:2/1/0/0000/try_absorb")
		```
		
		data modify storage skill:main new_queue set value []
		data modify storage skill:main temp set from storage skill:main new_schedule
		function ARG(_PATH)merge_schedule/run
		data modify entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue prepend from storage skill:main new_queue[]
		execute store result score @s ARG(skill_id)_eid run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		
		scoreboard players set @s hit_distance 0
		scoreboard players set @s hit_order 0
		tag @s remove first_target
		tag @s remove target
	}
	
	folder merge_schedule() from while_loop("if data storage skill:main temp[0]")
	{
		func execute()
		{
			execute store result score #EFFECT_DELAY temp run data get storage skill:main temp[0].delay
			execute if score #EFFECT_DELAY temp = @s hit_distance run function ARG(_PATH)merge
			
			data remove storage skill:main temp[0]
		}
		
		func merge()
		{
			execute store result score #LEFT temp run data get storage skill:main temp[0].time
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
			function ARG(__PATH)merge_ori_schedule/run
			```
			if "ARG(skill_id)" in ["3101003","6001003"]:
				print("scoreboard players operation #SELF_KNOCKBACK_RATE temp = #SKILL_KNOCKBACK_RATE temp")
				print("execute store result score #THIS_DAMAGE temp run data get entity @s ArmorItems[3].tag.damage_record[0].number")
				print("execute if score @s kb <= #THIS_DAMAGE temp run scoreboard players operation #SELF_KNOCKBACK_RATE temp += #KNOCKBACK_RATE temp")
			```
			data modify storage skill:main new_queue append value {}
			execute store result storage skill:main new_queue[-1].time int 1 run scoreboard players get #LEFT temp
			data modify storage skill:main new_queue[-1].damage set from entity @s ArmorItems[3].tag.damage_record[0]
			data modify storage skill:main new_queue[-1].attacker set from storage skill:main damage_info.attacker
			data modify storage skill:main new_queue[-1].attacker_id set from storage skill:main damage_info.attacker_id
			data modify storage skill:main new_queue[-1].hit_effect set from storage skill:main damage_info.hit_effect
			```
			if "ARG(skill_id)" in ["3101003","6001003"]:
				print("execute if score #RAND_RESULT temp >= #SELF_KNOCKBACK_RATE temp run data modify storage skill:main new_queue[-1].knock_back set from storage skill:main damage_info.knock_back")
				print("execute if score #RAND_RESULT temp < #SELF_KNOCKBACK_RATE temp run data modify storage skill:main new_queue[-1].knock_back set from storage skill:main damage_info.power_knock_back")
				print("execute if score #RAND_RESULT temp < #SELF_KNOCKBACK_RATE temp run data modify storage skill:main new_queue[-1].force_knock set value 1b")
			else:
				print("data modify storage skill:main new_queue[-1].knock_back set from storage skill:main damage_info.knock_back")
			```
			data remove entity @s ArmorItems[3].tag.damage_record[0]
			scoreboard players add @s queuing_effect 1
		}
	}
	
	folder merge_ori_schedule() from while_loop("if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] if score #RIGHT temp < #LEFT temp")
	{
		func execute()
		{
			data modify storage skill:main new_queue append from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		}
	}
	
	func add_debuff();
	func append_scheduler_sample() as virtual
	{
		data modify storage skill:main new_schedule append value 0
		execute store result storage skill:main new_schedule[-1] int 1 run schedule function ARG(_PATH)hit_effect 6t append
		data modify storage skill:main new_schedule append value 0
		execute store result storage skill:main new_schedule[-1] int 1 run schedule function ARG(_PATH)hit_effect 9t append
	}
}

namespace bullet_skill_template(skill_id) as virtual
{
	# functions to override:
	#	check => check whether to use the skill or not
	#	mark_target => tag all target
	#	cast_effect => visual and audio effects on casting skill
	#	set_numeric => calculate all numbers related to damage and write to global storage
	#	add_debuff => set all debuff numbers as the hit mob (optional)
	#	effect => visual and audio effects with display_number as damage
	#	append_scheduler => see "append_scheduler_sample"
	
	```
	skill_ids.append("ARG(skill_id)")
	```
	
	func run()
	{
		```
		# reset final attack
		if "ARG(skill_id)" != "3000006":
			print("scoreboard players reset @s f_attack_skill")
		```
		function skill:use_constraint
		
		data modify storage skill:main damage set value [{min_damage:0,max_damage:0,accuracy:0,player_level:0,crit_rate:0,crit_damage:0,base_percent:100,attribute:0}]
		data modify storage skill:main damage_info.hit_effect set value 0
		```
		if "ARG(skill_id)" not in ["3101005", "3001004", "3001005", "4101005", "4001344", "6001002"]:
			print("function ARG(_PATH)mark_target")
		```
		function ARG(_PATH)summon_bullet
		function ARG(_PATH)set_numeric
		function ARG(_PATH)cast_effect
		
		scoreboard players add #BULLET_ID number 1
		execute if score #FOUND_ENEMY temp matches 1.. run function ARG(_PATH)did_hit
		execute if score #FOUND_ENEMY temp matches 0 as @e[type=armor_stand,tag=new_bullet] run function skill:bullet/no_target_setting
	}
	
	func did_hit()
	{
		scoreboard players set #EXP_GAIN temp 0
		```
		# mp eater
		if "ARG(skill_id)"[0] == "2" or "ARG(skill_id)" == "0001000":
			print("function skill:2/1/0/0000/set_numeric")
		```
		data modify storage skill:main damage_info.attacker set from entity @s UUID
		execute store result storage skill:main damage_info.attacker_id int 1 run scoreboard players get @s number
		
		execute positioned 250.0 0.0 0.0 rotated ~ 0 run summon area_effect_cloud ^ ^ ^0.2 {Duration:0,Tags:["knockback_motion"]}
		data modify storage skill:main damage_info.knock_back set from entity @e[type=area_effect_cloud,tag=knockback_motion,limit=1] Pos
		execute store result score #GLOBAL temp run data get storage skill:main damage_info.knock_back[0] 10000
		execute store result storage skill:main damage_info.knock_back[0] double 0.0001 run scoreboard players remove #GLOBAL temp 2500000
		kill @e[type=area_effect_cloud,tag=knockback_motion,limit=1]
		
		execute as @e[type=zombified_piglin,tag=target] at @s run function ARG(_PATH)hit
		```
		if "ARG(skill_id)" == "4101005":
			print("scoreboard players operation @s hp += #DRAIN_AMOUNT temp")
			print("scoreboard players operation @s hp < @s hp_max")
			print("function bar_display:change/hp/recovered")
		elif "ARG(skill_id)"[0] == "2" or "ARG(skill_id)" == "0001000":
			print("execute if score #TOTAL_ABSORB temp matches 1.. run function skill:2/1/0/0000/cast_effect")
		```
		function skill:hunt_exp
	}
	
	func hit_effect()
	{
		execute store result score #GLOBAL ARG(skill_id)_eid run time query gametime
		execute as @e[type=zombified_piglin,tag=enemy] if score @s ARG(skill_id)_eid = #GLOBAL ARG(skill_id)_eid at @s run function ARG(_PATH)perform_effect
	}
	
	func perform_effect()
	{
		scoreboard players remove @s queuing_effect 1
		
		execute store result score @s display_number run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.number
		execute store result score @s display_num_type run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.crit
		execute store result score #NUMBER_HEIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.height
		execute store result score #HIT_EFFECT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].hit_effect
		data modify entity @s AngryAt set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker
		
		execute store result score #GLOBAL temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker_id
		execute as @a if score @s number = #GLOBAL temp run tag @s add face_target
		execute facing entity @a[tag=face_target,limit=1] feet run function ARG(_PATH)facing_effect
		tag @a[tag=face_target,limit=1] remove face_target
		
		function skill:show_num_at_height
		
		execute if score @s hp matches ..0 unless score @s queuing_effect matches 1.. run function skill:mob_effect/dead
		data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
		execute unless data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] run scoreboard players reset @s ARG(skill_id)_eid
		execute store result score #GLOBAL temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		execute if score #GLOBAL temp = @s ARG(skill_id)_eid run function ARG(_PATH)perform_effect
		execute if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] run scoreboard players operation @s ARG(skill_id)_eid = #GLOBAL temp
	}
	
	func facing_effect()
	{
		execute unless score @s pushed_time matches 0.. if score @s kb <= @s display_number run function ARG(_PATH)knock_back
		scoreboard players operation #DEFAULT_SIZE temp = @s default_width
		function ARG(_PATH)forward_effect/run
	}
	
	folder forward_effect()
	{
		func run()
		{
			scoreboard players remove #DEFAULT_SIZE temp 1
			execute if score #DEFAULT_SIZE temp matches -1 run function ARG(_PATH)forward
			execute if score #DEFAULT_SIZE temp matches 0.. positioned ^ ^ ^0.4 run function ARG(_PATH)run
		}
		
		func forward()
		{
			execute if score @s display_number matches 1.. if score #HIT_EFFECT temp matches 1 positioned ^ ^ ^0.5 run function skill:afterimage/hit/mace
			execute if score @s display_number matches 1.. if score #HIT_EFFECT temp matches 2 positioned ^ ^ ^0.5 run function skill:afterimage/hit/sword
			function ARG(__PATH)effect
		}
	}
	
	func knock_back()
	{
		scoreboard players set @s pushed_time 12
		scoreboard players operation @s kb_time > @s pushed_time
		execute if score @s status matches ..3 run function skill:mob_effect/hit_model
		
		# face attacker player
		tp @s ~ ~ ~ ~ ~
		
		data modify entity @s Motion set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].knock_back
		
		attribute @s minecraft:generic.movement_speed modifier add 495407c5-10c0-4270-84ed-c566e01e6952 move_control -100.0 add
	}
	
	func hit()
	{
		scoreboard players operation #GLOBAL temp = @s number
		
		scoreboard players set #BULLET_AMOUNT temp 0
		execute as @e[type=armor_stand,tag=new_bullet] run function skill:bullet/setting
		
		function skill:calculate_damage/run
		execute if score #DID_HIT temp matches 1 run function ARG(_PATH)add_debuff
		```
		# mp eater
		if "ARG(skill_id)"[0] == "2" or "ARG(skill_id)" == "0001000":
			print("execute if score #ABSORB_RATE temp matches 1.. if score @s[tag=!boss] mp matches 1.. run function skill:2/1/0/0000/try_absorb")
		```
		scoreboard players add @s queuing_effect 1
		data modify entity @s ArmorItems[3].tag.bullet_list append value {}
		execute store result entity @s ArmorItems[3].tag.bullet_list[-1].bullet_id int 1 run scoreboard players get #BULLET_ID number
		data modify entity @s ArmorItems[3].tag.bullet_list[-1].damage_record set from entity @s ArmorItems[3].tag.damage_record
		data modify entity @s ArmorItems[3].tag.bullet_list[-1].damage_info set from storage skill:main damage_info
		
		tag @s remove target
		tag @s remove first_target
		scoreboard players operation @s bullet_targeted += #BULLET_AMOUNT temp
	}
	
	folder bullet_hit()
	{
		func run()
		{
			data modify storage skill:main temp set value []
			function ARG(_PATH)pop_bullet_list
			
			scoreboard players remove @s queuing_effect 1
			data modify storage skill:main new_queue set value []
			function ARG(__PATH)merge_schedule/run
			data modify entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue prepend from storage skill:main new_queue[]
			execute store result score @s ARG(skill_id)_eid run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
			
			data remove entity @s ArmorItems[3].tag.bullet_list[0]
			data modify entity @s ArmorItems[3].tag.bullet_list prepend from storage skill:main temp[]
		}
		
		func pop_bullet_list()
		{
			execute store result score #CUR_BULLET_ID temp run data get entity @s ArmorItems[3].tag.bullet_list[0].bullet_id
			execute unless score #CUR_BULLET_ID temp = #BULLET_ID temp run function ARG(_PATH)check_next
		}
		
		func check_next()
		{
			data modify storage skill:main temp append from entity @s ArmorItems[3].tag.bullet_list[0]
			data remove entity @s ArmorItems[3].tag.bullet_list[0]
			function ARG(_PATH)pop_bullet_list
		}
	}
	
	```
	# 3101005 uses its own merge_schedule function
	if "ARG(skill_id)" != "3101005":
		print('''
	folder merge_schedule() from while_loop("if data storage skill:main new_schedule[0]")
	{
		func execute()
		{
			execute store result score #LEFT temp run data get storage skill:main new_schedule[0].time
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
			function ARG(__PATH)merge_ori_schedule/run
			
			data modify storage skill:main new_queue append value {time:0,damage:0,attacker:[I;0,0,0,0],knock_back:[]}
			execute store result storage skill:main new_queue[-1].time int 1 run scoreboard players get #LEFT temp
			data modify storage skill:main new_queue[-1].damage set from entity @s ArmorItems[3].tag.bullet_list[0].damage_record[0]
			data modify storage skill:main new_queue[-1].attacker set from entity @s ArmorItems[3].tag.bullet_list[0].damage_info.attacker
			data modify storage skill:main new_queue[-1].attacker_id set from entity @s ArmorItems[3].tag.bullet_list[0].damage_info.attacker_id
			data modify storage skill:main new_queue[-1].hit_effect set from entity @s ArmorItems[3].tag.bullet_list[0].damage_info.hit_effect
			data modify storage skill:main new_queue[-1].knock_back set from entity @s ArmorItems[3].tag.bullet_list[0].damage_info.knock_back
			
			data remove storage skill:main new_schedule[0]
			data remove entity @s ArmorItems[3].tag.bullet_list[0].damage_record[0]
			scoreboard players add @s queuing_effect 1
		}
	}
	''')
	```
	
	folder merge_ori_schedule() from while_loop("if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] if score #RIGHT temp < #LEFT temp")
	{
		func execute()
		{
			data modify storage skill:main new_queue append from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		}
	}
	
	func add_debuff();
	func summon_bullet_sample() as virtual
	{
		# first bullet should have "first_bullet" tag
		summon minecraft:armor_stand ~ ~ ~ {Tags:["first_bullet","new_bullet","bullet"],CustomName:'{"text":"2","font":"space:default"}',ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1,tag:{appear_delay:16,max_distance:5,skill_id:1,bullet_model:123,CustomModelData:1}}],Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Fire:32767s,CustomNameVisible:0}
		summon minecraft:armor_stand ~ ~ ~ {Tags:["new_bullet","bullet"],CustomName:'{"text":"2","font":"space:default"}',ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1,tag:{appear_delay:19,max_distance:5,skill_id:1,bullet_model:123,CustomModelData:1}}],Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Fire:32767s,CustomNameVisible:0}
	}
}

namespace cd_counter(skill_id) as virtual
{
	func add()
	{
		scoreboard players add #ARG(skill_id)_CD_PEOPLE temp 1
		execute if score #ARG(skill_id)_CD_PEOPLE temp matches 1 run schedule function ARG(_PATH)loop 1s
	}
	
	func loop()
	{
		execute as @a if score @s ARG(skill_id)_cd matches 1.. run function ARG(_PATH)countdown
		execute if score #ARG(skill_id)_CD_PEOPLE temp matches 1.. run schedule function ARG(_PATH)loop 1s
	}
	
	func countdown()
	{
		scoreboard players remove @s ARG(skill_id)_cd 1
		execute if score @s ARG(skill_id)_cd matches 0 run scoreboard players remove #ARG(skill_id)_CD_PEOPLE temp 1
	}
}

namespace booster_skill_template(skill_id, weapon, icon) as virtual
{
	func check()
	{
		```
		if "ARG(skill_id)"[0] == "4":
			print("execute unless score @s action_time matches 1.. if score @s ARG(skill_id)_level matches 1.. unless score @s invis_buff_time matches 1.. run function ARG(_PATH)other_check")
		else:
			print("execute unless score @s action_time matches 1.. if score @s ARG(skill_id)_level matches 1.. run function ARG(_PATH)other_check")
		```
	}
	
	func other_check()
	{
		function skill:check_weapon/ARG(weapon)/run
		execute if score #ACCEPTED_WEAPON temp matches 1.. if score @s hp <= @s ARG(skill_id)_mp run tellraw @s {"translate":"warning.skill.lack_hp","font":"minecraft:uniform","color":"#efb7ab"}
		execute if score #ACCEPTED_WEAPON temp matches 1.. if score @s hp > @s ARG(skill_id)_mp run function ARG(_PATH)mp_check
	}
	
	func mp_check()
	{
		execute if score @s mp < @s ARG(skill_id)_mp run tellraw @s {"translate":"warning.skill.lack_mp","font":"minecraft:uniform","color":"#efb7ab"}
		execute if score @s mp >= @s ARG(skill_id)_mp run function ARG(_PATH)cast_effect
	}
	
	func cast_effect()
	{
		function skill:use_constraint
		
		function skill:buff/boost/run
		
		# set this buff values
		scoreboard players operation @s boost_buff_time = @s ARG(skill_id)_time
		```
		print(f"attribute @s minecraft:generic.luck modifier add {simple_buff_info_dict['boost']['uuid']} ARG(icon) 0 add")
		```
		# VVV since we got mp change below, no need to update the bar display VVV
		# execute if entity @s[tag=!hp_mp_varying] run function bar_display:update_bar/run
		
		execute positioned ~ ~-0.4 ~ run function skill:summon_font_effect/1101004effect
		playsound minecraft:skill.1101004 player @a ~ ~ ~ 1 1 0
		
		scoreboard players operation @s hp -= @s ARG(skill_id)_mp
		scoreboard players operation @s mp -= @s ARG(skill_id)_mp
		function bar_display:change/hp/dropped
		function bar_display:change/mp/dropped
		
		scoreboard players set @s action_time 12
	}
	
	folder levels()
	{
		func add()
		{
			scoreboard players add @s ARG(skill_id)_level 1
			function ARG(_PATH)check
			function skill:window/after_addition
		}
		
		func check()
		{
			scoreboard players operation @s ARG(skill_id)_time = @s ARG(skill_id)_level
			scoreboard players operation @s ARG(skill_id)_time *= #10 const
			scoreboard players set @s ARG(skill_id)_mp 30
			scoreboard players operation @s ARG(skill_id)_mp -= @s ARG(skill_id)_level
		}
		
		func set_description()
		{
			data modify block 250 0 0 Text1 set value '""'
			data modify storage ui:main temp set value [0, 0, 0, 0, 0, 0]
			execute store result storage ui:main temp[0] int 1 run scoreboard players get @s ARG(skill_id)_level
			execute store result storage ui:main temp[1] int 1 run scoreboard players get @s ARG(skill_id)_mp
			execute store result storage ui:main temp[2] int 1 run scoreboard players get @s ARG(skill_id)_time
			
			execute if score @s ARG(skill_id)_level matches ..19 run function ARG(_PATH)get_next_level
			execute if score @s ARG(skill_id)_level matches 1.. run data modify block 250 0 0 Text1 set value '[{"translate":"skill.description.level.current","with":[{"nbt":"temp[0]","storage":"ui:main"}]},{"translate":"skill.description.level.ARG(skill_id)","with":[{"nbt":"temp[1]","storage":"ui:main"},{"nbt":"temp[2]","storage":"ui:main"}]},{"nbt":"Text1","block":"250 0 0","interpret":true}]'
			data modify storage ui:main skill_level_info append from block 250 0 0 Text1
		}
		
		func get_next_level()
		{
			scoreboard players add @s ARG(skill_id)_level 1
			
			function ARG(_PATH)check
			execute store result storage ui:main temp[3] int 1 run scoreboard players get @s ARG(skill_id)_level
			execute store result storage ui:main temp[4] int 1 run scoreboard players get @s ARG(skill_id)_mp
			execute store result storage ui:main temp[5] int 1 run scoreboard players get @s ARG(skill_id)_time
			data modify block 250 0 0 Text1 set value '[{"translate":"skill.description.level.next","with":[{"nbt":"temp[3]","storage":"ui:main"}]},{"translate":"skill.description.level.ARG(skill_id)","with":[{"nbt":"temp[4]","storage":"ui:main"},{"nbt":"temp[5]","storage":"ui:main"}]}]'
			
			scoreboard players remove @s ARG(skill_id)_level 1
			execute store result score @s ARG(skill_id)_mp run data get storage ui:main temp[1]
			execute store result score @s ARG(skill_id)_time run data get storage ui:main temp[2]
			execute if score @s ARG(skill_id)_level matches 1.. run data modify block 250 0 0 Text1 set value '["\\n",{"nbt":"Text1","block":"250 0 0","interpret":true}]'
		}
	}
}


import buff as virtual
import skill_window as virtual
import 0 as virtual
import 1 as virtual
import 2 as virtual
import 3 as virtual
import 4 as virtual
# import 5 as virtual

namespace skill()
{
	folder buff() from buff();
	folder window() from skill_window();
	folder 0() from 0();
	folder 1() from 1();
	folder 2() from 2();
	folder 3() from 3();
	folder 4() from 4();
	# folder 5() from 5();
	
	# for auto attack
	folder 6()
	{
		folder 0()
		{
			folder 0()
			{
				folder 1000()
				{
					func check()
					{
						execute unless score @s action_time matches 0.. run function ARG(_PATH)invisible_check
					}
					
					func invisible_check()
					{
						execute unless score @s invis_buff_time matches 1.. run function ARG(_PATH)rope_check
						execute if score @s invis_buff_time matches 1.. run function skill:4/0/0/1003/cancel
					}
					
					func rope_check()
					{
						scoreboard players set #GLOBAL temp 0
						execute if block ~0.3 ~-0.4 ~0.3 #minecraft:climbable if block ~0.3 ~-0.4 ~-0.3 #minecraft:climbable if block ~-0.3 ~-0.4 ~0.3 #minecraft:climbable if block ~-0.3 ~-0.4 ~-0.3 #minecraft:climbable run scoreboard players set #GLOBAL temp 1
						execute if score #GLOBAL temp matches 0 unless block ~0.3 ~ ~0.3 #minecraft:climbable unless block ~0.3 ~ ~-0.3 #minecraft:climbable unless block ~-0.3 ~ ~0.3 #minecraft:climbable unless block ~-0.3 ~ ~-0.3 #minecraft:climbable run function ARG(_PATH)weapon_check
					}
				
					func weapon_check()
					{
						function skill:check_weapon/check_empty
						execute if score #USED_WEAPON temp matches 5.. unless score #USED_WEAPON temp matches 16..18 unless score #USED_WEAPON temp matches 24 run function ARG(__PATH)1001/mark_target
						execute if score #USED_WEAPON temp matches 16..18 run function ARG(_PATH)archer_check
						execute if score #USED_WEAPON temp matches 24 run function ARG(_PATH)claw_check
					}
					
					func archer_check()
					{
						scoreboard players set #LACK_BULLET temp 0
						execute if score #USED_WEAPON temp matches 16 unless score @s bullet_item matches 21..25 run scoreboard players set #LACK_BULLET temp 1
						execute if score #USED_WEAPON temp matches 18 unless score @s bullet_item matches 26..30 run scoreboard players set #LACK_BULLET temp 1
						execute unless score @s bullet_amount matches 1.. run scoreboard players set #LACK_BULLET temp 1
						execute if score @s soul_buff_time matches 1.. if score @s 3101004_weapon = #USED_WEAPON temp run scoreboard players set #LACK_BULLET temp 0
						
						execute if score #LACK_BULLET temp matches 1 run function ARG(__PATH)1003/mark_target
						execute if score #LACK_BULLET temp matches 0 run function ARG(__PATH)1002/check_distance
					}
			
					func claw_check()
					{
						scoreboard players set #LACK_BULLET temp 0
						execute unless score @s bullet_item matches ..20 run scoreboard players set #LACK_BULLET temp 1
						execute unless score @s bullet_amount matches 1.. run scoreboard players set #LACK_BULLET temp 1
						
						execute if score #LACK_BULLET temp matches 1 run function ARG(__PATH)1001/mark_target
						execute if score #LACK_BULLET temp matches 0 run function ARG(__PATH)1002/check_distance
					}
				}
				
				# melee weapon normal attack
				folder 1001() from attack_skill_template(6001001)
				{
					func mark_target()
					{
						execute unless score #USED_WEAPON temp matches 24 run function ARG(_PATH)check_weapon_distance
						execute if score #USED_WEAPON temp matches 24 run scoreboard players set #DISTANCE temp 4
						
						scoreboard players set #MAX_ENEMY temp 1
						function skill:enemy_search/search_front/search
						
						function ARG(_PATH)run
					}
					
					func check_weapon_distance()
					{
						scoreboard players operation #DISTANCE temp = #USED_WEAPON temp
						# make single hand weapon %2 be 0
						scoreboard players add #DISTANCE temp 1
						scoreboard players operation #DISTANCE temp %= #2 const
						scoreboard players add #DISTANCE temp 4
					}
				
					func set_numeric()
					{
						# melee *RANDOM* swing damage formula and default attack speed is done by afterimage functions
						scoreboard players operation @s action_time = @s weapon_speed
					}
				
					func cast_effect()
					{
						execute unless score #USED_WEAPON temp matches 24 run function skill:afterimage/warrior_swing/check
						execute if score #USED_WEAPON temp matches 24 run function skill:afterimage/claw/stab
						
						# hit_effect: 0 => None, 1 => mace, 2 => sword
						data modify storage skill:main damage_info.hit_effect set value 1
						execute unless score #USED_WEAPON temp matches ..4 unless score #USED_WEAPON temp matches 9..10 unless score #USED_WEAPON temp matches 16..21 unless score #USED_WEAPON temp matches 24 run data modify storage skill:main damage_info.hit_effect set value 2
					}
					
					func effect()
					{
						function skill:mob_effect/play_hurt_sound/run
					}
				
					func append_scheduler()
					{
						data modify storage skill:main new_schedule append value {delay:0,time:0}
						execute store result storage skill:main new_schedule[-1].time int 1 run schedule function ARG(_PATH)hit_effect 7t append
					}
				}
				
				# bullet weapon normal attack
				folder 1002() from bullet_skill_template(6001002)
				{
					func check_distance()
					{
						function ARG(_PATH)mark_target
						execute unless score #FIRST_DISTANCE temp matches ..2 run function ARG(_PATH)run_shoot
						execute if score #FIRST_DISTANCE temp matches ..2 run function ARG(_PATH)run_swing
					}
					
					func run_shoot()
					{
						execute if score #USED_WEAPON temp matches 24 run function ARG(_PATH)run
						execute if score #USED_WEAPON temp matches 16..18 run function ARG(_PATH)check_on_ground
					}
					
					func check_on_ground()
					{
						execute if entity @s[nbt={OnGround:1b}] run function ARG(_PATH)run
						execute unless entity @s[nbt={OnGround:1b}] as @e[type=zombified_piglin,tag=target] run function skill:enemy_search/clear
					}
					
					func run_swing()
					{
						execute if score #USED_WEAPON temp matches 24 run function skill:6/0/0/1001/run
						execute if score #USED_WEAPON temp matches 16..18 run function skill:6/0/0/1003/run
					}
					
					func mark_target()
					{
						execute if score #USED_WEAPON temp matches 16..18 run scoreboard players operation #DISTANCE temp = @s amazon_eyes_dist
						execute if score #USED_WEAPON temp matches 24 run scoreboard players operation #DISTANCE temp = @s keen_eyes_dist
						scoreboard players set #MAX_ENEMY temp 1
						function skill:enemy_search/search_front/search
					}
				
					func summon_bullet()
					{
						execute if score #USED_WEAPON temp matches 16 rotated ~ 0 run summon minecraft:armor_stand ^ ^0.2 ^1 {Tags:["first_bullet","new_bullet","bullet"],CustomName:'{"text":"2","font":"space:default"}',ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1,tag:{appear_delay:7,max_distance:10,skill_id:11,bullet_model:3101,CustomModelData:1}}],Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Fire:32767s,CustomNameVisible:0}
						execute if score #USED_WEAPON temp matches 18 rotated ~ 0 run summon minecraft:armor_stand ^ ^0.2 ^1 {Tags:["first_bullet","new_bullet","bullet"],CustomName:'{"text":"2","font":"space:default"}',ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1,tag:{appear_delay:8,max_distance:10,skill_id:11,bullet_model:3201,CustomModelData:1}}],Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Fire:32767s,CustomNameVisible:0}
						execute if score #USED_WEAPON temp matches 24 rotated ~ 0 run summon minecraft:armor_stand ^ ^0.2 ^1 {Tags:["first_bullet","new_bullet","bullet"],CustomName:'{"text":"2","font":"space:default"}',ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1,tag:{appear_delay:7,max_distance:10,skill_id:11,bullet_model:4000,CustomModelData:1}}],Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Fire:32767s,CustomNameVisible:0}
						
						scoreboard players operation #GLOBAL bullet_model = @s bullet_model
						execute if score @s soul_buff_time matches 1.. if score @s 3101004_weapon = #USED_WEAPON temp run scoreboard players set #GLOBAL bullet_model 3001
						scoreboard players operation #BULLET_DISTANCE temp = #DISTANCE temp
						scoreboard players remove #BULLET_DISTANCE temp 3
						execute as @e[type=armor_stand,tag=new_bullet] run function ARG(_PATH)set_bullet
					}
					
					func set_bullet()
					{
						execute store result entity @s ArmorItems[3].tag.max_distance int 1 run scoreboard players get #BULLET_DISTANCE temp
						execute store result entity @s ArmorItems[3].tag.bullet_model int 1 run scoreboard players get #GLOBAL bullet_model
					}
				
					func set_numeric()
					{
						execute if score #USED_WEAPON temp matches 16 run function skill:damage_formula/bow/normal
						execute if score #USED_WEAPON temp matches 18 run function skill:damage_formula/crossbow/normal
						execute if score #USED_WEAPON temp matches 24 run function skill:damage_formula/claw/normal
						
						scoreboard players remove @s bullet_amount 1
						execute if score @s soul_buff_time matches 1.. if score @s 3101004_weapon = #USED_WEAPON temp run scoreboard players add @s bullet_amount 1
						
						scoreboard players operation @s action_time = @s weapon_speed
						scoreboard players remove @s[scores={boost_buff_time=1..}] action_time 1
						scoreboard players add @s action_time 16
						execute if score #USED_WEAPON temp matches 18 run scoreboard players add @s action_time 1
					}
					
					func cast_effect()
					{
						execute if score #USED_WEAPON temp matches 16 run function ARG(_PATH)bow_effect
						execute if score #USED_WEAPON temp matches 18 run function ARG(_PATH)crossbow_effect
						execute if score #USED_WEAPON temp matches 24 run function ARG(_PATH)claw_effect
						
						# hit_effect: 0 => None, 1 => mace, 2 => sword
						data modify storage skill:main damage_info.hit_effect set value 1
					}
				
					func bow_effect()
					{
						function skill:afterimage/bow/shoot
						# soul arrow does not play arrow sound
						execute unless score #GLOBAL bullet_model matches 3001 run playsound minecraft:skill.attack.bow player @a ~ ~ ~ 1 1 0
					}
					
					func crossbow_effect()
					{
						function skill:afterimage/crossbow/shoot
						# soul arrow does not play arrow sound
						execute unless score #GLOBAL bullet_model matches 3001 run playsound minecraft:skill.attack.crossbow player @a ~ ~ ~ 1 1 0
					}
					
					func claw_effect()
					{
						function skill:afterimage/claw/swing
						playsound minecraft:skill.attack.throw player @a ~ ~ ~ 1 1 0
					}
				
					func effect()
					{
						function skill:mob_effect/play_hurt_sound/run
					}
					
					func append_scheduler()
					{
						data modify storage skill:main new_schedule append value {delay:0,time:0}
						execute store result storage skill:main new_schedule[-1].time int 1 run schedule function ARG(_PATH)hit_effect 1t append
					}
				}
				
				# bow/crossbow swing attack
				folder 1003() from attack_skill_template(6001003)
				{
					func mark_target()
					{
						scoreboard players set #DISTANCE temp 4
						scoreboard players set #MAX_ENEMY temp 1
						function skill:enemy_search/search_front/search
						
						function ARG(_PATH)run
					}
			
					func set_numeric()
					{
						# melee *RANDOM* swing damage formula and default attack speed is done by afterimage functions
						scoreboard players operation #KNOCKBACK_RATE temp = @s weapon_knock
						scoreboard players set #SKILL_KNOCKBACK_RATE temp 0
						
						scoreboard players operation @s action_time = @s weapon_speed
						scoreboard players remove @s[scores={boost_buff_time=1..}] action_time 1
					}
			
					func cast_effect()
					{
						execute if score #USED_WEAPON temp matches 16 run function skill:afterimage/bow/swing
						execute if score #USED_WEAPON temp matches 18 run function skill:afterimage/crossbow/swing
						
						# hit_effect: 0 => None, 1 => mace, 2 => sword
						data modify storage skill:main damage_info.hit_effect set value 1
					}
					
					func effect()
					{
						function skill:mob_effect/play_hurt_sound/run
					}
				
					func append_scheduler()
					{
						data modify storage skill:main new_schedule append value {delay:0,time:0}
						execute store result storage skill:main new_schedule[-1].time int 1 run schedule function ARG(_PATH)hit_effect 7t append
					}
				}
			}
		}
	}
	
	func install()
	{
		scoreboard objectives add right_click minecraft.used:minecraft.carrot_on_a_stick
		scoreboard objectives add base_model dummy
		scoreboard objectives add status dummy
		scoreboard objectives add motion_x dummy
		scoreboard objectives add motion_y dummy
		scoreboard objectives add motion_z dummy
		scoreboard objectives add rand_jump dummy
		# 0.4 block per unit
		scoreboard objectives add default_width dummy
		scoreboard objectives add default_height dummy
		
		scoreboard objectives add level dummy
		scoreboard objectives add exp dummy
		scoreboard objectives add exp_max dummy
		scoreboard objectives add avoidability dummy
		scoreboard objectives add weapon_defense dummy
		scoreboard objectives add magic_defense dummy
		scoreboard objectives add base_accuracy dummy
		scoreboard objectives add base_avoid dummy
		scoreboard objectives add speed dummy
		scoreboard objectives add wdef_drop dummy
		
		scoreboard objectives add crit_rate dummy
		scoreboard objectives add crit_damage dummy
		scoreboard objectives add addi_crit_rate dummy
		scoreboard objectives add addi_crit_damage dummy
		
		scoreboard objectives add kb dummy
		scoreboard objectives add kb_time dummy
		scoreboard objectives add pushed_time dummy
		scoreboard objectives add freeze_time dummy
		scoreboard objectives add poison_time dummy
		scoreboard objectives add next_poison dummy
		scoreboard objectives add poison_damage dummy
		scoreboard objectives add poison_particle dummy
		scoreboard objectives add stun_time dummy
		scoreboard objectives add stun_particle dummy
		scoreboard objectives add threat_particle dummy
		scoreboard objectives add queuing_effect dummy
		scoreboard objectives add hit_order dummy
		scoreboard objectives add hit_distance dummy
		scoreboard objectives add action_time dummy
		scoreboard objectives add f_attack_skill dummy
		scoreboard objectives add f_attack_time dummy
		scoreboard objectives add f_attack_weapon dummy
		scoreboard objectives add f_attack_action dummy
		
		scoreboard objectives add action_frame_max dummy
		scoreboard objectives add action_frame dummy
		scoreboard objectives add action_frame_s dummy
		scoreboard objectives add move_frame dummy
		scoreboard objectives add stand_frame dummy
		scoreboard objectives add hurt_sound dummy
		scoreboard objectives add die_sound dummy
		
		scoreboard objectives add target_id dummy
		scoreboard objectives add skill_id dummy
		scoreboard objectives add bullet_targeted dummy
		scoreboard objectives add mob_hp_length dummy
		scoreboard objectives add show_hp_time dummy
		
		scoreboard players set #WORLD_EXP_RATE const 1
		scoreboard players set #WORLD_DROP_RATE const 1
		scoreboard players set #WORLD_MESO_RATE const 1
		```
		for weapon in mastery_weapons:
			print(f"scoreboard objectives add {weapon}_mastery dummy")
			print(f"scoreboard objectives add {weapon}_accuracy dummy")
			print(f"scoreboard objectives add {weapon}_color dummy")
		
		non_skill_attacks = set(["6001001", "6001002", "6001003", "1000006", "3000006"])
		for skill in skill_ids:
			if skill not in non_skill_attacks:
				print(f"scoreboard objectives add {skill}_level dummy")
			print(f"scoreboard objectives add {skill}_eid dummy")
		```
		function ARG(_PATH)buff/install
		function ARG(_PATH)window/install
		function ARG(_PATH)0/install
		function ARG(_PATH)1/install
		function ARG(_PATH)2/install
		function ARG(_PATH)3/install
		function ARG(_PATH)4/install
		# function ARG(_PATH)5/install
	}
	
	folder loop()
	{
		func schedule_1s()
		{
			execute as @e[type=zombified_piglin,tag=enemy,tag=!dead] run function ARG(_PATH)enemy
		}
		
		func enemy()
		{
			execute if score @s weaken_time matches 1.. run function skill:4/0/0/1002/mob/countdown
			execute if score @s 2101003_time matches 1.. run function skill:2/1/0/1003/mob/countdown
			execute if score @s show_hp_time matches 1.. run function skill:calculate_damage/update_hp_display/countdown
		}
		
		func schedule_10s()
		{
			execute as @e[type=zombified_piglin,tag=enemy,tag=!dead] run data modify entity @s AngerTime set value 2147483647
		}
		
		func schedule_1d()
		{
			scoreboard players set #BULLET_ID number 1
		}
	}
	
	folder main()
	{
		func run()
		{
			execute as @e[type=area_effect_cloud,scores={type=1}] run function ARG(_PATH)font_effect_update/check
			execute as @e[type=armor_stand,tag=bullet] run function skill:bullet/check
			execute as @e[type=armor_stand,tag=model_animation] run function ARG(_PATH)model_animation_update
			execute as @e[type=armor_stand,tag=afterimage] run function skill:afterimage/update
			execute as @e[type=zombified_piglin,tag=enemy] run function ARG(_PATH)enemy/run
			execute as @e[type=magma_cube,tag=!original] unless predicate skill:riding_enemy run function ARG(_PATH)clear_magma_cube
			
			execute as @a[scores={action_time=1..}] run function ARG(_PATH)action/countdown
			execute as @a[scores={teleport_time=1..}] run function ARG(_PATH)tp_countdown
			execute as @a[tag=delay_tp] at @s run function skill:2/1/0/1002/move/horizon/run
			
			# used skill check
			execute as @a[scores={right_click=1..},tag=!dead] at @s run function skill:check_skill/run
		}
		
		func clear_magma_cube()
		{
			tp @s 0 -10 0
			kill @s
		}
		
		folder font_effect_update()
		{
			func check()
			{
				execute store result score #GLOBAL temp run data get entity @s Age
				execute if score #GLOBAL temp matches 1.. run function ARG(_PATH)update
			}
			
			func update()
			{
				scoreboard players operation #GLOBAL temp %= #10 const
				execute if score #GLOBAL temp matches 0 run data remove entity @s Tags[0]
				
				data modify storage skill:main effect_font set from entity @s Tags[0]
				data modify block 250 0 0 Text1 set value '[{"nbt":"effect_font","storage":"skill:main","interpret":true},{"text":"F","font":"space:default"},{"score":{"name":"#GLOBAL","objective":"temp"}},{"text":"F","font":"space:default"}]'
				data modify entity @s CustomName set from block 250 0 0 Text1
			}
		}
		
		func model_animation_update()
		{
			execute store result score #GLOBAL temp run scoreboard players add @s life 1
			execute store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players operation #GLOBAL temp += @s base_model
			
			execute if score @s life = @s max_life run kill @s
		}
		
		folder enemy()
		{
			func run()
			{
				execute unless score @s kb_time matches 1.. if entity @s[tag=!dead] run function ARG(_PATH)status_change/check
				execute if score @s action_frame_max matches 1.. unless entity @s[scores={kb_time=1..,status=..3}] run function ARG(_PATH)status_change/update_frame
				execute if entity @s[tag=color_changed] run function ARG(_PATH)status_change/color/check
				
				execute if score @s kb_time matches 1.. run function ARG(_PATH)kb/countdown
				execute if score @s pushed_time matches 1.. run function ARG(_PATH)push_countdown
				execute if entity @s[tag=mob_effect] run function ARG(_PATH)mob_effect/run
				execute if score @s bullet_targeted matches 1.. at @s run function ARG(_PATH)move_bullets
			}
			
			folder status_change()
			{
				func check()
				{
					scoreboard players set #GLOBAL temp -1
					execute if data entity @s {OnGround:0b} run function ARG(_PATH)check_jump
					execute if score #GLOBAL temp matches -1 run function ARG(_PATH)check_motion
					
					execute unless score @s status = #GLOBAL temp run function ARG(_PATH)change
					
					scoreboard players remove @s[tag=!no_jump,scores={status=2..}] rand_jump 1
					execute if score @s rand_jump matches 0 run function ARG(_PATH)force_jump/try
				}
				
				folder force_jump()
				{
					func try()
					{
						scoreboard players set @s rand_jump 20
						execute unless data entity @s AngryAt run function ARG(_PATH)rand_jump
						execute if data entity @s AngryAt run function ARG(_PATH)check_target
					}
				
					func rand_jump()
					{
						function main:rand_rate
						execute if score #RAND_RESULT temp matches ..9 store result entity @s Motion[1] double 0.1 run scoreboard players get #5 const
					}
					
					func check_target()
					{
						execute if data entity @s {AngryAt:[I;0,2,0,2]} run function ARG(_PATH)rand_jump
						execute unless data entity @s {AngryAt:[I;0,2,0,2]} if score @s status matches 3 store result entity @s Motion[1] double 0.1 run scoreboard players get #5 const
					}
				}
				
				func check_jump()
				{
					execute if entity @s[tag=no_jump] run function ARG(_PATH)prevent_jump
					scoreboard players set #GLOBAL temp 0
				}
				
				func prevent_jump()
				{
					execute store result score @s motion_y run data get entity @s Motion[1] 100
					execute if score @s motion_y matches 1.. run data modify entity @s Motion[1] set value 0.0
				}
				
				func check_motion()
				{
					execute store result score @s motion_x run data get entity @s Motion[0] 100
					execute store result score @s motion_z run data get entity @s Motion[2] 100
					scoreboard players set #GLOBAL temp 2
					execute if score @s motion_x matches 0 if score @s motion_z matches 0 run scoreboard players add #GLOBAL temp 1
				}
				
				func update_frame()
				{
					scoreboard players add @s action_frame 1
					execute if score @s action_frame = @s action_frame_max run scoreboard players set @s action_frame 0
					
					scoreboard players operation #GLOBAL temp = @s base_model
					scoreboard players operation #GLOBAL temp += @s action_frame_s
					execute store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players operation #GLOBAL temp += @s action_frame
				}
				
				func change()
				{
					scoreboard players reset @s action_frame_max
					scoreboard players set @s action_frame_s 2
					execute if score #GLOBAL temp matches 2 if score @s move_frame matches 1.. run scoreboard players operation @s action_frame_max = @s move_frame
					execute if score #GLOBAL temp matches 3 if score @s stand_frame matches 1.. run scoreboard players operation @s action_frame_s += @s move_frame
					execute if score #GLOBAL temp matches 3 if score @s stand_frame matches 1.. run scoreboard players operation @s action_frame_max = @s stand_frame
					scoreboard players set @s action_frame -1
					
					scoreboard players set @s[tag=!no_jump] rand_jump 20
					
					scoreboard players operation @s status = #GLOBAL temp
					execute unless score @s action_frame_max matches 1.. store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players operation #GLOBAL temp += @s base_model
				}
				
				folder color()
				{
					func check()
					{
						execute if score @s freeze_time matches 1.. run function ARG(_PATH)freeze/run
						execute if score @s poison_time matches 1.. at @s run function ARG(_PATH)poison/run
						
						```
						raise Warning("TODO: check all other color change effects")
						```
						# execute unless score @s freeze_time matches 1.. unless score @s poison_time matches 1.. unless score @s burn_time matches 1.. run tag @s remove color_changed
						execute unless score @s freeze_time matches 1.. unless score @s poison_time matches 1.. run tag @s remove color_changed
						execute if entity @s[tag=!color_changed] run data modify entity @s ArmorItems[3].tag.CustomPotionColor set value -1
					}
					
					func other_color_check()
					{
						data modify entity @s[scores={freeze_time=1..}] ArmorItems[3].tag.CustomPotionColor set value 12580095
						data modify entity @s[scores={poison_time=1..}] ArmorItems[3].tag.CustomPotionColor set value 2779438
					}
					
					folder freeze()
					{
						func run()
						{
							scoreboard players remove @s freeze_time 1
							execute if score @s freeze_time matches 0 run function ARG(_PATH)reset
							
						}
						
						func reset()
						{
							scoreboard players reset @s freeze_time
							function ARG(__PATH)other_color_check
						}
					}
					
					folder poison()
					{
						func run()
						{
							scoreboard players remove @s next_poison 1
							scoreboard players remove @s poison_particle 1
							execute if score @s next_poison matches 0 run function ARG(_PATH)next
							execute if score @s poison_particle matches 0 run function ARG(_PATH)show_particle
						}
						
						func show_particle()
						{
							scoreboard players operation #DEFAULT_SIZE temp = @s default_height
							execute positioned ~ ~0.4 ~ run function ARG(_PATH)show_particle_at_height
							scoreboard players set @s poison_particle 7
						}
						
						func show_particle_at_height()
						{
							scoreboard players remove #DEFAULT_SIZE temp 1
							execute if score #DEFAULT_SIZE temp matches -1 run function skill:summon_font_effect/2101005mob
							execute if score #DEFAULT_SIZE temp matches 0.. positioned ~ ~0.4 ~ run function ARG(_PATH)show_particle_at_height
						}
						
						func next()
						{
							scoreboard players remove @s poison_time 1
							scoreboard players set @s next_poison 20
							
							execute if entity @s[tag=!dead] run function ARG(_PATH)damage
							
							execute if score @s poison_time matches 0 run function ARG(_PATH)reset
						}
						
						func damage()
						{
							function skill:mob_effect/play_hurt_sound/run
							
							scoreboard players operation @s hp -= @s poison_damage
							scoreboard players operation @s hp > #1 const
							function skill:calculate_damage/update_hp_display/run
							
							scoreboard players operation @s display_number = @s poison_damage
							scoreboard players set @s display_num_type 0
							scoreboard players operation #NUMBER_HEIGHT temp = @s default_height
							execute positioned ~ ~-0.4 ~ run function skill:show_num_at_height
							
							scoreboard players set @s[scores={hp=1}] poison_time 0
						}
						
						func reset()
						{
							scoreboard players reset @s poison_particle
							scoreboard players reset @s next_poison
							scoreboard players reset @s poison_time
							function ARG(__PATH)other_color_check
						}
					}
				}
			}
			
			folder kb()
			{
				func countdown()
				{
					scoreboard players remove @s kb_time 1
					execute if score @s kb_time matches 0 run function ARG(_PATH)reset
				}
			
				func reset()
				{
					function ARG(__PATH)status_change/run
					attribute @s minecraft:generic.movement_speed modifier remove 495407c5-10c0-4270-84ed-c566e01e6952
					scoreboard players reset @s kb_time
				}
			}
			
			func push_countdown()
			{
				scoreboard players remove @s pushed_time 1
				scoreboard players reset @s[scores={pushed_time=0}] pushed_time
			}
			
			folder mob_effect()
			{
				func run()
				{
					execute if score @s stun_time matches 1.. run function ARG(_PATH)stun_countdown/run
					execute if score @s weaken_from matches 2 run function ARG(_PATH)threaten_effect/run
				}
				
				folder stun_countdown()
				{
					func run()
					{
						scoreboard players remove @s stun_particle 1
						scoreboard players remove @s stun_time 1
						execute if score @s stun_time matches 0 run function ARG(_PATH)reset
						execute if score @s stun_particle matches 0 at @s run function ARG(_PATH)show_particle
					}
							
					func show_particle()
					{
						scoreboard players operation #DEFAULT_SIZE temp = @s default_height
						execute positioned ~ ~0.4 ~ run function ARG(_PATH)show_particle_at_height
						scoreboard players set @s stun_particle 6
					}
					
					func show_particle_at_height()
					{
						scoreboard players remove #DEFAULT_SIZE temp 1
						execute if score #DEFAULT_SIZE temp matches -1 run function skill:summon_font_effect/3101005mob
						execute if score #DEFAULT_SIZE temp matches 0.. positioned ~ ~0.4 ~ run function ARG(_PATH)show_particle_at_height
					}
					
					func reset()
					{
						scoreboard players reset @s stun_particle
						scoreboard players reset @s stun_time
						
						attribute @s minecraft:generic.movement_speed modifier remove 98fb435b-7645-4b76-8504-ee4f9e13fdec
						execute unless score @s weaken_from matches 2 run tag @s remove mob_effect
					}
				}
				
				folder threaten_effect()
				{
					func run()
					{
						scoreboard players remove @s threat_particle 1
						execute if score @s threat_particle matches 0 at @s run function ARG(_PATH)show_particle
					}
							
					func show_particle()
					{
						scoreboard players operation #DEFAULT_SIZE temp = @s default_height
						execute positioned ~ ~0.4 ~ run function ARG(_PATH)show_particle_at_height
						scoreboard players set @s threat_particle 11
					}
					
					func show_particle_at_height()
					{
						scoreboard players remove #DEFAULT_SIZE temp 1
						execute if score #DEFAULT_SIZE temp matches -1 run function skill:summon_font_effect/1201006mob
						execute if score #DEFAULT_SIZE temp matches 0.. positioned ~ ~0.4 ~ run function ARG(_PATH)show_particle_at_height
					}
				}
			}
			
			func move_bullets()
			{
				scoreboard players set #HIT_BULLET temp 0
				scoreboard players operation #GLOBAL temp = @s number
				execute as @e[type=armor_stand,tag=bullet,scores={life=0..}] if score @s target_id = #GLOBAL temp run function skill:bullet/move
				scoreboard players operation @s bullet_targeted -= #HIT_BULLET temp
			}
		}
		
		folder action()
		{
			func countdown()
			{
				execute if score @s f_attack_time matches 1.. run function ARG(_PATH)final_attack/countdown
				scoreboard players remove @s action_time 1
				execute if score @s action_time matches 0 run function ARG(_PATH)reset
			}
			
			func reset()
			{
				attribute @s minecraft:generic.movement_speed modifier remove 5b908c48-54cb-4388-aa76-82f61b02032d
				effect clear @s minecraft:jump_boost
				execute if score @s jump_buff_num matches 1 run effect give @s minecraft:jump_boost 1000000 0 true
				execute if score @s jump_buff_num matches 2 run effect give @s minecraft:jump_boost 1000000 1 true
				scoreboard players reset @s action_time
			}
			
			folder final_attack()
			{
				func countdown()
				{
					scoreboard players remove @s f_attack_time 1
					execute if score @s f_attack_time matches 0 at @s run function ARG(_PATH)check
				}
				
				func check()
				{
					execute if score @s f_attack_weapon matches 5..14 run function skill:1/0/0/0006/pre_set
					execute if score @s f_attack_weapon matches 16..18 run function skill:3/0/0/0006/pre_set
					scoreboard players reset @s f_attack_time
				}
			}
		}
		
		func tp_countdown()
		{
			scoreboard players remove @s teleport_time 1
			scoreboard players reset @s[scores={teleport_time=0}] teleport_time
		}
	}
	
	func use_constraint()
	{
		# basic skill constraints
		scoreboard players operation @s next_hp_recover = @s hp_recover_time
		attribute @s minecraft:generic.movement_speed modifier add 5b908c48-54cb-4388-aa76-82f61b02032d skill_action -0.95 multiply
		effect give @s minecraft:jump_boost 1000000 128 true
	}
	
	func hunt_exp()
	{
		```
		raise Warning("TODO: holy symbol rate calculation")
		```
		scoreboard players operation #EXP_GAIN temp *= #WORLD_EXP_RATE const
		execute if score @s level matches ..199 run scoreboard players operation @s exp += #EXP_GAIN temp
		scoreboard players reset #EXP_GAIN temp
		execute if score @s exp >= @s exp_max run function stat:exp/level_up
	}
	
	folder player()
	{
		func reset_mastery()
		{
			```
			for weapon in mastery_weapons:
				print(f"scoreboard players set @s {weapon}_mastery 10")
				print(f"scoreboard players set @s {weapon}_color 255")
				print(f"scoreboard players set @s {weapon}_accuracy 0")
			```
		}
	
		func reset_all_skill()
		{
			scoreboard players reset @s 0001000_level
			scoreboard players reset @s 0001001_level
			scoreboard players reset @s 0001002_level
			scoreboard players set @s hp_recovery 10
			scoreboard players reset @s 1000000_level
			scoreboard players set @s addi_hp_level 0
			scoreboard players set @s addi_hp_point 0
			scoreboard players reset @s 1000001_level
			scoreboard players set @s hp_recover_time 10
			scoreboard players reset @s 1000002_level
			scoreboard players reset @s 1001003_level
			scoreboard players reset @s 1001004_level
			scoreboard players reset @s 1001005_level
			scoreboard players set @s mp_recovery 3
			scoreboard players reset @s 2000000_level
			scoreboard players set @s addi_mp_level 0
			scoreboard players set @s addi_mp_point 0
			scoreboard players reset @s 2000001_level
			scoreboard players reset @s 2001002_level
			scoreboard players reset @s 2001003_level
			scoreboard players reset @s 2001004_level
			scoreboard players reset @s 2001005_level
			scoreboard players set @s base_accuracy 0
			scoreboard players reset @s 3000000_level
			scoreboard players set @s crit_rate 0
			scoreboard players set @s crit_damage 0
			scoreboard players reset @s 3000001_level
			scoreboard players set @s amazon_eyes_dist 9
			scoreboard players reset @s 3000002_level
			scoreboard players reset @s 3001003_level
			scoreboard players reset @s 3001004_level
			scoreboard players reset @s 3001005_level
			scoreboard players set @s base_avoid 0
			scoreboard players reset @s 4000000_level
			scoreboard players set @s keen_eyes_dist 9
			scoreboard players reset @s 4000001_level
			scoreboard players reset @s 4001002_level
			scoreboard players reset @s 4001003_level
			scoreboard players reset @s 4001334_level
			scoreboard players reset @s 4001344_level
			
			function ARG(_PATH)reset_mastery
			scoreboard players reset @s 1100000_level
			scoreboard players reset @s 1100001_level
			scoreboard players set @s sword_final_rate 0
			scoreboard players reset @s 1100002_level
			scoreboard players set @s axe_final_rate 0
			scoreboard players reset @s 1100003_level
			scoreboard players reset @s 1101004_level
			scoreboard players reset @s 1101005_level
			scoreboard players reset @s 1101006_level
			scoreboard players reset @s 1101007_level
			scoreboard players reset @s 1200001_level
			scoreboard players set @s blunt_final_rate 0
			scoreboard players reset @s 1200003_level
			scoreboard players reset @s 1201005_level
			scoreboard players reset @s 1201006_level
			scoreboard players reset @s 1300000_level
			scoreboard players reset @s 1300001_level
			scoreboard players set @s spear_final_rate 0
			scoreboard players reset @s 1300002_level
			scoreboard players set @s p_arm_final_rate 0
			scoreboard players reset @s 1300003_level
			scoreboard players reset @s 1301004_level
			scoreboard players reset @s 1301005_level
			scoreboard players reset @s 1301006_level
			scoreboard players reset @s 1301007_level
			scoreboard players set @s 2100000_rate 0
			scoreboard players reset @s 2100000_level
			scoreboard players reset @s 2101001_level
			scoreboard players reset @s 2101002_level
			scoreboard players reset @s 2101003_level
			scoreboard players reset @s 2101004_level
			scoreboard players reset @s 2101005_level
			scoreboard players reset @s 2201004_level
			scoreboard players reset @s 2201005_level
			scoreboard players reset @s 2301002_level
			scoreboard players reset @s 2301003_level
			scoreboard players reset @s 2301004_level
			scoreboard players reset @s 2301005_level
			scoreboard players reset @s 3100000_level
			scoreboard players set @s bow_final_rate 0
			scoreboard players reset @s 3100001_level
			scoreboard players reset @s 3101002_level
			scoreboard players reset @s 3101003_level
			scoreboard players reset @s 3101004_level
			scoreboard players reset @s 3101005_level
			scoreboard players reset @s 3200000_level
			scoreboard players set @s cbow_final_rate 0
			scoreboard players reset @s 3200001_level
			scoreboard players reset @s 3201002_level
			scoreboard players reset @s 3201005_level
			scoreboard players reset @s 4100000_level
			scoreboard players reset @s 4100001_level
			scoreboard players reset @s 4100002_level
			scoreboard players reset @s 4101003_level
			scoreboard players reset @s 4101004_level
			scoreboard players reset @s 4101005_level
			scoreboard players reset @s 4200000_level
			scoreboard players reset @s 4201002_level
			scoreboard players reset @s 4201004_level
			scoreboard players reset @s 4201005_level
		}
	}
	
	folder bullet()
	{
		func setting()
		{
			execute facing entity @s eyes positioned as @s run tp @s ~ ~ ~ ~180 0
			scoreboard players add #BULLET_AMOUNT temp 1
			
			scoreboard players operation @s number = #BULLET_ID number
			scoreboard players operation @s target_id = #GLOBAL temp
			execute store result score @s life run data get entity @s ArmorItems[3].tag.appear_delay -1
			execute store result score @s skill_id run data get entity @s ArmorItems[3].tag.skill_id
			tag @s remove new_bullet
		}
		
		func no_target_setting()
		{
			execute positioned as @s run tp @s ~ ~ ~ ~ 0
			execute store result score @s life run data get entity @s ArmorItems[3].tag.appear_delay -1
			execute store result score @s max_life run data get entity @s ArmorItems[3].tag.max_distance
			tag @s remove new_bullet
		}
		
		func check()
		{
			scoreboard players add @s life 1
			execute if score @s life matches 0 run function ARG(_PATH)appear
			# no target bullet
			execute if score @s life matches 0.. unless score @s target_id matches -2147483648.. at @s run function ARG(_PATH)wander
		}
		
		func appear()
		{
			data modify entity @s ArmorItems[3].tag.CustomModelData set from entity @s ArmorItems[3].tag.bullet_model
			data modify entity @s CustomNameVisible set value 1
		}
		
		func wander()
		{
			execute if score @s life > @s max_life run kill @s
			tp @s ^ ^ ^0.7
		}
		
		func move()
		{
			execute if entity @s[distance=..0.7] run function ARG(_PATH)hit
			execute facing entity @s eyes positioned as @s run tp @s ^ ^ ^-0.7
		}
		
		func hit()
		{
			execute if entity @s[tag=first_bullet] run function ARG(_PATH)append_scheduler
			scoreboard players add #HIT_BULLET temp 1
			kill @s
		}
		
		func append_scheduler()
		{
			scoreboard players operation #BULLET_ID temp = @s number
			data modify storage skill:main new_schedule set value []
			function ARG(_PATH)find_parent_skill/run
		}
		
		folder find_parent_skill()
		{
			```
			def bs_bullet_skill(id_list, start, end):
				if len(id_list) == 1:
					print("func run()")
					print("{")
					print(f"\texecute if score @s skill_id matches {id_list[0][1]} run function skill:{id_list[0][0][0]}/{id_list[0][0][1]}/{id_list[0][0][2]}/{id_list[0][0][3:]}/append_scheduler")
					print(f"\texecute if score @s skill_id matches {id_list[0][1]} as @e[type=zombified_piglin,tag=enemy] if score @s number = #GLOBAL temp run function skill:{id_list[0][0][0]}/{id_list[0][0][1]}/{id_list[0][0][2]}/{id_list[0][0][3:]}/bullet_hit/run")
					print("}")
					return
				
				if start == end:
					return
				
				mid = (start + end) // 2
				mid_right = mid + 1
				
				if start == 0 and end == len(id_list) - 1:
					print("func run()")
				else:
					print(f"func {start}_{end}()")
				print("{")
				if start == mid:
					print(f"\texecute if score @s skill_id matches {id_list[start][1]} run function skill:{id_list[start][0][0]}/{id_list[start][0][1]}/{id_list[start][0][2]}/{id_list[start][0][3:]}/append_scheduler")
					print(f"\texecute if score @s skill_id matches {id_list[start][1]} as @e[type=zombified_piglin,tag=enemy] if score @s number = #GLOBAL temp run function skill:{id_list[start][0][0]}/{id_list[start][0][1]}/{id_list[start][0][2]}/{id_list[start][0][3:]}/bullet_hit/run")
				else:
					print(f"\texecute if score @s skill_id matches {id_list[start][1]}..{id_list[mid][1]} run function ARG(_PATH){start}_{mid}")
				if mid_right == end:
					print(f"\texecute if score @s skill_id matches {id_list[end][1]} run function skill:{id_list[end][0][0]}/{id_list[end][0][1]}/{id_list[end][0][2]}/{id_list[end][0][3:]}/append_scheduler")
					print(f"\texecute if score @s skill_id matches {id_list[end][1]} as @e[type=zombified_piglin,tag=enemy] if score @s number = #GLOBAL temp run function skill:{id_list[end][0][0]}/{id_list[end][0][1]}/{id_list[end][0][2]}/{id_list[end][0][3:]}/bullet_hit/run")
				else:
					print(f"\texecute if score @s skill_id matches {id_list[mid_right][1]}..{id_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
				print("}")
				
				bs_bullet_skill(id_list, start, mid)
				bs_bullet_skill(id_list, mid_right, end)
			
			with open(PROJ_DIR + "/../skill_bullet_ids.csv") as f:
				skill_bullet_ids = f.read().split("\n")
				for i in range(len(skill_bullet_ids)):
					skill_bullet_ids[i] = skill_bullet_ids[i].split(",")
					skill_bullet_ids[i][1] = int(skill_bullet_ids[i][1])
			
			bs_bullet_skill(skill_bullet_ids, 0, len(skill_bullet_ids) - 1)
			```
		}
	}
	
	folder check_skill()
	{
		func run()
		{
			execute store result score #USING_SKILL temp run data get entity @s[nbt={SelectedItem:{id:"minecraft:carrot_on_a_stick"}}] SelectedItem.tag.CustomModelData
			function ARG(_PATH)binary_search/run
			scoreboard players reset @s right_click
		}
		
		folder binary_search()
		{
			```
			def binary_search_skill(skill_list, start, end):
				if len(skill_list) == 1:
					print("func run()")
					print("{")
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[0][1]} run function skill:{skill_list[0][0][0]}/{skill_list[0][0][1]}/{skill_list[0][0][2]}/{skill_list[0][0][3:]}/check")
					print("}")
					return
				
				if start == end:
					return
				
				mid = (start + end) // 2
				mid_right = mid + 1
				
				if start == 0 and end == len(skill_list) - 1:
					print("func run()")
				else:
					print(f"func {start}_{end}()")
				print("{")
				if start == mid:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[start][1]} run function skill:{skill_list[start][0][0]}/{skill_list[start][0][1]}/{skill_list[start][0][2]}/{skill_list[start][0][3:]}/check")
				else:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[start][1]}..{skill_list[mid][1]} run function ARG(_PATH){start}_{mid}")
				if mid_right == end:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[end][1]} run function skill:{skill_list[end][0][0]}/{skill_list[end][0][1]}/{skill_list[end][0][2]}/{skill_list[end][0][3:]}/check")
				else:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[mid_right][1]}..{skill_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
				print("}")
				
				binary_search_skill(skill_list, start, mid)
				binary_search_skill(skill_list, mid_right, end)
			
			with open(PROJ_DIR + "/../skill_icons.csv") as f:
				skill_models = f.read().split("\n")
				for i in range(len(skill_models)):
					skill_models[i] = skill_models[i].split(",")
					skill_models[i][1] = int(skill_models[i][1])
			
			binary_search_skill(skill_models, 0, len(skill_models) - 1)
			```
		}
	}
	
	folder check_weapon()
	{
		func check_empty()
		{
			scoreboard players set #ACCEPTED_WEAPON temp 0
			
			scoreboard players operation #USED_WEAPON temp = @s weapon_type
			execute if score #USED_WEAPON temp matches 0 run tellraw @s {"translate":"warning.skill.no_weapon","font":"minecraft:uniform","color":"#efb7ab"}
		}
		
		folder single_hand()
		{
			func run()
			{
				function ARG(__PATH)check_empty
				execute if score #USED_WEAPON temp matches 1.. run function ARG(_PATH)check
			}
			
			func check()
			{
				scoreboard players operation #ACCEPTED_WEAPON temp = #USED_WEAPON temp
				scoreboard players operation #ACCEPTED_WEAPON temp %= #2 const
				execute if score #ACCEPTED_WEAPON temp matches 0 run tellraw @s {"translate":"warning.skill.wrong_weapon","font":"minecraft:uniform","color":"#efb7ab"}
			}
		}
		
		```
		def check_weapon_range(range_string):
			print(f'''
			func run()
			{{
				function ARG(__PATH)check_empty
				execute if score #USED_WEAPON temp matches 1.. run function ARG(_PATH)check
			}}
			
			func check()
			{{
				execute store success score #ACCEPTED_WEAPON temp if score #USED_WEAPON temp matches {range_string}
				execute if score #ACCEPTED_WEAPON temp matches 0 run tellraw @s {{"translate":"warning.skill.wrong_weapon","font":"minecraft:uniform","color":"#efb7ab"}}
			}}''')
		
		type_id_dict = {
			"dagger": "23",
			"claw": "24",
			"archer": "16..18",
			"bow": "16",
			"crossbow": "18",
			"sword": "7..8",
			"axe": "5..6",
			"blunt": "9..10",
			"spear": "12",
			"polearm": "14"
		} # to avoid single bracelet in a line
		
		for t in type_id_dict:
			print(f"folder {t}()")
			print("{")
			check_weapon_range(type_id_dict[t])
			print("}")
		```
	}

	folder enemy_search()
	{
		func clear()
		{
			tag @s remove first_target
			tag @s remove target
		}
		
		folder search_front() from for_loop().for("#DISTANCE temp", "if score #FOUND_ENEMY temp < #MAX_ENEMY temp positioned ^ ^ ^0.7")
		{
			func search()
			{
				scoreboard players reset #PAIR_NUMBER temp
				scoreboard players reset #FIRST_DISTANCE temp
				scoreboard players set #CUR_DISTANCE temp 0
				scoreboard players set #FOUND_ENEMY temp 0
				
				execute at @s rotated ~ 0 positioned ^ ^ ^100 run summon minecraft:area_effect_cloud ~ ~ ~ {Duration:1,UUID:[I;0,3,0,3]}
				execute at @s rotated ~ 0 positioned ^ ^ ^-1.8 run function ARG(_PATH)run
				tag @e[type=magma_cube,tag=target] remove target
				kill 00000000-0000-0003-0000-000000000003
			}
			
			func execute()
			{
				# simulating sector detection, larger y axis detection on further distance
				execute if score #CUR_DISTANCE temp matches 5.. positioned ~-1.8 ~-0.6 ~-1.8 as @e[type=#skill:enemy,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=2.2,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				execute unless score #CUR_DISTANCE temp matches 5.. positioned ~-1.8 ~ ~-1.8 as @e[type=#skill:enemy,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=1,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				scoreboard players add #CUR_DISTANCE temp 1
			}
			
			func try_mark()
			{
				execute unless score #FIRST_DISTANCE temp matches 0.. run scoreboard players operation #FIRST_DISTANCE temp = #CUR_DISTANCE temp
				execute if score #FOUND_ENEMY temp < #MAX_ENEMY temp run function ARG(_PATH)type_check
			}
			
			func type_check()
			{
				execute if entity @s[type=zombified_piglin] run function ARG(_PATH)mark
				# if both piglin and magma_cube pair are found, magma_cube must be right after the piglin
				execute if entity @s[type=magma_cube] unless score @s number = #PAIR_NUMBER temp run function ARG(_PATH)mark_owner
			}
			
			func mark()
			{
				tag @s add target
				scoreboard players operation #PAIR_NUMBER temp = @s number
				scoreboard players add #FOUND_ENEMY temp 1
			}
			
			func mark_owner()
			{
				scoreboard players operation #PAIR_NUMBER temp = @s number
				execute as @e[type=zombified_piglin,tag=paired_mob] if score @s number = #PAIR_NUMBER temp run function ARG(_PATH)mark
				tag @s add target
			}
		}
		
		folder search_front_pure_order() from for_loop().for("#DISTANCE temp", "if score #FOUND_ENEMY temp < #MAX_ENEMY temp positioned ^ ^ ^0.7")
		{
			func search()
			{
				scoreboard players set #CUR_DISTANCE temp 0
				scoreboard players set #FOUND_ENEMY temp 0
				data modify storage skill:main temp set value []
				
				execute at @s rotated ~ 0 positioned ^ ^ ^100 run summon minecraft:area_effect_cloud ~ ~ ~ {Duration:1,UUID:[I;0,3,0,3]}
				execute at @s rotated ~ 0 positioned ^ ^ ^-1.8 run function ARG(_PATH)run
				tag @e[type=magma_cube,tag=target] remove target
				kill 00000000-0000-0003-0000-000000000003
			}
			
			func execute()
			{
				# simulating sector detection, larger y axis detection on further distance
				execute if score #CUR_DISTANCE temp matches 5.. positioned ~-1.8 ~-0.6 ~-1.8 as @e[type=#skill:enemy,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=2.2,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				execute unless score #CUR_DISTANCE temp matches 5.. positioned ~-1.8 ~ ~-1.8 as @e[type=#skill:enemy,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=1,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				scoreboard players add #CUR_DISTANCE temp 1
			}
			
			func try_mark()
			{
				execute if score #FOUND_ENEMY temp < #MAX_ENEMY temp run function ARG(_PATH)type_check
			}
			
			func type_check()
			{
				execute if entity @s[type=zombified_piglin] run function ARG(_PATH)mark
				# if both piglin and magma_cube pair are found, magma_cube must be right after the piglin
				execute if entity @s[type=magma_cube] unless score @s number = #PAIR_NUMBER temp run function ARG(_PATH)mark_owner
			}
			
			func mark()
			{
				execute if score #FOUND_ENEMY temp matches ..4 run function ARG(_PATH)record_dists
				
				tag @s add target
				scoreboard players operation #PAIR_NUMBER temp = @s number
				execute store result score @s hit_distance run scoreboard players operation @s hit_order = #FOUND_ENEMY temp
				scoreboard players remove @s[scores={hit_distance=5}] hit_distance 1
				scoreboard players add #FOUND_ENEMY temp 1
			}
			
			func record_dists()
			{
				data modify storage skill:main temp append value 0
				execute store result storage skill:main temp[-1] int 1 run scoreboard players get #FOUND_ENEMY temp
			}
			
			func mark_owner()
			{
				scoreboard players operation #PAIR_NUMBER temp = @s number
				execute as @e[type=zombified_piglin,tag=paired_mob] if score @s number = #PAIR_NUMBER temp run function ARG(_PATH)mark
				tag @s add target
			}
		}
		
		folder search_front_rec_dist() from for_loop().for("#DISTANCE temp", "if score #FOUND_ENEMY temp < #MAX_ENEMY temp positioned ^ ^ ^0.7")
		{
			func search()
			{
				scoreboard players reset #FIRST_DISTANCE temp
				scoreboard players set #CUR_DISTANCE temp 0
				scoreboard players set #GLOBAL hit_distance -1
				scoreboard players set #FOUND_ENEMY temp 0
				data modify storage skill:main temp set value []
				
				execute at @s rotated ~ 0 positioned ^ ^ ^100 run summon minecraft:area_effect_cloud ~ ~ ~ {Duration:1,UUID:[I;0,3,0,3]}
				execute at @s rotated ~ 0 positioned ^ ^ ^-1.8 run function ARG(_PATH)run
				tag @e[type=magma_cube,tag=target] remove target
				kill 00000000-0000-0003-0000-000000000003
			}
			
			func execute()
			{
				# simulating sector detection, larger y axis detection on further distance
				execute if score #CUR_DISTANCE temp matches 5.. positioned ~-1.8 ~-0.6 ~-1.8 as @e[type=#skill:enemy,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=2.2,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				execute unless score #CUR_DISTANCE temp matches 5.. positioned ~-1.8 ~ ~-1.8 as @e[type=#skill:enemy,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=1,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				scoreboard players add #CUR_DISTANCE temp 1
			}
			
			func record_first()
			{
				scoreboard players operation #FIRST_DISTANCE temp = #CUR_DISTANCE temp
				tag @s add first_target
			}
			
			func try_mark()
			{
				execute if score #FOUND_ENEMY temp < #MAX_ENEMY temp run function ARG(_PATH)type_check
			}
			
			func type_check()
			{
				execute if entity @s[type=zombified_piglin] run function ARG(_PATH)mark
				# if both piglin and magma_cube pair are found, magma_cube must be right after the piglin
				execute if entity @s[type=magma_cube] unless score @s number = #PAIR_NUMBER temp run function ARG(_PATH)mark_owner
			}
			
			func mark()
			{
				execute unless score #FIRST_DISTANCE temp matches 0.. run function ARG(_PATH)record_first
				execute if score #GLOBAL hit_distance < #CUR_DISTANCE temp run function ARG(_PATH)record_dists
				
				tag @s add target
				scoreboard players operation #PAIR_NUMBER temp = @s number
				scoreboard players operation @s hit_distance = #CUR_DISTANCE temp
				scoreboard players operation @s hit_order = #FOUND_ENEMY temp
				scoreboard players add #FOUND_ENEMY temp 1
			}
			
			func record_dists()
			{
				data modify storage skill:main temp append value 0
				execute store result storage skill:main temp[-1] int 1 run scoreboard players get #CUR_DISTANCE temp
				scoreboard players operation #GLOBAL hit_distance = #CUR_DISTANCE temp
			}
			
			func mark_owner()
			{
				scoreboard players operation #PAIR_NUMBER temp = @s number
				execute as @e[type=zombified_piglin,tag=paired_mob] if score @s number = #PAIR_NUMBER temp run function ARG(_PATH)mark
				tag @s add target
			}
		}
	}
	
	folder damage_formula()
	{
		func spell()
		{
			# magic attack
			scoreboard players operation #MAGIC_ATTACK temp = @s weapon_mattack
			scoreboard players operation #MAGIC_ATTACK temp += @s matk_buff_num
			
			scoreboard players operation #MAGIC_ATTACK temp += @s INT
			scoreboard players operation #INT temp = @s INT
			scoreboard players operation #INT temp *= #5 const
			
			scoreboard players operation #MAX_DAMAGE temp = #MAGIC_ATTACK temp
			scoreboard players operation #MAX_DAMAGE temp *= #MAGIC_ATTACK temp
			scoreboard players operation #MAGIC_ATTACK temp *= #1000 const
			scoreboard players operation #MAX_DAMAGE temp += #MAGIC_ATTACK temp
			
			scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
			scoreboard players operation #MIN_DAMAGE temp *= #9 const
			scoreboard players operation #MIN_DAMAGE temp *= #SKILL_MASTERY temp
			scoreboard players operation #MIN_DAMAGE temp /= #1000 const
			
			scoreboard players operation #MAX_DAMAGE temp /= #30 const
			scoreboard players operation #MAX_DAMAGE temp += #INT temp
			scoreboard players operation #MAX_DAMAGE temp *= #SPELL_ATTACK temp
			scoreboard players operation #MAX_DAMAGE temp /= #1000 const
			
			scoreboard players operation #MIN_DAMAGE temp /= #30 const
			scoreboard players operation #MIN_DAMAGE temp += #INT temp
			scoreboard players operation #MIN_DAMAGE temp *= #SPELL_ATTACK temp
			scoreboard players operation #MIN_DAMAGE temp /= #1000 const
			
			# accuracy
			scoreboard players operation #INT temp /= #50 const
			scoreboard players operation #ACCURACY temp = @s LUK
			scoreboard players operation #ACCURACY temp /= #10 const
			scoreboard players operation #ACCURACY temp += #INT temp
			
			# write values
			execute store result storage skill:main damage[0].max_damage int 1 run scoreboard players get #MAX_DAMAGE temp
			execute store result storage skill:main damage[0].min_damage int 1 run scoreboard players get #MIN_DAMAGE temp
			execute store result storage skill:main damage[0].accuracy int 1 run scoreboard players get #ACCURACY temp
			execute store result storage skill:main damage[0].player_level int 1 run scoreboard players get @s level
			execute store result storage skill:main damage[0].crit_rate int 1 run scoreboard players get @s addi_crit_rate
			execute store result storage skill:main damage[0].crit_damage int 1 run scoreboard players get @s addi_crit_damage
		}
		
		func heal()
		{
			# target multiplier
			scoreboard players set #MULTIPLIER temp 500
			scoreboard players operation #MULTIPLIER temp /= #FOUND_ENEMY temp
			scoreboard players add #MULTIPLIER temp 150
			
			# magic attack
			scoreboard players operation #MAGIC_ATTACK temp = @s weapon_mattack
			scoreboard players operation #MAGIC_ATTACK temp += @s matk_buff_num
			
			scoreboard players operation #MAGIC_ATTACK temp += @s INT
			scoreboard players operation #MAGIC_ATTACK temp *= @s 2301002_level
			scoreboard players operation #MAGIC_ATTACK temp *= #MULTIPLIER temp
			scoreboard players operation #MAGIC_ATTACK temp /= #100 const
			
			scoreboard players operation #MIN_DAMAGE temp = @s INT
			scoreboard players operation #MIN_DAMAGE temp *= #3 const
			
			scoreboard players operation #MAX_DAMAGE temp = #MIN_DAMAGE temp
			scoreboard players operation #MAX_DAMAGE temp *= #4 const
			
			scoreboard players operation #MIN_DAMAGE temp /= #10 const
			scoreboard players operation #MIN_DAMAGE temp += @s LUK
			scoreboard players operation #MIN_DAMAGE temp *= #MAGIC_ATTACK temp
			scoreboard players operation #MIN_DAMAGE temp /= #10000 const
			
			scoreboard players operation #MAX_DAMAGE temp /= #10 const
			scoreboard players operation #MAX_DAMAGE temp += @s LUK
			scoreboard players operation #MAX_DAMAGE temp *= #MAGIC_ATTACK temp
			scoreboard players operation #MAX_DAMAGE temp /= #10000 const
			
			# recovery amount
			scoreboard players operation #MAX_HEAL_AMOUNT temp = #MAGIC_ATTACK temp
			scoreboard players operation #MAX_HEAL_AMOUNT temp *= #3 const
			scoreboard players operation #MAX_HEAL_AMOUNT temp /= #40 const
			
			scoreboard players operation #MIN_HEAL_AMOUNT temp = #MAGIC_ATTACK temp
			scoreboard players operation #MIN_HEAL_AMOUNT temp *= #45 const
			scoreboard players operation #MIN_HEAL_AMOUNT temp /= #1000 const
			
			# accuracy
			scoreboard players operation #INT temp = @s INT
			scoreboard players operation #INT temp /= #10 const
			scoreboard players operation #ACCURACY temp = @s LUK
			scoreboard players operation #ACCURACY temp /= #10 const
			scoreboard players operation #ACCURACY temp += #INT temp
			
			# write values
			execute store result storage skill:main damage[0].max_damage int 1 run scoreboard players get #MAX_DAMAGE temp
			execute store result storage skill:main damage[0].min_damage int 1 run scoreboard players get #MIN_DAMAGE temp
			execute store result storage skill:main damage[0].accuracy int 1 run scoreboard players get #ACCURACY temp
			execute store result storage skill:main damage[0].player_level int 1 run scoreboard players get @s level
			execute store result storage skill:main damage[0].crit_rate int 1 run scoreboard players get @s addi_crit_rate
			execute store result storage skill:main damage[0].crit_damage int 1 run scoreboard players get @s addi_crit_damage
		}
		
		folder accuracy()
		{
			func job_check()
			{
				execute if entity @s[tag=!archer,tag=!thief,tag=!pirate] run function ARG(_PATH)war_mag_beg
				execute if entity @s[tag=brawler] run function ARG(_PATH)brawler
				execute unless entity @s[tag=!archer,tag=!thief,tag=!pirate] if entity @s[tag=!brawler] run function ARG(_PATH)bow_thief_pirate
			}
			
			# warrior / magician / beginner
			func war_mag_beg()
			{
				scoreboard players operation #LUK temp = @s LUK
				scoreboard players operation #LUK temp *= #5 const
				scoreboard players operation #ACCURACY temp = @s DEX
				scoreboard players operation #ACCURACY temp *= #8 const
				scoreboard players operation #ACCURACY temp += #LUK temp
				scoreboard players operation #ACCURACY temp /= #10 const
				
				scoreboard players operation #ACCURACY temp += @s base_accuracy
				scoreboard players operation #ACCURACY temp += @s equip_accuracy
				scoreboard players operation #ACCURACY temp += @s accu_buff_num
			}
			
			# one punch
			func brawler()
			{
				scoreboard players operation #LUK temp = @s LUK
				scoreboard players operation #LUK temp *= #5 const
				scoreboard players operation #ACCURACY temp = @s DEX
				scoreboard players operation #ACCURACY temp *= #9 const
				scoreboard players operation #ACCURACY temp += #LUK temp
				scoreboard players operation #ACCURACY temp /= #10 const
				
				scoreboard players operation #ACCURACY temp += @s base_accuracy
				scoreboard players operation #ACCURACY temp += @s equip_accuracy
				scoreboard players operation #ACCURACY temp += @s accu_buff_num
			}
			
			# include gunslingers
			func bow_thief_pirate()
			{
				scoreboard players operation #LUK temp = @s LUK
				scoreboard players operation #LUK temp *= #3 const
				scoreboard players operation #ACCURACY temp = @s DEX
				scoreboard players operation #ACCURACY temp *= #6 const
				scoreboard players operation #ACCURACY temp += #LUK temp
				scoreboard players operation #ACCURACY temp /= #10 const
				
				scoreboard players operation #ACCURACY temp += @s base_accuracy
				scoreboard players operation #ACCURACY temp += @s equip_accuracy
				scoreboard players operation #ACCURACY temp += @s accu_buff_num
			}
		}
		
		func addi_crit()
		{
			scoreboard players operation #CRIT_RATE temp += @s addi_crit_rate
			scoreboard players operation #CRIT_DAMAGE temp += @s addi_crit_damage
			scoreboard players add #CRIT_DAMAGE temp 100
		}
		
		func write_values()
		{
			execute store result storage skill:main damage[0].max_damage int 1 run scoreboard players get #MAX_DAMAGE temp
			execute store result storage skill:main damage[0].min_damage int 1 run scoreboard players get #MIN_DAMAGE temp
			execute store result storage skill:main damage[0].accuracy int 1 run scoreboard players get #ACCURACY temp
			execute store result storage skill:main damage[0].player_level int 1 run scoreboard players get @s level
			execute store result storage skill:main damage[0].crit_rate int 1 run scoreboard players get #CRIT_RATE temp
			execute store result storage skill:main damage[0].crit_damage int 1 run scoreboard players get #CRIT_DAMAGE temp
		}
		
		folder claw()
		{
			func normal()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				execute if score @s bullet_item matches ..20 run scoreboard players operation #WEAPON_ATTACK temp += @s bullet_damage
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s LUK
				scoreboard players operation #MAX_DAMAGE temp *= #36 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s claw_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				function ARG(_PATH)other_formula
			}
			
			func lucky_seven()
			{
				# weapon attack
				scoreboard players operation #MAX_DAMAGE temp = @s weapon_attack
				execute if score @s bullet_item matches ..20 run scoreboard players operation #MAX_DAMAGE temp += @s bullet_damage
				scoreboard players operation #MAX_DAMAGE temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp *= @s LUK
				scoreboard players operation #MAX_DAMAGE temp /= #20 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp /= #2 const
				
				function ARG(_PATH)other_formula
			}
			
			func punch()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s LUK
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp /= #10 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #150 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #150 const
				
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s claw_accuracy
				
				# reset crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				
				function ARG(__PATH)write_values
			}
			
			func other_formula()
			{
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s claw_accuracy
				
				# crit
				scoreboard players operation #CRIT_RATE temp = @s crit_rate
				scoreboard players operation #CRIT_DAMAGE temp = @s crit_damage
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder dagger()
		{
			func thief()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s LUK
				scoreboard players operation #MAX_DAMAGE temp *= #36 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s dagger_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s dagger_accuracy
				
				function ARG(_PATH)other_formula
			}
			
			func non_thief()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #4 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				execute if entity @s[tag=!archer,tag=!pirate] run function ARG(__PATH)accuracy/war_mag_beg
				execute if entity @s[tag=brawler] run function ARG(__PATH)accuracy/brawler
				execute unless entity @s[tag=!archer,tag=!pirate] if entity @s[tag=!brawler] run function ARG(__PATH)accuracy/bow_thief_pirate
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder bow()
		{
			func normal()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				execute unless score #GLOBAL bullet_model matches 3001 if score @s bullet_item matches 21..25 run scoreboard players operation #WEAPON_ATTACK temp += @s bullet_damage
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #34 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s bow_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# crit
				scoreboard players operation #CRIT_RATE temp = @s crit_rate
				scoreboard players operation #CRIT_DAMAGE temp = @s crit_damage
				
				function ARG(_PATH)other_formula
			}
			
			func power_knock_back()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #34 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #150 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #150 const
				
				# reset crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s bow_accuracy
				
				# additional crit
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder crossbow()
		{
			func normal()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				execute unless score #GLOBAL bullet_model matches 3001 if score @s bullet_item matches 26..30 run scoreboard players operation #WEAPON_ATTACK temp += @s bullet_damage
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #36 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s cbow_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# crit
				scoreboard players operation #CRIT_RATE temp = @s crit_rate
				scoreboard players operation #CRIT_DAMAGE temp = @s crit_damage
				
				function ARG(_PATH)other_formula
			}
			
			func power_knock_back()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #34 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #150 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #150 const
				
				# reset crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s cbow_accuracy
				
				# additional crit
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder spear()
		{
			func stab()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #5 const
				
				function ARG(_PATH)other_formula
			}
			
			func swing()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #3 const
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s spear_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s spear_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder polearm()
		{
			func swing()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #5 const
				
				function ARG(_PATH)other_formula
			}
			
			func stab()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #3 const
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s polearm_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s polearm_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder sword()
		{
			func one_hand()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #4 const
				
				function ARG(_PATH)other_formula
			}
			
			func two_hand()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #46 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s sword_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s sword_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder axe()
		{
			folder one_hand()
			{
				func swing()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #44 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
				
				func stab()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #32 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
			}
			
			folder two_hand()
			{
				func swing()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #48 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
				
				func stab()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #34 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
			}
			
			func other_formula()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s axe_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s axe_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder blunt()
		{
			folder one_hand()
			{
				func swing()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #44 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
				
				func stab()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #32 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
			}
			
			folder two_hand()
			{
				func swing()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #48 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
				
				func stab()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #34 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
			}
			
			func other_formula()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s blunt_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s blunt_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		# wand formula == staff formula
		folder staff()
		{
			func swing()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #44 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				function ARG(_PATH)other_formula
			}
			
			func stab()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #32 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
	}

	folder calculate_damage()
	{
		func run()
		{
			data modify entity @s ArmorItems[3].tag.damage_record set value []
			# copy damage list
			data modify storage skill:main damage_copy set from storage skill:main damage
			scoreboard players set #SAME_DAMAGE temp 0
			scoreboard players operation #NUMBER_HEIGHT temp = @s default_height
			scoreboard players remove #NUMBER_HEIGHT temp 1
			scoreboard players set #DID_HIT temp 0
			function ARG(_PATH)traverse_damages/run
			
			execute if score #DID_HIT temp matches 1 run function ARG(_PATH)update_hp_display/run
			scoreboard players set #KILLED_MOB temp 0
			execute if score @s hp matches ..0 run function ARG(_PATH)record_dead
			execute if score #KILLED_MOB temp matches 1 if entity @s[tag=paired_mob] run function ARG(_PATH)stop_magma_cube
		}
			
		func stop_magma_cube()
		{
			scoreboard players operation #PAIR_NUMBER temp = @s number
			execute as @e[type=magma_cube,tag=enemy] if score @s number = #PAIR_NUMBER temp run data merge entity @s {NoAI:1,Tags:[]}
		}
		
		folder update_hp_display()
		{
			func run()
			{
				# for rounding
				scoreboard players operation #HP_CARRY temp = @s hp_max
				scoreboard players operation #HP_CARRY temp /= #92 const
				
				execute store result score #HP_LENGTH temp run scoreboard players operation @s hp > #0 const
				scoreboard players operation #HP_LENGTH temp += #HP_CARRY temp
				scoreboard players operation #HP_LENGTH temp *= #46 const
				scoreboard players operation #HP_LENGTH temp /= @s hp_max
				
				execute if score @s mob_hp_length = #HP_LENGTH temp run function ARG(_PATH)show
				execute unless score @s mob_hp_length = #HP_LENGTH temp run function ARG(_PATH)update
			}
			
			func update()
			{
				scoreboard players operation @s mob_hp_length = #HP_LENGTH temp
				
				data modify storage bar:main mob_hp set value []
				data modify storage bar:main mob_hp_back set value []
				execute if score #HP_LENGTH temp matches 32.. run function ARG(_PATH)32
				execute if score #HP_LENGTH temp matches 16.. run function ARG(_PATH)16
				execute if score #HP_LENGTH temp matches 8.. run function ARG(_PATH)8
				execute if score #HP_LENGTH temp matches 4.. run function ARG(_PATH)4
				execute if score #HP_LENGTH temp matches 2.. run function ARG(_PATH)2
				execute if score #HP_LENGTH temp matches 1.. run function ARG(_PATH)1
				
				data modify block 250 0 0 Text1 set value '[{"text":"985","font":"space:default"},{"text":"0","font":"ui:mob_hp"},{"text":"A92","font":"space:default"},{"nbt":"mob_hp[]","storage":"bar:main","font":"ui:mob_hp","interpret":true},{"nbt":"mob_hp_back","storage":"bar:main","font":"space:default","interpret":true},{"text":"\\uF829\\uF825","font":"space:default"}]'
				execute if entity @s[tag=!paired_mob] run data modify entity @s CustomName set from block 250 0 0 Text1
				execute if entity @s[tag=paired_mob] run function ARG(_PATH)update_pair
				data modify entity @s ArmorItems[3].tag.health_bar set from block 250 0 0 Text1
				
				scoreboard players set @s show_hp_time 5
			}
			
			func update_pair()
			{
				scoreboard players operation #GLOBAL temp = @s number
				execute as @e[type=magma_cube,tag=enemy] if score @s number = #GLOBAL temp run data modify entity @s CustomName set from block 250 0 0 Text1
			}
			
			func show()
			{
				execute unless score @s show_hp_time matches 1.. if entity @s[tag=!paired_mob] run data modify entity @s CustomName set from entity @s ArmorItems[3].tag.health_bar
				execute unless score @s show_hp_time matches 1.. if entity @s[tag=paired_mob] run function ARG(_PATH)show_pair
				scoreboard players set @s show_hp_time 5
			}
			
			func show_pair()
			{
				data modify storage bar:main temp set from entity @s ArmorItems[3].tag.health_bar
				scoreboard players operation #GLOBAL temp = @s number
				execute as @e[type=magma_cube,tag=enemy] if score @s number = #GLOBAL temp run data modify entity @s CustomName set from storage bar:main temp
			}
			
			func countdown()
			{
				scoreboard players remove @s show_hp_time 1
				execute if score @s show_hp_time matches 0 run function ARG(_PATH)hide
			}
			
			func hide()
			{
				execute if entity @s[tag=!paired_mob] run data modify entity @s CustomName set value '{"text":"2","font":"space:default"}'
				execute if entity @s[tag=paired_mob] run function ARG(_PATH)hide_pair
				scoreboard players reset @s show_hp_time
			}
			
			func hide_pair()
			{
				scoreboard players operation #GLOBAL temp = @s number
				execute as @e[type=magma_cube,tag=enemy] if score @s number = #GLOBAL temp run data modify entity @s CustomName set value '{"text":"2","font":"space:default"}'
			}
			
			func 32()
			{
				data modify storage bar:main mob_hp prepend value '{"text":"6","font":"ui:mob_hp"}'
				data modify storage bar:main mob_hp_back append value "A"
				scoreboard players remove #HP_LENGTH temp 32
			}
			
			func 16()
			{
				data modify storage bar:main mob_hp prepend value '{"text":"5","font":"ui:mob_hp"}'
				data modify storage bar:main mob_hp_back append value "9"
				scoreboard players remove #HP_LENGTH temp 16
			}
			
			func 8()
			{
				data modify storage bar:main mob_hp prepend value '{"text":"4","font":"ui:mob_hp"}'
				data modify storage bar:main mob_hp_back append value "8"
				scoreboard players remove #HP_LENGTH temp 8
			}
			
			func 4()
			{
				data modify storage bar:main mob_hp prepend value '{"text":"3","font":"ui:mob_hp"}'
				data modify storage bar:main mob_hp_back append value "4"
				scoreboard players remove #HP_LENGTH temp 4
			}
			
			func 2()
			{
				data modify storage bar:main mob_hp prepend value '{"text":"2","font":"ui:mob_hp"}'
				data modify storage bar:main mob_hp_back append value "2"
				scoreboard players remove #HP_LENGTH temp 2
			}
			
			func 1()
			{
				data modify storage bar:main mob_hp prepend value '{"text":"1","font":"ui:mob_hp"}'
				data modify storage bar:main mob_hp_back append value "1"
			}
		}
		
		func record_dead()
		{
			attribute @s minecraft:generic.attack_damage base set -100.0
			attribute @s minecraft:generic.movement_speed base set -100.0
			
			replaceitem entity @s weapon.mainhand minecraft:potion{CustomModelData:1,Enchantments:[{id:"minecraft:looting",lvl:1}]}
			execute store result entity @s HandItems[0].tag.Enchantments[0].lvl int 1 run scoreboard players get #WORLD_DROP_RATE const
			loot spawn ~ ~1 ~ kill @s
			execute as @e[type=item,tag=!checked] at @s run function item:entity/check
			
			scoreboard players operation #EXP_GAIN temp += @s exp
			tag @s add dead
			
			scoreboard players set #KILLED_MOB temp 1
		}
		
		folder traverse_damages() from while_loop("if data storage skill:main damage_copy[0]")
		{
			func execute()
			{
				execute unless score #SAME_DAMAGE temp matches 1 run function ARG(_PATH)record_value
				data remove storage skill:main damage_copy[0]
				
				data modify entity @s ArmorItems[3].tag.damage_record append value {number:0,crit:0}
				execute store result entity @s ArmorItems[3].tag.damage_record[-1].height int 1 run scoreboard players add #NUMBER_HEIGHT temp 1
				
				function main:rand_rate
				execute if score #HIT_RATE temp > #RAND_RESULT temp run function ARG(_PATH)deal_damage
			}
			
			func record_value()
			{
				execute store result score #MIN_DAMAGE temp run data get storage skill:main damage_copy[0].min_damage
				execute store result score #MAX_DAMAGE temp run data get storage skill:main damage_copy[0].max_damage
				execute store result score #BASE_PERCENT temp run data get storage skill:main damage_copy[0].base_percent
				execute store result score #CRIT_RATE temp run data get storage skill:main damage_copy[0].crit_rate
				execute store result score #CRIT_DAMAGE temp run data get storage skill:main damage_copy[0].crit_damage
				scoreboard players operation #CRIT_DAMAGE temp += #BASE_PERCENT temp
				execute store result score #LEVEL_DIFFERENCE temp run data get storage skill:main damage_copy[0].player_level -1
				scoreboard players operation #LEVEL_DIFFERENCE temp += @s level
				scoreboard players operation #LEVEL_DIFFERENCE temp > #0 const
				# ATTRIBUTE 0 = weapon attack; 1 = magic attack; 2 = fire; 3 = poison; 4 = ice; 5 = lightning; 6 = holy
				execute store result score #ATTRIBUTE temp run data get storage skill:main damage_copy[0].attribute
				execute if score #ATTRIBUTE temp matches 2.. run function ARG(_PATH)attribute_multiply/run
				# Calculate defense and hit rate
				execute if score #ATTRIBUTE temp matches 0 run function ARG(_PATH)weapon_formula
				execute if score #ATTRIBUTE temp matches 1.. run function ARG(_PATH)magic_formula
				
				execute store success score #SAME_DAMAGE temp run data modify storage skill:main damage_copy[0] set from storage skill:main damage_copy[1]
			}
			
			func weapon_formula()
			{
				# defense
				scoreboard players operation #DEFENSE temp = @s weapon_defense
				scoreboard players operation #DEFENSE temp -= @s wdef_drop
				scoreboard players operation #DEFENSE temp /= #2 const
				
				scoreboard players set #LEVEL_PUNISH temp 100
				scoreboard players operation #LEVEL_PUNISH temp -= #LEVEL_DIFFERENCE temp
				scoreboard players operation #MAX_DAMAGE temp *= #LEVEL_PUNISH temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				scoreboard players operation #MAX_DAMAGE temp -= #DEFENSE temp
				
				scoreboard players operation #MIN_DAMAGE temp *= #LEVEL_PUNISH temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				scoreboard players operation #DEFENSE temp *= #6 const
				scoreboard players operation #DEFENSE temp /= #5 const
				scoreboard players operation #MIN_DAMAGE temp -= #DEFENSE temp
				
				# hit rate
				execute store result score #HIT_RATE temp run data get storage skill:main damage_copy[0].accuracy 100000
				scoreboard players operation #LEVEL_DIFFERENCE temp *= #66 const
				scoreboard players add #LEVEL_DIFFERENCE temp 1835
				scoreboard players operation #LEVEL_DIFFERENCE temp *= @s avoidability
				scoreboard players operation #HIT_RATE temp /= #LEVEL_DIFFERENCE temp
				scoreboard players remove #HIT_RATE temp 100
			}
			
			func magic_formula()
			{
				# defense
				scoreboard players operation #DEFENSE temp = @s magic_defense
				scoreboard players operation #DEFENSE temp /= #2 const
				
				scoreboard players set #LEVEL_PUNISH temp 100
				scoreboard players operation #LEVEL_PUNISH temp += #LEVEL_DIFFERENCE temp
				scoreboard players operation #DEFENSE temp *= #LEVEL_PUNISH temp
				scoreboard players operation #DEFENSE temp /= #100 const
				scoreboard players operation #MAX_DAMAGE temp -= #DEFENSE temp
				
				scoreboard players operation #DEFENSE temp *= #6 const
				scoreboard players operation #DEFENSE temp /= #5 const
				scoreboard players operation #MIN_DAMAGE temp -= #DEFENSE temp
				
				# hit rate
				scoreboard players operation #LEVEL_DIFFERENCE temp *= #4 const
				scoreboard players add #LEVEL_DIFFERENCE temp 100
				scoreboard players operation #MAX_ACCURACY temp = @s avoidability
				scoreboard players add #MAX_ACCURACY temp 1
				scoreboard players operation #MAX_ACCURACY temp *= #LEVEL_DIFFERENCE temp
				scoreboard players operation #MAX_ACCURACY temp /= #100 const
				
				scoreboard players operation #MIN_ACCURACY temp = #MAX_ACCURACY temp
				scoreboard players operation #MIN_ACCURACY temp *= #41 const
				scoreboard players operation #MIN_ACCURACY temp /= #100 const
				
				execute store result score #ACCURACY temp run data get storage skill:main damage_copy[0].accuracy
				scoreboard players set #HIT_RATE temp 0
				execute if score #ACCURACY temp >= #MAX_ACCURACY temp run scoreboard players set #HIT_RATE temp 100
				execute if score #ACCURACY temp < #MAX_ACCURACY temp if score #ACCURACY temp >= #MIN_ACCURACY temp run function ARG(_PATH)magic_hit_rate
			}
			
			func magic_hit_rate()
			{
				scoreboard players operation #ACCURACY temp -= #MIN_ACCURACY temp
				scoreboard players add #ACCURACY temp 1
				scoreboard players operation #ACCURACY temp *= #100 const
				
				scoreboard players operation #MAX_ACCURACY temp -= #MIN_ACCURACY temp
				scoreboard players add #MAX_ACCURACY temp 1
				
				execute store result score #HIT_RATE temp run scoreboard players operation #ACCURACY temp /= #MAX_ACCURACY temp
				scoreboard players operation #HIT_RATE temp *= #HIT_RATE temp
				scoreboard players operation #HIT_RATE temp *= #-7 const
				scoreboard players operation #HIT_RATE temp /= #1000 const
				
				scoreboard players operation #ACCURACY temp *= #17 const
				scoreboard players operation #ACCURACY temp /= #10 const
				
				scoreboard players operation #HIT_RATE temp += #ACCURACY temp
			}
			
			func deal_damage()
			{
				scoreboard players operation @s display_number = #MAX_DAMAGE temp
				execute unless score #MAX_DAMAGE temp = #MIN_DAMAGE temp run function ARG(_PATH)rand_damage
				
				execute if score #CRIT_RATE temp matches 1.. run function main:rand_rate
				execute if score #CRIT_RATE temp > #RAND_RESULT temp run function ARG(_PATH)crit_multiply
				execute unless score #CRIT_RATE temp > #RAND_RESULT temp run function ARG(_PATH)skill_multiply
				
				scoreboard players operation @s display_number < #99999 const
				scoreboard players operation @s display_number > #1 const
				
				execute if score #AFTER_MODIFIER_NUM temp matches 1.. run function ARG(_PATH)after_modify/set
				
				scoreboard players operation @s hp -= @s display_number
				execute store result entity @s ArmorItems[3].tag.damage_record[-1].number int 1 run scoreboard players get @s display_number
				
				scoreboard players set #DID_HIT temp 1
			}
			
			folder after_modify() from for_loop().for("@s hit_order", "")
			{
				func set()
				{
					scoreboard players operation @s display_number *= #AFTER_MODIFIER_SCALE_NUM temp
					scoreboard players operation @s display_number /= #AFTER_MODIFIER_SCALE_DENOM temp
					scoreboard players operation @s display_number *= #100 const
					function ARG(_PATH)run
					scoreboard players operation @s display_number /= #100 const
				}
				
				func execute()
				{
					scoreboard players operation @s display_number *= #AFTER_MODIFIER_NUM temp
					scoreboard players operation @s display_number /= #AFTER_MODIFIER_DENOM temp
				}
			}
			
			folder attribute_multiply()
			{
				func run()
				{
					execute if score #ATTRIBUTE temp matches 2 run function ARG(_PATH)fire
					execute if score #ATTRIBUTE temp matches 3 run function ARG(_PATH)poison
					execute if score #ATTRIBUTE temp matches 4 run function ARG(_PATH)ice
					execute if score #ATTRIBUTE temp matches 5 run function ARG(_PATH)lightning
					execute if score #ATTRIBUTE temp matches 6 run function ARG(_PATH)holy
				}
				
				func fire()
				{
					execute if entity @s[tag=fire_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=fire_weakness] run function ARG(_PATH)weakness
				}
				
				func poison()
				{
					execute if entity @s[tag=poison_s_resist] run function ARG(_PATH)strong_resist
					execute if entity @s[tag=poison_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=poison_weakness] run function ARG(_PATH)weakness
				}
				
				func ice()
				{
					execute if entity @s[tag=ice_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=ice_weakness] run function ARG(_PATH)weakness
				}
				
				func lightning()
				{
					execute if entity @s[tag=lightning_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=lightning_weakness] run function ARG(_PATH)weakness
				}
				
				func holy()
				{
					execute if entity @s[tag=holy_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=holy_weakness] run function ARG(_PATH)weakness
				}
				
				func strong_resist()
				{
					scoreboard players set #MIN_DAMAGE temp 1
					scoreboard players set #MAX_DAMAGE temp 1
				}
	
				func resist()
				{
					scoreboard players operation #MIN_DAMAGE temp *= #50 const
					scoreboard players operation #MAX_DAMAGE temp *= #50 const
					function ARG(_PATH)divide_back
				}
				
				func weakness()
				{
					scoreboard players operation #MIN_DAMAGE temp *= #150 const
					scoreboard players operation #MAX_DAMAGE temp *= #150 const
					function ARG(_PATH)divide_back
				}
				
				func divide_back()
				{
					scoreboard players operation #MIN_DAMAGE temp /= #100 const
					scoreboard players operation #MAX_DAMAGE temp /= #100 const
				}
			}
			
			func crit_multiply()
			{
				scoreboard players operation @s display_number *= #CRIT_DAMAGE temp
				scoreboard players operation @s display_number /= #100 const
				data modify entity @s ArmorItems[3].tag.damage_record[-1].crit set value 1
			}
			
			func skill_multiply()
			{
				scoreboard players operation @s display_number *= #BASE_PERCENT temp
				scoreboard players operation @s display_number /= #100 const
			}
			
			func rand_damage() from random().generate("#MIN_DAMAGE temp", "#MAX_DAMAGE temp", "@s display_number");
		}
	}
	
	folder mob_effect()
	{
		folder debuff()
		{
			func freeze()
			{
				tag @s add color_changed
				execute store result score @s kb_time run scoreboard players operation @s freeze_time = #FREEZE_TIME temp
				scoreboard players add @s kb_time 12
				
				data modify entity @s ArmorItems[3].tag.CustomPotionColor set value 12580095
				
				execute store result score #GLOBAL temp run scoreboard players set @s status 1
				execute store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players operation #GLOBAL temp += @s base_model
				
				attribute @s minecraft:generic.movement_speed modifier add 495407c5-10c0-4270-84ed-c566e01e6952 move_control -100.0 add
			}
			
			func poison()
			{
				tag @s add color_changed
				scoreboard players operation @s poison_time = #POISON_TIME temp
				scoreboard players operation @s poison_damage = @s hp_max
				scoreboard players operation @s poison_damage /= #POISON_HP_RATE temp
				
				execute unless score @s next_poison matches 1.. run scoreboard players set @s poison_particle 7
				execute unless score @s next_poison matches 1.. run scoreboard players set @s next_poison 20
				
				data modify entity @s ArmorItems[3].tag.CustomPotionColor set value 2779438
			}
			
			func stun()
			{
				scoreboard players operation @s stun_time = #STUN_TIME temp
				execute unless score @s stun_particle matches 1.. run scoreboard players set @s stun_particle 6
				
				attribute @s minecraft:generic.movement_speed modifier add 98fb435b-7645-4b76-8504-ee4f9e13fdec stun_control -100.0 add
				tag @s add mob_effect
			}
		}
		
		func hit_model()
		{
			execute store result score #GLOBAL temp run scoreboard players set @s status 1
			execute store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players operation #GLOBAL temp += @s base_model
		}
		
		func dead()
		{
			scoreboard players operation #GLOBAL temp = @s number
			execute as @e[type=armor_stand,tag=bullet] if score @s target_id = #GLOBAL temp run kill @s
			
			function ARG(_PATH)play_die_sound/run
			execute if entity @s[tag=dead_effect] run function ARG(_PATH)dead_effect/check
			kill @s
		}
		
		folder dead_effect()
		{
			func check()
			{
				execute if entity @s[tag=king_slime] run function ARG(_PATH)king_slime/run
			}
			
			folder king_slime()
			{
				func run()
				{
					summon minecraft:area_effect_cloud ~ ~ ~ {Duration:100,Tags:["dead_king_slime"]}
					scoreboard players reset #KING_SLIME_EXIST temp
					schedule function ARG(_PATH)call_summon 20t
				}
				
				func call_summon()
				{
					execute as @e[type=area_effect_cloud,tag=dead_king_slime] at @s run function ARG(_PATH)summon
				}
				
				func summon()
				{
					```
					for i in range(10):
						print('''summon zombified_piglin ~ ~ ~ {Tags:["kpq_mob","new_enemy","split_slime","lightning_weakness"],ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1b,tag:{info:{level:6,hp_max:50,mp_max:35,avoidability:1,weapon_defense:5,magic_defense:10,kb:1,exp:10,width:1,height:2,move_frame:21,stand_frame:15,hurt_sound:3,die_sound:6},steal_loot:"skill:steal/0_9/slime",CustomModelData:10107,CustomPotionColor:-1,Unbreakable:1,AttributeModifiers:[{AttributeName:"generic.attack_damage",Name:"disorder",Amount:0,Operation:0,UUID:[I;0,1,0,1]},{AttributeName:"generic.movement_speed",Name:"slow",Amount:0,Operation:0,UUID:[I;0,2,0,2]}]}}],ArmorDropChances:[0.0,0.0,0.0,0.0],Silent:1,PersistenceRequired:1,Attributes:[{Name:"generic.attack_damage",Base:4.2},{Name:"generic.movement_speed",Base:0.15},{Name:"generic.follow_range",Base:0.0}],DeathLootTable:"skill:mob/0_9/slime",Invulnerable:1b,OnGround:1b,AngerTime:2147483647,Team:"enemy",CustomName:'{"text":"2","font":"space:default"}',CustomNameVisible:1b}''')
					```
					execute as @e[type=#skill:enemy,tag=new_enemy,tag=split_slime] run function mob:setting/run
					kill @s
				}
			}
		}
		
		folder play_hurt_sound()
		{
			```
			def bs_hurt_sound(sound_list, start, end):
				if len(sound_list) == 1:
					print("func run()")
					print("{")
					print(f"\texecute if score @s hurt_sound matches {sound_list[0][1]} run playsound minecraft:mob.hurt.{sound_list[0][0]} player @a ~ ~ ~ 1 1 0")
					print("}")
					return
				
				if start == end:
					return
				
				mid = (start + end) // 2
				mid_right = mid + 1
				
				if start == 0 and end == len(sound_list) - 1:
					print("func run()")
				else:
					print(f"func {start}_{end}()")
				print("{")
				if start == mid:
					print(f"\texecute if score @s hurt_sound matches {sound_list[start][1]} run playsound minecraft:mob.hurt.{sound_list[start][0]} player @a ~ ~ ~ 1 1 0")
				else:
					print(f"\texecute if score @s hurt_sound matches {sound_list[start][1]}..{sound_list[mid][1]} run function ARG(_PATH){start}_{mid}")
				if mid_right == end:
					print(f"\texecute if score @s hurt_sound matches {sound_list[end][1]} run playsound minecraft:mob.hurt.{sound_list[end][0]} player @a ~ ~ ~ 1 1 0")
				else:
					print(f"\texecute if score @s hurt_sound matches {sound_list[mid_right][1]}..{sound_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
				print("}")
				
				bs_hurt_sound(sound_list, start, mid)
				bs_hurt_sound(sound_list, mid_right, end)
			
			with open(PROJ_DIR + "/../hurt_sounds.csv") as f:
				hurt_sounds = f.read().split("\n")
				for i in range(len(hurt_sounds)):
					hurt_sounds[i] = hurt_sounds[i].split(",")
					hurt_sounds[i][1] = int(hurt_sounds[i][1])
			
			bs_hurt_sound(hurt_sounds, 0, len(hurt_sounds) - 1)
			```
		}
		
		folder play_die_sound()
		{
			```
			def bs_die_sound(sound_list, start, end):
				if len(sound_list) == 1:
					print("func run()")
					print("{")
					print(f"\texecute if score @s die_sound matches {sound_list[0][1]} run playsound minecraft:mob.die.{sound_list[0][0]} player @a ~ ~ ~ 1 1 0")
					print("}")
					return
				
				if start == end:
					return
				
				mid = (start + end) // 2
				mid_right = mid + 1
				
				if start == 0 and end == len(sound_list) - 1:
					print("func run()")
				else:
					print(f"func {start}_{end}()")
				print("{")
				if start == mid:
					print(f"\texecute if score @s die_sound matches {sound_list[start][1]} run playsound minecraft:mob.die.{sound_list[start][0]} player @a ~ ~ ~ 1 1 0")
				else:
					print(f"\texecute if score @s die_sound matches {sound_list[start][1]}..{sound_list[mid][1]} run function ARG(_PATH){start}_{mid}")
				if mid_right == end:
					print(f"\texecute if score @s die_sound matches {sound_list[end][1]} run playsound minecraft:mob.die.{sound_list[end][0]} player @a ~ ~ ~ 1 1 0")
				else:
					print(f"\texecute if score @s die_sound matches {sound_list[mid_right][1]}..{sound_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
				print("}")
				
				bs_die_sound(sound_list, start, mid)
				bs_die_sound(sound_list, mid_right, end)
			
			with open(PROJ_DIR + "/../die_sounds.csv") as f:
				die_sounds = f.read().split("\n")
				for i in range(len(die_sounds)):
					die_sounds[i] = die_sounds[i].split(",")
					die_sounds[i][1] = int(die_sounds[i][1])
			
			bs_die_sound(die_sounds, 0, len(die_sounds) - 1)
			```
		}
	}
		
	folder summon_font_effect()
	{
		```
		font_root_path = os.path.dirname(os.path.abspath(PROJ_DIR)) + "/MapleCraft resource pack/assets/skill/font"
		for root, dirs, files in os.walk(font_root_path):
			for name in files:
				if name == "summon.txt":
					func_name = ""
					recursive_path = root
					for i in range(3):
						func_name = os.path.basename(recursive_path) + func_name
						recursive_path = os.path.dirname(recursive_path)
						
					print(f"func {func_name}()")
					print("{")
					with open(os.path.join(root, name), "r") as f:
						print(f.read())
					print("}")
					
					break
		```
	}
	
	folder afterimage()
	{
		folder hit()
		{
			func mace()
			{
				scoreboard players set #RANGE_MAX temp 6
				function main:rand_range
				execute if score #RAND_RANGE_RESULT temp matches ..2 run function skill:summon_font_effect/0000000mace0
				execute if score #RAND_RANGE_RESULT temp matches 3.. run function skill:summon_font_effect/0000000mace1
			}
			
			func sword()
			{
				scoreboard players set #RANGE_MAX temp 6
				function main:rand_range
				execute if score #RAND_RANGE_RESULT temp matches ..2 run function skill:summon_font_effect/0000000sword0
				execute if score #RAND_RANGE_RESULT temp matches 3.. run function skill:summon_font_effect/0000000sword1
			}
		}
		
		folder final_swing()
		{
			func check()
			{
				execute if score #USED_WEAPON temp matches 5..8 run function ARG(_PATH)sword_axe
				execute if score #USED_WEAPON temp matches 9..14 run function ARG(_PATH)others
			}
			
			func sword_axe()
			{
				execute if score #USED_WEAPON temp matches 5 run function ARG(__PATH)oh_axe/final_attack/use
				execute if score #USED_WEAPON temp matches 6 run function ARG(__PATH)th_axe/final_attack/use
				execute if score #USED_WEAPON temp matches 7 run function ARG(__PATH)oh_sword/final_attack/use
				execute if score #USED_WEAPON temp matches 8 run function ARG(__PATH)th_sword/final_attack/use
			}
			
			func others()
			{
				execute if score #USED_WEAPON temp matches 9 run function ARG(__PATH)oh_blunt/final_attack/use
				execute if score #USED_WEAPON temp matches 12 run function ARG(__PATH)spear/final_attack/use
				execute if score #USED_WEAPON temp matches 14 run function ARG(__PATH)polearm/final_attack/use
				execute if score #USED_WEAPON temp matches 10 run function ARG(__PATH)th_blunt/final_attack/use
			}
		}
		
		folder warrior_swing()
		{
			func check()
			{
				execute if score #DISTANCE temp matches 4 run function ARG(_PATH)one_hand
				execute if score #DISTANCE temp matches 5 run function ARG(_PATH)two_hand
			}
			
			func one_hand()
			{
				execute if score #USED_WEAPON temp matches 23 run function ARG(__PATH)dagger/random
				execute if score #USED_WEAPON temp matches 19..21 run function ARG(__PATH)staff/swing
				execute if score #USED_WEAPON temp matches 5 run function ARG(__PATH)oh_axe/random
				execute if score #USED_WEAPON temp matches 7 run function ARG(__PATH)oh_sword/random
				execute if score #USED_WEAPON temp matches 9 run function ARG(__PATH)oh_blunt/random
			}
			
			func two_hand()
			{
				execute if score #USED_WEAPON temp matches 12 run function ARG(__PATH)spear/random
				execute if score #USED_WEAPON temp matches 14 run function ARG(__PATH)polearm/random
				execute if score #USED_WEAPON temp matches 8 run function ARG(__PATH)th_sword/random
				execute if score #USED_WEAPON temp matches 6 run function ARG(__PATH)th_axe/random
				execute if score #USED_WEAPON temp matches 10 run function ARG(__PATH)th_blunt/random
			}
		}
		
		folder claw()
		{
			func swing()
			{
				scoreboard players set #RANGE_MAX temp 9
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000000
				execute if score @s claw_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.punch player @a ~ ~ ~ 1 1 0
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s claw_color
			}
			
			func stab()
			{
				scoreboard players set #RAND_RANGE_RESULT temp 1001009
				scoreboard players set #AFTERIMAGE_COLOR temp 255
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.punch player @a ~ ~ ~ 1 1 0
				function skill:damage_formula/claw/punch
				scoreboard players add @s action_time 16
			}
		}
		
		folder dagger()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 15
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000021
				execute if score @s dagger_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				execute if entity @s[tag=thief] run function skill:damage_formula/dagger/thief
				execute if entity @s[tag=!thief] run function skill:damage_formula/dagger/non_thief
				scoreboard players add @s action_time 15
			}
			
			func stab()
			{
				scoreboard players set #RAND_RANGE_RESULT temp 1000030
				execute if score @s dagger_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s dagger_color
			}
		}
		
		folder bow()
		{
			func swing()
			{
				scoreboard players set #RANGE_MAX temp 6
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000015
				execute if score @s bow_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				function skill:damage_formula/bow/power_knock_back
				scoreboard players add @s action_time 16
			}
			
			func shoot()
			{
				scoreboard players set #RAND_RANGE_RESULT temp 1000096
				execute if score @s bow_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				execute if score @s f_attack_skill matches 1.. if score @s bow_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			folder final_attack()
			{
				func try()
				{
					function main:rand_rate
					execute if score #RAND_RESULT temp < @s bow_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 4
					
					scoreboard players add @s action_time 10
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s bow_color
			}
		}
		
		folder crossbow()
		{
			func swing()
			{
				scoreboard players set #RANGE_MAX temp 6
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000012
				execute if score @s cbow_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model_delay
				
				playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				function skill:damage_formula/crossbow/power_knock_back
				scoreboard players add @s action_time 17
			}
			
			func shoot()
			{
				scoreboard players set #RAND_RANGE_RESULT temp 1000096
				execute if score @s cbow_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model_delay
				
				playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				execute if score @s f_attack_skill matches 1.. if score @s cbow_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			folder final_attack()
			{
				func try()
				{
					function main:rand_rate
					execute if score #RAND_RESULT temp < @s cbow_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					scoreboard players add @s action_time 10
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s cbow_color
			}
		}
		
		folder staff()
		{
			func swing()
			{
				scoreboard players set #RAND_RANGE_RESULT temp 1001069
				scoreboard players set #AFTERIMAGE_COLOR temp 255
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				function skill:damage_formula/staff/swing
				scoreboard players add @s action_time 16
			}
		}
		
		folder polearm()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 15
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000036
				
				execute if score #RAND_RANGE_RESULT temp matches 1000036..1000044 run function ARG(_PATH)swing_formula
				execute if score #RAND_RANGE_RESULT temp matches 1000045..1000050 run function ARG(_PATH)stab_formula
				
				execute if score @s polearm_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				playsound minecraft:skill.attack.polearm player @a ~ ~ ~ 1 1 0
				
				scoreboard players add @s action_time 15
				execute if score @s f_attack_skill matches 1.. if score @s p_arm_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			func swing_formula()
			{
				function skill:damage_formula/polearm/swing
				scoreboard players set #LAST_ACTION_TYPE temp 1
			}
			
			func stab_formula()
			{
				function skill:damage_formula/polearm/stab
				scoreboard players set #LAST_ACTION_TYPE temp 2
			}
			
			folder final_attack()
			{
				func try()
				{
					function main:rand_rate
					execute if score #RAND_RESULT temp < @s p_arm_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 1
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 1 run scoreboard players add @s action_time 1
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 6
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000106
				}
				
				func use()
				{
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
				
					execute if score #RAND_RANGE_RESULT temp matches 1000106..1000108 run function skill:damage_formula/polearm/swing
					execute if score #RAND_RANGE_RESULT temp matches 1000109..1000111 run function skill:damage_formula/polearm/stab
					
					execute if score @s polearm_mastery matches ..55 run function ARG(__PATH)set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.polearm player @a ~ ~ ~ 1 1 0
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s polearm_color
			}
		}
		
		folder spear()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 15
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000036
				
				execute if score #RAND_RANGE_RESULT temp matches 1000036..1000044 run function ARG(_PATH)swing_formula
				execute if score #RAND_RANGE_RESULT temp matches 1000045..1000050 run function ARG(_PATH)stab_formula
				
				execute if score @s spear_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				playsound minecraft:skill.attack.spear player @a ~ ~ ~ 1 1 0
				
				scoreboard players add @s action_time 15
				execute if score @s f_attack_skill matches 1.. if score @s spear_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			func swing_formula()
			{
				function skill:damage_formula/spear/swing
				scoreboard players set #LAST_ACTION_TYPE temp 1
			}
			
			func stab_formula()
			{
				function skill:damage_formula/spear/stab
				scoreboard players set #LAST_ACTION_TYPE temp 2
			}
			
			folder final_attack()
			{
				func try()
				{
					function main:rand_rate
					execute if score #RAND_RESULT temp < @s spear_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 1
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 1 run scoreboard players add @s action_time 1
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 6
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000106
				}
				
				func use()
				{
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
				
					execute if score #RAND_RANGE_RESULT temp matches 1000106..1000108 run function skill:damage_formula/spear/swing
					execute if score #RAND_RANGE_RESULT temp matches 1000109..1000111 run function skill:damage_formula/spear/stab
					
					execute if score @s spear_mastery matches ..55 run function ARG(__PATH)set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.spear player @a ~ ~ ~ 1 1 0
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s spear_color
			}
		}
		
		folder oh_sword()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 15
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000000
				
				execute if score #RAND_RANGE_RESULT temp matches 1000000..1000008 run scoreboard players set #LAST_ACTION_TYPE temp 1
				execute if score #RAND_RANGE_RESULT temp matches 1000009..1000014 run scoreboard players set #LAST_ACTION_TYPE temp 2
				
				execute if score @s sword_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				function skill:damage_formula/sword/one_hand
				
				scoreboard players add @s action_time 16
				execute if score @s f_attack_skill matches 1.. if score @s sword_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			folder final_attack()
			{
				func try()
				{
					function main:rand_rate
					execute if score #RAND_RESULT temp < @s sword_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 6
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000100
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 2 if score #RAND_RANGE_RESULT temp matches 1000103..1000105 run scoreboard players remove @s action_time 2
				}
				
				func use()
				{
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
					function skill:damage_formula/sword/one_hand
					
					execute if score @s sword_mastery matches ..55 run function ARG(__PATH)set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s sword_color
			}
		}
		
		folder oh_axe()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 15
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000000
				
				execute if score #RAND_RANGE_RESULT temp matches 1000000..1000008 run function ARG(_PATH)swing_formula
				execute if score #RAND_RANGE_RESULT temp matches 1000009..1000014 run function ARG(_PATH)stab_formula
				
				execute if score @s axe_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				playsound minecraft:skill.attack.sword_l player @a ~ ~ ~ 1 1 0
				
				scoreboard players add @s action_time 16
				execute if score @s f_attack_skill matches 1.. if score @s axe_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			func swing_formula()
			{
				function skill:damage_formula/axe/one_hand/swing
				scoreboard players set #LAST_ACTION_TYPE temp 1
			}
			
			func stab_formula()
			{
				function skill:damage_formula/axe/one_hand/stab
				scoreboard players set #LAST_ACTION_TYPE temp 2
			}
			
			folder final_attack()
			{
				func try()
				{
					function main:rand_rate
					execute if score #RAND_RESULT temp < @s axe_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 6
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000100
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 2 if score #RAND_RANGE_RESULT temp matches 1000103..1000105 run scoreboard players remove @s action_time 2
				}
				
				func use()
				{
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
				
					execute if score #RAND_RANGE_RESULT temp matches 1000100..1000102 run function skill:damage_formula/axe/one_hand/swing
					execute if score #RAND_RANGE_RESULT temp matches 1000103..1000105 run function skill:damage_formula/axe/one_hand/stab
					
					execute if score @s axe_mastery matches ..55 run function ARG(__PATH)set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.sword_l player @a ~ ~ ~ 1 1 0
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s axe_color
			}
		}
		
		folder oh_blunt()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 15
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000066
				
				execute if score #RAND_RANGE_RESULT temp matches 1000066..1000074 run function ARG(_PATH)swing_formula
				execute if score #RAND_RANGE_RESULT temp matches 1000075..1000080 run function ARG(_PATH)stab_formula
				
				execute if score @s blunt_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				
				scoreboard players add @s action_time 16
				execute if score @s f_attack_skill matches 1.. if score @s blunt_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			func swing_formula()
			{
				function skill:damage_formula/blunt/one_hand/swing
				scoreboard players set #LAST_ACTION_TYPE temp 1
			}
			
			func stab_formula()
			{
				function skill:damage_formula/blunt/one_hand/stab
				scoreboard players set #LAST_ACTION_TYPE temp 2
			}
			
			folder final_attack()
			{
				func try()
				{
					function main:rand_rate
					execute if score #RAND_RESULT temp < @s blunt_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 6
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000118
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 2 if score #RAND_RANGE_RESULT temp matches 1000121..1000123 run scoreboard players remove @s action_time 2
				}
				
				func use()
				{
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
				
					execute if score #RAND_RANGE_RESULT temp matches 1000118..1000120 run function skill:damage_formula/blunt/one_hand/swing
					execute if score #RAND_RANGE_RESULT temp matches 1000121..1000123 run function skill:damage_formula/blunt/one_hand/stab
					
					execute if score @s blunt_mastery matches ..55 run function ARG(__PATH)set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s blunt_color
			}
		}
		
		folder th_sword()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 15
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000081
				
				execute if score #RAND_RANGE_RESULT temp matches 1000081..1000089 run scoreboard players set #LAST_ACTION_TYPE temp 1
				execute if score #RAND_RANGE_RESULT temp matches 1000090..1000095 run scoreboard players set #LAST_ACTION_TYPE temp 2
				
				execute if score @s sword_mastery matches ..55 run function ARG(__PATH)oh_sword/set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.sword_l player @a ~ ~ ~ 1 1 0
				function skill:damage_formula/sword/two_hand
				
				scoreboard players add @s action_time 16
				execute if score @s f_attack_skill matches 1.. if score @s sword_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			folder final_attack()
			{
				func try()
				{
					function main:rand_rate
					execute if score #RAND_RESULT temp < @s sword_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 6
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000124
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 2 if score #RAND_RANGE_RESULT temp matches 1000127..1000129 run scoreboard players remove @s action_time 2
				}
				
				func use()
				{
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
					function skill:damage_formula/sword/two_hand
					
					execute if score @s sword_mastery matches ..55 run function skill:afterimage/oh_sword/set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.sword_l player @a ~ ~ ~ 1 1 0
				}
			}
		}
		
		folder th_axe()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 15
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000051
				
				execute if score #RAND_RANGE_RESULT temp matches 1000051..1000059 run function ARG(_PATH)swing_formula
				execute if score #RAND_RANGE_RESULT temp matches 1000060..1000065 run function ARG(_PATH)stab_formula
				
				execute if score @s axe_mastery matches ..55 run function ARG(__PATH)oh_axe/set_color
				function ARG(__PATH)summon_model
				playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				
				scoreboard players add @s action_time 16
				execute if score @s f_attack_skill matches 1.. if score @s axe_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			func swing_formula()
			{
				function skill:damage_formula/axe/two_hand/swing
				scoreboard players set #LAST_ACTION_TYPE temp 1
			}
			
			func stab_formula()
			{
				function skill:damage_formula/axe/two_hand/stab
				scoreboard players set #LAST_ACTION_TYPE temp 2
			}
			
			folder final_attack()
			{
				func try()
				{
					function main:rand_rate
					execute if score #RAND_RESULT temp < @s axe_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 6
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000112
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 2 if score #RAND_RANGE_RESULT temp matches 1000115..1000117 run scoreboard players remove @s action_time 2
				}
				
				func use()
				{
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
				
					execute if score #RAND_RANGE_RESULT temp matches 1000112..1000114 run function skill:damage_formula/axe/two_hand/swing
					execute if score #RAND_RANGE_RESULT temp matches 1000115..1000117 run function skill:damage_formula/axe/two_hand/stab
					
					execute if score @s axe_mastery matches ..55 run function skill:afterimage/oh_axe/set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				}
			}
		}
		
		folder th_blunt()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 15
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000051
				
				execute if score #RAND_RANGE_RESULT temp matches 1000051..1000059 run function ARG(_PATH)swing_formula
				execute if score #RAND_RANGE_RESULT temp matches 1000060..1000065 run function ARG(_PATH)stab_formula
				
				execute if score @s blunt_mastery matches ..55 run function ARG(__PATH)oh_blunt/set_color
				function ARG(__PATH)summon_model
				playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				
				scoreboard players add @s action_time 16
				execute if score @s f_attack_skill matches 1.. if score @s blunt_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			func swing_formula()
			{
				function skill:damage_formula/blunt/two_hand/swing
				scoreboard players set #LAST_ACTION_TYPE temp 1
			}
			
			func stab_formula()
			{
				function skill:damage_formula/blunt/two_hand/stab
				scoreboard players set #LAST_ACTION_TYPE temp 2
			}
			
			folder final_attack()
			{
				func try()
				{
					function main:rand_rate
					execute if score #RAND_RESULT temp < @s blunt_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 6
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000112
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 2 if score #RAND_RANGE_RESULT temp matches 1000115..1000117 run scoreboard players remove @s action_time 2
				}
				
				func use()
				{
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
				
					execute if score #RAND_RANGE_RESULT temp matches 1000112..1000114 run function skill:damage_formula/blunt/two_hand/swing
					execute if score #RAND_RANGE_RESULT temp matches 1000115..1000117 run function skill:damage_formula/blunt/two_hand/stab
					
					execute if score @s blunt_mastery matches ..55 run function skill:afterimage/oh_blunt/set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				}
			}
		}
		
		func summon_model()
		{
			execute rotated ~ 0 run summon minecraft:armor_stand ^ ^ ^0.7 {Tags:["afterimage","new"],Invisible:1,Invulnerable:1,NoGravity:1,Marker:1,Fire:32767s,ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1b,tag:{CustomModelData:1,CustomPotionColor:255}}]}
			execute as @e[type=armor_stand,tag=new] run function ARG(_PATH)model_set
		}
		
		func summon_model_delay()
		{
			execute rotated ~ 0 run summon minecraft:armor_stand ^ ^ ^0.7 {Tags:["afterimage","new"],Invisible:1,Invulnerable:1,NoGravity:1,Marker:1,Fire:32767s,ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1b,tag:{CustomModelData:1}}]}
			execute as @e[type=armor_stand,tag=new] run function ARG(_PATH)model_set_delay
		}
		
		func model_set()
		{
			execute positioned as @s run tp @s ~ ~ ~ ~ ~
			scoreboard players set @s life 8
			scoreboard players operation @s base_model = #RAND_RANGE_RESULT temp
			execute store result entity @s ArmorItems[3].tag.CustomPotionColor int 1 run scoreboard players get #AFTERIMAGE_COLOR temp
			tag @s remove new
		}
		
		func model_set_delay()
		{
			execute positioned as @s run tp @s ~ ~ ~ ~ ~
			scoreboard players set @s life 9
			scoreboard players operation @s base_model = #RAND_RANGE_RESULT temp
			execute store result entity @s ArmorItems[3].tag.CustomPotionColor int 1 run scoreboard players get #AFTERIMAGE_COLOR temp
			tag @s remove new
		}

		func update()
		{
			scoreboard players remove @s life 1
			execute if score @s life matches 0 store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players get @s base_model
			kill @s[scores={life=-4}]
		}
	}
	
	func show_num_at_height()
	{
		scoreboard players remove #NUMBER_HEIGHT temp 1
		execute if score #NUMBER_HEIGHT temp matches -1 run function number_display:show
		execute if score #NUMBER_HEIGHT temp matches 0.. positioned ~ ~0.4 ~ run function ARG(_PATH)show_num_at_height
	}
	
	func hurt_by_magma_cube()
	{
		tag @s add magma_cube_hit
		advancement revoke @s only skill:hurt_by_magma_cube
	}
}