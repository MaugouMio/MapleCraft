import loop
import random

```
skill_ids = []
```

namespace attack_skill_template(skill_id) as virtual
{
	# functions to override:
	#	check => check whether to use the skill or not
	#	mark_target => tag all target
	#	cast_effect => visual and audio effects on casting skill
	#	set_numeric => calculate all numbers related to damage and write to global storage
	#	effect => visual and audio effects with ARG(skill_id)_enum as damage
	#	append_scheduler => see "append_scheduler_sample"
	
	```
	skill_ids.append(str(ARG(skill_id)))
	```
	
	func run()
	{
		function ARG(_PATH)mark_target
		function ARG(_PATH)cast_effect
		function ARG(_PATH)set_numeric
		
		data modify storage skill:main damage_info.attacker set from entity @s UUID
		execute store result storage skill:main damage_info.attacker_id int 1 run scoreboard players get @s number
		
		execute positioned 0.0 0.0 0.0 rotated ~ 0 run summon area_effect_cloud ^ ^ ^0.2 {Duration:0,Tags:["knockback_motion"]}
		data modify storage skill:main damage_info.knock_back set from entity @e[type=area_effect_cloud,tag=knockback_motion,limit=1] Pos
		kill @e[type=area_effect_cloud,tag=knockback_motion,limit=1]
		
		data modify storage skill:main new_schedule set value []
		function ARG(_PATH)append_scheduler
		
		execute as @e[type=zombified_piglin,tag=target] at @s run function ARG(_PATH)hit
	}
	
	func hit_effect()
	{
		execute store result score #GLOBAL ARG(skill_id)_eid run time query gametime
		execute as @e if score @s ARG(skill_id)_eid = #GLOBAL ARG(skill_id)_eid at @s run function ARG(_PATH)perform_effect
	}
	
	func perform_effect()
	{
		data modify entity @s AngryAt set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker
		execute unless score @s pushed_time matches 0.. if score @s kb <= @s ARG(skill_id)_enum run function ARG(_PATH)knock_back
		data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
		
		function ARG(_PATH)effect
		
		scoreboard players reset @s ARG(skill_id)_eid
		execute if score @s hp matches ..0 unless data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] run function skill:mob_dead_event
		execute if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] run function ARG(_PATH)peek_schedule
	}
	
	func knock_back()
	{
		scoreboard players set @s pushed_time 10
		```
		raise Warning("TODO: change model to kb status")
		```
		execute store result score #GLOBAL temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker_id
		execute as @a if score @s number = #GLOBAL temp run tag @s add face_target
		tp @s ~ ~ ~ facing entity @a[tag=face_target,limit=1]
		tag @a[tag=face_target] remove face_target
		
		data modify entity @s Motion set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].knock_back
		
		data modify entity @s ArmorItems[3].tag.AttributeModifiers[{Name:"move_control"}].Amount set value -1.0
	}
	
	func peek_schedule()
	{
		execute store result score @s ARG(skill_id)_eid run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		execute store result score @s ARG(skill_id)_enum run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage
	}
	
	func hit()
	{
		function skill:calculate_damage/run
		
		data modify storage skill:main new_queue set value []
		data modify storage skill:main temp set from storage skill:main new_schedule
		function ARG(_PATH)merge_schedule/run
		data modify entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue prepend from storage skill:main new_queue[]
		function ARG(_PATH)peek_schedule
		
		tag @s remove target
	}
	
	folder merge_schedule() from while_loop("if data storage skill:main temp[0]")
	{
		func execute()
		{
			execute store result score #LEFT temp run data get storage skill:main temp[0]
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
			function ARG(__PATH)merge_ori_schedule/run
			
			data modify storage skill:main new_queue append value {time:0,damage:0,attacker:[I;0,0,0,0],knock_back:[]}
			execute store result storage skill:main new_queue[-1].time int 1 run scoreboard players get #LEFT temp
			data modify storage skill:main new_queue[-1].damage set from entity @s ArmorItems[3].tag.damage_record[0]
			data modify storage skill:main new_queue[-1].attacker set from storage skill:main damage_info.attacker
			data modify storage skill:main new_queue[-1].attacker_id set from storage skill:main damage_info.attacker_id
			data modify storage skill:main new_queue[-1].knock_back set from storage skill:main damage_info.knock_back
			
			data remove storage skill:main temp[0]
			data remove entity @s ArmorItems[3].tag.damage_record[0]
		}
	}
	
	folder merge_ori_schedule() from while_loop("if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] if score #RIGHT temp < #LEFT temp")
	{
		func execute()
		{
			data modify storage skill:main new_queue append from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		}
	}
	
	func append_scheduler_sample() as virtual
	{
		data modify storage skill:main new_schedule append value 0
		execute store result storage skill:main new_schedule[-1] int 1 run schedule function ARG(_PATH)hit_effect 6t append
		data modify storage skill:main new_schedule append value 0
		execute store result storage skill:main new_schedule[-1] int 1 run schedule function ARG(_PATH)hit_effect 9t append
	}
}

namespace enemy_search()
{
	folder search_front() from for_loop().for("#DISTANCE temp", "if score #FOUND_ENEMY temp < #MAX_ENEMY temp positioned ^ ^ ^1")
	{
		func search()
		{
			scoreboard players set #FOUND_ENEMY temp 0
			execute at @s rotated ~ 0 positioned ^ ^ ^1 run function ARG(_PATH)run
		}
		
		func execute()
		{
			execute as @e[type=minecraft:zombified_piglin,tag=enemy,distance=..2] run function ARG(_PATH)pre_mark
			execute if score #FOUND_ENEMY temp >= #MAX_ENEMY temp run function ARG(_PATH)order_mark
		}
		
		func pre_mark()
		{
			scoreboard players add #FOUND_ENEMY temp 1
			tag @s add temp_mark
		}
		
		func order_mark()
		{
			scoreboard players set #FOUND_ENEMY temp 0
			execute at @s as @e[type=zombified_piglin,tag=temp_mark,sort=nearest] run function ARG(_PATH)try_mark
			tag @e[type=zombified_piglin,tag=temp_mark] remove temp_mark
		}
		
		func try_mark()
		{
			execute if score #FOUND_ENEMY temp < #MAX_ENEMY temp run tag @s add target
			scoreboard players add #FOUND_ENEMY temp 1
		}
	}
}



# import 1 as virtual
import 2 as virtual
# import 3 as virtual
# import 4 as virtual
# import 5 as virtual

namespace skill()
{
	# folder 1() from 1();
	folder 2() from 2();
	# folder 3() from 3();
	# folder 4() from 4();
	# folder 5() from 5();
	
	func install()
	{
		scoreboard objectives add right_click minecraft.used:minecraft.carrot_on_a_stick
		
		scoreboard objectives add level dummy
		scoreboard objectives add avoidability dummy
		scoreboard objectives add weapon_defense dummy
		scoreboard objectives add magic_defense dummy
		
		scoreboard objectives add crit_rate dummy
		scoreboard objectives add crit_damage dummy
		scoreboard objectives add addi_crit_rate dummy
		scoreboard objectives add addi_crit_damage dummy
		
		scoreboard objectives add kb dummy
		scoreboard objectives add pushed_time dummy
		scoreboard objectives add action_time dummy
		scoreboard objectives add attack_times dummy
		
		scoreboard objectives add hurt_sound dummy
		scoreboard objectives add die_sound dummy
		```
		for skill in skill_ids:
			print(f"scoreboard objectives add {skill}_level dummy")
			print(f"scoreboard objectives add {skill}_eid dummy")
			print(f"scoreboard objectives add {skill}_enum dummy")
		```
		# function ARG(_PATH)1/install
		function ARG(_PATH)2/install
		# function ARG(_PATH)3/install
		# function ARG(_PATH)4/install
		# function ARG(_PATH)5/install
	}
	
	func main()
	{
		execute as @e[type=area_effect_cloud,scores={type=1}] run function ARG(_PATH)font_effect_update
		execute as @e[type=zombified_piglin,tag=enemy,scores={pushed_time=1..}] run function ARG(_PATH)push_countdown
		execute as @a[scores={action_time=1..}] run function ARG(_PATH)action_countdown
		
		# used skill check
		execute as @a[scores={right_click=1..}] at @s run function ARG(_PATH)check_skill/run
	}
	
	folder check_skill()
	{
		func run()
		{
			execute store result score #USING_SKILL temp run data get entity @s[nbt={SelectedItem:{id:"minecraft:carrot_on_a_stick"}}] SelectedItem.tag.CustomModelData
			function ARG(_PATH)binary_search/run
			scoreboard players reset @s right_click
		}
		
		folder binary_search()
		{
			```
			def binary_search_skill(skill_list, start, end):
				if len(skill_list) == 1:
					print("func run()")
					print("{")
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[0][1]} run function skill:{skill_list[0][0][0]}/{skill_list[0][0][1]}/{skill_list[0][0][2]}/{skill_list[0][0][3:]}/check")
					print("}")
					return
				
				if start == end:
					return
				
				mid = (start + end) // 2
				mid_right = mid + 1
				
				if start == 0 and end == len(skill_list) - 1:
					print("func run()")
				else:
					print(f"func {start}_{end}()")
				print("{")
				if start == mid:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[start][1]} run function skill:{skill_list[start][0][0]}/{skill_list[start][0][1]}/{skill_list[start][0][2]}/{skill_list[start][0][3:]}/check")
				else:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[start][1]}..{skill_list[mid][1]} run function ARG(_PATH){start}_{mid}")
				if mid_right == end:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[end][1]} run function skill:{skill_list[end][0][0]}/{skill_list[end][0][1]}/{skill_list[end][0][2]}/{skill_list[end][0][3:]}/check")
				else:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[mid_right][1]}..{skill_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
				print("}")
				
				binary_search_skill(skill_list, start, mid)
				binary_search_skill(skill_list, mid_right, end)
			
			with open(PROJ_DIR + "/../skill_icons.csv") as f:
				skill_models = f.read().split("\n")
				for i in range(len(skill_models)):
					skill_models[i] = skill_models[i].split(",")
					skill_models[i][1] = int(skill_models[i][1])
			
			binary_search_skill(skill_models, 0, len(skill_models) - 1)
			```
		}
	}
	
	func action_countdown()
	{
		scoreboard players remove @s action_time 1
		scoreboard players reset @s[scores={action_time=0}] action_time
	}
	
	func push_countdown()
	{
		scoreboard players remove @s pushed_time 1
		execute if score @s pushed_time matches 0 run data modify entity @s ArmorItems[3].tag.AttributeModifiers[{Name:"move_control"}].Amount set value 0.0
		scoreboard players reset @s[scores={pushed_time=0}] pushed_time
	}
	
	folder calculate_damage()
	{
		func run()
		{
			data modify entity @s ArmorItems[3].tag.damage_record set value []
			# copy damage list
			data modify storage skill:main damage_copy set from storage skill:main damage
			scoreboard players set #SAME_DAMAGE temp 0
			function ARG(_PATH)traverse_damages/run
			
			execute if score @s hp matches ..0 run function ARG(_PATH)record_dead
		}
		
		func record_dead()
		{
			data merge entity @s {Attributes:[{Name:"generic.attack_damage",Base:0.0},{Name:"generic.movement_speed",Base:0.0}]}
			loot spawn ~ ~ ~ kill @s
			```
			raise Warning("TODO: give exp to killer player")
			```
			tag @s remove enemy
		}
		
		folder traverse_damages() from while_loop("if data storage skill:main damage_copy[0] positioned ~ ~0.4 ~")
		{
			func execute()
			{
				execute unless score #SAME_DAMAGE temp matches 1 run function ARG(_PATH)record_value
				execute store result score #GLOBAL display_delay run data get storage skill:main damage_copy[0].delay
				data remove storage skill:main damage_copy[0]
				
				data modify entity @s ArmorItems[3].tag.damage_record append value 0
				
				function main:rand_rate
				scoreboard players set @s display_num_type 0
				execute if score #HIT_RATE temp <= #RAND_RESULT temp run scoreboard players set @s display_number 0
				execute if score #HIT_RATE temp > #RAND_RESULT temp run function ARG(_PATH)deal_damage
				function number_display:show
			}
			
			func record_value()
			{
				execute store result score #MIN_DAMAGE temp run data get storage skill:main damage_copy[0].info.min_damage
				execute store result score #MAX_DAMAGE temp run data get storage skill:main damage_copy[0].info.max_damage
				execute store result score #BASE_PERCENT temp run data get storage skill:main damage_copy[0].info.base_percent
				execute store result score #CRIT_RATE temp run data get storage skill:main damage_copy[0].info.crit_rate
				execute store result score #CRIT_DAMAGE temp run data get storage skill:main damage_copy[0].info.crit_damage
				scoreboard players operation #CRIT_DAMAGE temp += #BASE_PERCENT temp
				execute store result score #LEVEL_DIFFERENCE temp run data get storage skill:main damage_copy[0].info.player_level -1
				scoreboard players operation #LEVEL_DIFFERENCE temp += @s level
				scoreboard players operation #LEVEL_DIFFERENCE temp > #0 const
				# ATTRIBUTE 0 = weapon attack; 1 = magic attack; 2 = fire; 3 = poison; 4 = ice; 5 = lightning; 6 = holy
				execute store result score #ATTRIBUTE temp run data get storage skill:main damage_copy[0].info.attribute
				execute if score #ATTRIBUTE temp matches 2.. run function ARG(_PATH)attribute_multiply/run
				# Calculate defense and hit rate
				execute if score #ATTRIBUTE temp matches 0 run function ARG(_PATH)weapon_formula
				execute if score #ATTRIBUTE temp matches 1.. run function ARG(_PATH)magic_formula
				
				execute store success score #SAME_DAMAGE temp run data modify storage skill:main damage_copy[0].info set from storage skill:main damage_copy[1].info
			}
			
			func weapon_formula()
			{
				# defense
				scoreboard players operation #DEFENSE temp = @s weapon_defense
				scoreboard players operation #DEFENSE temp /= #2 const
				
				scoreboard players set #LEVEL_PUNISH temp 100
				scoreboard players operation #LEVEL_PUNISH temp -= #LEVEL_DIFFERENCE temp
				scoreboard players operation #MAX_DAMAGE temp *= #LEVEL_PUNISH temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				scoreboard players operation #MAX_DAMAGE temp -= #DEFENSE temp
				
				scoreboard players operation #MIN_DAMAGE temp *= #LEVEL_PUNISH temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				scoreboard players operation #DEFENSE temp *= #6 const
				scoreboard players operation #DEFENSE temp /= #5 const
				scoreboard players operation #MIN_DAMAGE temp -= #DEFENSE temp
				
				# hit rate
				execute store result score #HIT_RATE temp run data get storage skill:main damage_copy[0].info.accuracy 100000
				scoreboard players operation #LEVEL_DIFFERENCE temp *= #66 const
				scoreboard players add #LEVEL_DIFFERENCE temp 1835
				scoreboard players operation #LEVEL_DIFFERENCE temp *= @s avoidability
				scoreboard players operation #HIT_RATE temp /= #LEVEL_DIFFERENCE temp
				scoreboard players remove #HIT_RATE temp 100
			}
			
			func magic_formula()
			{
				# defense
				scoreboard players operation #DEFENSE temp = @s magic_defense
				scoreboard players operation #DEFENSE temp /= #2 const
				
				scoreboard players set #LEVEL_PUNISH temp 100
				scoreboard players operation #LEVEL_PUNISH temp += #LEVEL_DIFFERENCE temp
				scoreboard players operation #DEFENSE temp *= #LEVEL_PUNISH temp
				scoreboard players operation #DEFENSE temp /= #100 const
				scoreboard players operation #MAX_DAMAGE temp -= #DEFENSE temp
				
				scoreboard players operation #DEFENSE temp *= #6 const
				scoreboard players operation #DEFENSE temp /= #5 const
				scoreboard players operation #MIN_DAMAGE temp -= #DEFENSE temp
				
				# hit rate
				scoreboard players operation #LEVEL_DIFFERENCE temp *= #4 const
				scoreboard players add #LEVEL_DIFFERENCE temp 100
				scoreboard players operation #MAX_ACCURACY temp = @s avoidability
				scoreboard players add #MAX_ACCURACY temp 1
				scoreboard players operation #MAX_ACCURACY temp *= #LEVEL_DIFFERENCE temp
				scoreboard players operation #MAX_ACCURACY temp /= #100 const
				
				scoreboard players operation #MIN_ACCURACY temp = #MAX_ACCURACY temp
				scoreboard players operation #MIN_ACCURACY temp *= #41 const
				scoreboard players operation #MIN_ACCURACY temp /= #100 const
				
				execute store result score #ACCURACY temp run data get storage skill:main damage_copy[0].info.accuracy
				scoreboard players operation #ACCURACY temp -= #MIN_ACCURACY temp
				scoreboard players add #ACCURACY temp 1
				scoreboard players operation #ACCURACY temp *= #100 const
				
				scoreboard players operation #MAX_ACCURACY temp -= #MIN_ACCURACY temp
				scoreboard players add #MAX_ACCURACY temp 1
				
				execute store result score #HIT_RATE temp run scoreboard players operation #ACCURACY temp /= #MAX_ACCURACY temp
				scoreboard players operation #HIT_RATE temp *= #HIT_RATE temp
				scoreboard players operation #HIT_RATE temp *= #-7 const
				scoreboard players operation #HIT_RATE temp /= #1000 const
				
				scoreboard players operation #ACCURACY temp *= #17 const
				scoreboard players operation #ACCURACY temp /= #10 const
				
				scoreboard players operation #HIT_RATE temp += #ACCURACY temp
			}
			
			func deal_damage()
			{
				scoreboard players operation #MAX_DAMAGE_FINAL temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE_FINAL temp = #MIN_DAMAGE temp
				
				execute if score #CRIT_RATE temp matches 1.. run function main:rand_rate
				execute if score #CRIT_RATE temp > #RAND_RESULT temp run function ARG(_PATH)crit_multiply
				execute unless score #CRIT_RATE temp > #RAND_RESULT temp run function ARG(_PATH)skill_multiply
				
				scoreboard players set @s display_number 0
				execute unless score #MAX_DAMAGE_FINAL temp = #MIN_DAMAGE_FINAL temp run function ARG(_PATH)rand_damage
				scoreboard players add @s display_number 1
				scoreboard players operation @s display_number < #99999 const
				scoreboard players operation @s display_number > #1 const
				
				scoreboard players operation @s hp -= @s display_number
				execute store result entity @s ArmorItems[3].tag.damage_record[-1] int 1 run scoreboard players get @s display_number
			}
			
			folder attribute_multiply()
			{
				func run()
				{
					execute if score #ATTRIBUTE temp matches 2 run function ARG(_PATH)fire
					execute if score #ATTRIBUTE temp matches 3 run function ARG(_PATH)poison
					execute if score #ATTRIBUTE temp matches 4 run function ARG(_PATH)ice
					execute if score #ATTRIBUTE temp matches 5 run function ARG(_PATH)lightning
					execute if score #ATTRIBUTE temp matches 6 run function ARG(_PATH)holy
					execute if score #ATTRIBUTE temp matches 2.. run function ARG(_PATH)divide_back
				}
				
				func fire()
				{
					execute if entity @s[tag=fire_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=fire_weakness] run function ARG(_PATH)weakness
				}
				
				func poison()
				{
					execute if entity @s[tag=poison_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=poison_weakness] run function ARG(_PATH)weakness
				}
				
				func ice()
				{
					execute if entity @s[tag=ice_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=ice_weakness] run function ARG(_PATH)weakness
				}
				
				func lightning()
				{
					execute if entity @s[tag=lightning_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=lightning_weakness] run function ARG(_PATH)weakness
				}
				
				func holy()
				{
					execute if entity @s[tag=holy_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=holy_weakness] run function ARG(_PATH)weakness
				}
	
				func resist()
				{
					scoreboard players operation #MIN_DAMAGE temp *= #50 const
					scoreboard players operation #MAX_DAMAGE temp *= #50 const
				}
				
				func weakness()
				{
					scoreboard players operation #MIN_DAMAGE temp *= #150 const
					scoreboard players operation #MAX_DAMAGE temp *= #150 const
				}
				
				func divide_back()
				{
					scoreboard players operation #MIN_DAMAGE temp /= #100 const
					scoreboard players operation #MAX_DAMAGE temp /= #100 const
				}
			}
			
			func crit_multiply()
			{
				scoreboard players operation #MAX_DAMAGE_FINAL temp *= #CRIT_DAMAGE temp
				scoreboard players operation #MAX_DAMAGE_FINAL temp /= #100 const
				scoreboard players operation #MIN_DAMAGE_FINAL temp *= #CRIT_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE_FINAL temp /= #100 const
				scoreboard players set @s display_num_type 1
			}
			
			func skill_multiply()
			{
				scoreboard players operation #MAX_DAMAGE_FINAL temp *= #BASE_PERCENT temp
				scoreboard players operation #MAX_DAMAGE_FINAL temp /= #100 const
				scoreboard players operation #MIN_DAMAGE_FINAL temp *= #BASE_PERCENT temp
				scoreboard players operation #MIN_DAMAGE_FINAL temp /= #100 const
			}
			
			func rand_damage() from random().generate("#MIN_DAMAGE_FINAL temp", "#MAX_DAMAGE_FINAL temp", "@s display_number");
		}
	}
	
	func mob_dead_event()
	{
		function skill:play_die_sound/run
		kill @s
	}
	
	folder play_hurt_sound()
	{
		```
		def bs_hurt_sound(sound_list, start, end):
			if len(sound_list) == 1:
				print("func run()")
				print("{")
				print(f"\texecute if score @s hurt_sound matches {sound_list[0][1]} run playsound minecraft:mob.hurt.{sound_list[0][0]} hostile @a ~ ~ ~ 1 1 0")
				print("}")
				return
			
			if start == end:
				return
			
			mid = (start + end) // 2
			mid_right = mid + 1
			
			if start == 0 and end == len(sound_list) - 1:
				print("func run()")
			else:
				print(f"func {start}_{end}()")
			print("{")
			if start == mid:
				print(f"\texecute if score @s hurt_sound matches {sound_list[start][1]} run playsound minecraft:mob.hurt.{sound_list[start][0]} hostile @a ~ ~ ~ 1 1 0")
			else:
				print(f"\texecute if score @s hurt_sound matches {sound_list[start][1]}..{sound_list[mid][1]} run function ARG(_PATH){start}_{mid}")
			if mid_right == end:
				print(f"\texecute if score @s hurt_sound matches {sound_list[end][1]} run playsound minecraft:mob.hurt.{sound_list[end][0]} hostile @a ~ ~ ~ 1 1 0")
			else:
				print(f"\texecute if score @s hurt_sound matches {sound_list[mid_right][1]}..{sound_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
			print("}")
			
			bs_hurt_sound(sound_list, start, mid)
			bs_hurt_sound(sound_list, mid_right, end)
		
		with open(PROJ_DIR + "/../hurt_sounds.csv") as f:
			hurt_sounds = f.read().split("\n")
			for i in range(len(hurt_sounds)):
				hurt_sounds[i] = hurt_sounds[i].split(",")
				hurt_sounds[i][1] = int(hurt_sounds[i][1])
		
		bs_hurt_sound(hurt_sounds, 0, len(hurt_sounds) - 1)
		```
	}
	
	folder play_die_sound()
	{
		```
		def bs_die_sound(sound_list, start, end):
			if len(sound_list) == 1:
				print("func run()")
				print("{")
				print(f"\texecute if score @s die_sound matches {sound_list[0][1]} run playsound minecraft:mob.die.{sound_list[0][0]} hostile @a ~ ~ ~ 1 1 0")
				print("}")
				return
			
			if start == end:
				return
			
			mid = (start + end) // 2
			mid_right = mid + 1
			
			if start == 0 and end == len(sound_list) - 1:
				print("func run()")
			else:
				print(f"func {start}_{end}()")
			print("{")
			if start == mid:
				print(f"\texecute if score @s die_sound matches {sound_list[start][1]} run playsound minecraft:mob.die.{sound_list[start][0]} hostile @a ~ ~ ~ 1 1 0")
			else:
				print(f"\texecute if score @s die_sound matches {sound_list[start][1]}..{sound_list[mid][1]} run function ARG(_PATH){start}_{mid}")
			if mid_right == end:
				print(f"\texecute if score @s die_sound matches {sound_list[end][1]} run playsound minecraft:mob.die.{sound_list[end][0]} hostile @a ~ ~ ~ 1 1 0")
			else:
				print(f"\texecute if score @s die_sound matches {sound_list[mid_right][1]}..{sound_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
			print("}")
			
			bs_die_sound(sound_list, start, mid)
			bs_die_sound(sound_list, mid_right, end)
		
		with open(PROJ_DIR + "/../die_sounds.csv") as f:
			die_sounds = f.read().split("\n")
			for i in range(len(die_sounds)):
				die_sounds[i] = die_sounds[i].split(",")
				die_sounds[i][1] = int(die_sounds[i][1])
		
		bs_die_sound(die_sounds, 0, len(die_sounds) - 1)
		```
	}
	
	func font_effect_update()
	{
		execute store result score #GLOBAL temp run data get entity @s Age
		scoreboard players operation #GLOBAL temp %= #10 const
		execute if score #GLOBAL temp matches 0 run data remove entity @s Tags[0]
		
		data modify storage skill:main effect_font set from entity @s Tags[0]
		data modify block 0 0 0 Text1 set value '[{"nbt":"effect_font","storage":"skill:main","interpret":true},{"text":"F","font":"space:default"},{"score":{"name":"#GLOBAL","objective":"temp"}},{"text":"F","font":"space:default"}]'
		data modify entity @s CustomName set from block 0 0 0 Text1
	}
	
	folder summon_font_effect()
	{
		```
		font_root_path = os.path.dirname(os.path.abspath(PROJ_DIR)) + "/MapleCraft resource pack/assets/skill/font"
		for root, dirs, files in os.walk(font_root_path):
			for name in files:
				if name == "summon.txt":
					func_name = ""
					recursive_path = root
					for i in range(3):
						func_name = os.path.basename(recursive_path) + func_name
						recursive_path = os.path.dirname(recursive_path)
						
					print(f"func {func_name}()")
					print("{")
					with open(os.path.join(root, name), "r") as f:
						print(f.read())
					print("}")
					
					break
		```
	}
	
	func test_mob()
	{
		execute rotated ~ 0 run summon zombified_piglin ^ ^ ^5 {Tags:["new","enemy"],ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1b,tag:{CustomModelData:1,Unbreakable:1,AttributeModifiers:[{Name:"move_control",AttributeName:"generic.movement_speed",Amount:0.0,Operation:0,UUID:[I;0,1,0,1]}]}}],ArmorDropChances:[0.0,0.0,0.0,0.0],Silent:1,PersistenceRequired:1,Attributes:[{Name:"generic.attack_damage",Base:1.2}]}
		execute rotated ~ 0 run summon zombified_piglin ^ ^ ^5 {Tags:["new","enemy"],ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1b,tag:{CustomModelData:1,Unbreakable:1,AttributeModifiers:[{Name:"move_control",AttributeName:"generic.movement_speed",Amount:0.0,Operation:0,UUID:[I;0,1,0,1]}]}}],ArmorDropChances:[0.0,0.0,0.0,0.0],Silent:1,PersistenceRequired:1,Attributes:[{Name:"generic.attack_damage",Base:1.2}]}
		execute rotated ~ 0 run summon zombified_piglin ^ ^ ^5 {Tags:["new","enemy"],ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1b,tag:{CustomModelData:1,Unbreakable:1,AttributeModifiers:[{Name:"move_control",AttributeName:"generic.movement_speed",Amount:0.0,Operation:0,UUID:[I;0,1,0,1]}]}}],ArmorDropChances:[0.0,0.0,0.0,0.0],Silent:1,PersistenceRequired:1,Attributes:[{Name:"generic.attack_damage",Base:1.2}]}
		
		scoreboard players set @e[type=zombified_piglin,tag=new] level 25
		scoreboard players set @e[type=zombified_piglin,tag=new] hp 550
		scoreboard players set @e[type=zombified_piglin,tag=new] avoidability 8
		scoreboard players set @e[type=zombified_piglin,tag=new] weapon_defense 20
		scoreboard players set @e[type=zombified_piglin,tag=new] magic_defense 30
		scoreboard players set @e[type=zombified_piglin,tag=new] kb 1
		scoreboard players set @e[type=zombified_piglin,tag=new] hurt_sound 1
		scoreboard players set @e[type=zombified_piglin,tag=new] die_sound 1
		tag @e[type=zombified_piglin,tag=new] remove new
	}
}