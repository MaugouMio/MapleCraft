import loop
import random

```
skill_ids = []

mastery_weapons = ["claw", "dagger", "bow", "crossbow", "spear", "polearm", "sword", "axe", "blunt"]
```

namespace attack_skill_template(skill_id) as virtual
{
	# functions to override:
	#	check => check whether to use the skill or not
	#	mark_target => tag all target
	#	cast_effect => visual and audio effects on casting skill
	#	set_numeric => calculate all numbers related to damage and write to global storage
	#	add_debuff => set all debuff numbers as the hit mob
	#	effect => visual and audio effects with display_number as damage
	#	append_scheduler => see "append_scheduler_sample"
	
	```
	skill_ids.append("ARG(skill_id)")
	```
	
	func run()
	{
		scoreboard players set @s hp_recover_time 10
		# movement restriction
		attribute @s minecraft:generic.movement_speed modifier add 5b908c48-54cb-4388-aa76-82f61b02032d skill_action -10 multiply
		
		function ARG(_PATH)mark_target
		function ARG(_PATH)cast_effect
		function ARG(_PATH)set_numeric
		
		data modify storage skill:main damage_info.attacker set from entity @s UUID
		execute store result storage skill:main damage_info.attacker_id int 1 run scoreboard players get @s number
		
		execute positioned 0.0 0.0 0.0 rotated ~ 0 run summon area_effect_cloud ^ ^ ^0.2 {Duration:0,Tags:["knockback_motion"]}
		data modify storage skill:main damage_info.knock_back set from entity @e[type=area_effect_cloud,tag=knockback_motion,limit=1] Pos
		kill @e[type=area_effect_cloud,tag=knockback_motion,limit=1]
		
		data modify storage skill:main new_schedule set value []
		function ARG(_PATH)append_scheduler
		
		execute as @e[type=zombified_piglin,tag=target] at @s run function ARG(_PATH)hit
	}
	
	func hit_effect()
	{
		execute store result score #GLOBAL ARG(skill_id)_eid run time query gametime
		execute as @e[type=zombified_piglin,tag=enemy] if score @s ARG(skill_id)_eid = #GLOBAL ARG(skill_id)_eid at @s run function ARG(_PATH)perform_effect
	}
	
	func perform_effect()
	{
		execute store result score @s display_number run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.number
		execute store result score @s display_num_type run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.crit
		execute store result score #NUMBER_HEIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.height
		data modify entity @s AngryAt set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker
		
		execute unless score @s pushed_time matches 0.. if score @s kb <= @s display_number run function ARG(_PATH)knock_back
		data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
		
		function ARG(_PATH)effect
		function skill:show_num_at_height
		
		scoreboard players reset @s ARG(skill_id)_eid
		execute if score @s hp matches ..0 unless data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] run function skill:mob_effect/dead
		execute if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] store result score @s ARG(skill_id)_eid run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
	}
	
	func knock_back()
	{
		scoreboard players set @s pushed_time 12
		scoreboard players operation @s kb_time > @s pushed_time
		execute store result score #GLOBAL temp run scoreboard players set @s status 2
		execute store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players operation #GLOBAL temp += @s base_model
		
		execute store result score #GLOBAL temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker_id
		execute as @a if score @s number = #GLOBAL temp run tag @s add face_target
		tp @s ~ ~ ~ facing entity @a[tag=face_target,limit=1]
		tag @a[tag=face_target] remove face_target
		
		data modify entity @s Motion set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].knock_back
		
		data modify entity @s ArmorItems[3].tag.AttributeModifiers[{Name:"move_control"}].Amount set value -1.0
	}
	
	func hit()
	{
		function skill:calculate_damage/run
		
		data modify storage skill:main new_queue set value []
		data modify storage skill:main temp set from storage skill:main new_schedule
		function ARG(_PATH)merge_schedule/run
		data modify entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue prepend from storage skill:main new_queue[]
		execute store result score @s ARG(skill_id)_eid run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		
		execute if score #DID_HIT temp matches 1 run function ARG(_PATH)add_debuff
		
		tag @s remove target
	}
	
	folder merge_schedule() from while_loop("if data storage skill:main temp[0]")
	{
		func execute()
		{
			execute store result score #LEFT temp run data get storage skill:main temp[0]
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
			function ARG(__PATH)merge_ori_schedule/run
			
			data modify storage skill:main new_queue append value {}
			execute store result storage skill:main new_queue[-1].time int 1 run scoreboard players get #LEFT temp
			data modify storage skill:main new_queue[-1].damage set from entity @s ArmorItems[3].tag.damage_record[0]
			data modify storage skill:main new_queue[-1].attacker set from storage skill:main damage_info.attacker
			data modify storage skill:main new_queue[-1].attacker_id set from storage skill:main damage_info.attacker_id
			data modify storage skill:main new_queue[-1].knock_back set from storage skill:main damage_info.knock_back
			
			data remove storage skill:main temp[0]
			data remove entity @s ArmorItems[3].tag.damage_record[0]
		}
	}
	
	folder merge_ori_schedule() from while_loop("if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] if score #RIGHT temp < #LEFT temp")
	{
		func execute()
		{
			data modify storage skill:main new_queue append from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		}
	}
	
	func add_debuff();
	func append_scheduler_sample() as virtual
	{
		data modify storage skill:main new_schedule append value 0
		execute store result storage skill:main new_schedule[-1] int 1 run schedule function ARG(_PATH)hit_effect 6t append
		data modify storage skill:main new_schedule append value 0
		execute store result storage skill:main new_schedule[-1] int 1 run schedule function ARG(_PATH)hit_effect 9t append
	}
}

namespace bullet_skill_template(skill_id) as virtual
{
	# functions to override:
	#	check => check whether to use the skill or not
	#	mark_target => tag all target
	#	cast_effect => visual and audio effects on casting skill
	#	set_numeric => calculate all numbers related to damage and write to global storage
	#	add_debuff => set all debuff numbers as the hit mob (optional)
	#	effect => visual and audio effects with display_number as damage
	#	append_scheduler => see "append_scheduler_sample"
	
	```
	skill_ids.append("ARG(skill_id)")
	```
	
	func run()
	{
		scoreboard players set @s hp_recover_time 10
		# movement restriction
		attribute @s minecraft:generic.movement_speed modifier add 5b908c48-54cb-4388-aa76-82f61b02032d skill_action -10 multiply
		
		function ARG(_PATH)mark_target
		function ARG(_PATH)cast_effect
		function ARG(_PATH)summon_bullet
		function ARG(_PATH)set_numeric
		
		data modify storage skill:main damage_info.attacker set from entity @s UUID
		execute store result storage skill:main damage_info.attacker_id int 1 run scoreboard players get @s number
		
		execute positioned 0.0 0.0 0.0 rotated ~ 0 run summon area_effect_cloud ^ ^ ^0.2 {Duration:0,Tags:["knockback_motion"]}
		data modify storage skill:main damage_info.knock_back set from entity @e[type=area_effect_cloud,tag=knockback_motion,limit=1] Pos
		kill @e[type=area_effect_cloud,tag=knockback_motion,limit=1]
		
		scoreboard players set #DID_HIT_ENEMY temp 0
		scoreboard players add #BULLET_ID number 1
		execute as @e[type=zombified_piglin,tag=target] at @s run function ARG(_PATH)hit
		execute if score #DID_HIT_ENEMY temp matches 0 as @e[type=armor_stand,tag=new_bullet] run function skill:bullet/no_target_setting
	}
	
	func hit_effect()
	{
		execute store result score #GLOBAL ARG(skill_id)_eid run time query gametime
		execute as @e[type=zombified_piglin,tag=enemy] if score @s ARG(skill_id)_eid = #GLOBAL ARG(skill_id)_eid at @s run function ARG(_PATH)perform_effect
	}
	
	func perform_effect()
	{
		execute store result score @s display_number run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.number
		execute store result score @s display_num_type run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.crit
		execute store result score #NUMBER_HEIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.height
		data modify entity @s AngryAt set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker
		
		execute unless score @s pushed_time matches 0.. if score @s kb <= @s display_number run function ARG(_PATH)knock_back
		data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
		
		function ARG(_PATH)effect
		function skill:show_num_at_height
		
		scoreboard players reset @s ARG(skill_id)_eid
		execute if score @s hp matches ..0 unless data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] run function skill:mob_effect/dead
		execute if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] store result score @s ARG(skill_id)_eid run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
	}
	
	func knock_back()
	{
		scoreboard players set @s pushed_time 12
		scoreboard players operation @s kb_time > @s pushed_time
		execute store result score #GLOBAL temp run scoreboard players set @s status 2
		execute store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players operation #GLOBAL temp += @s base_model
		
		execute store result score #GLOBAL temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker_id
		execute as @a if score @s number = #GLOBAL temp run tag @s add face_target
		tp @s ~ ~ ~ facing entity @a[tag=face_target,limit=1]
		tag @a[tag=face_target] remove face_target
		
		data modify entity @s Motion set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].knock_back
		
		data modify entity @s ArmorItems[3].tag.AttributeModifiers[{Name:"move_control"}].Amount set value -1.0
	}
	
	func hit()
	{
		scoreboard players operation #GLOBAL temp = @s number
		execute as @e[type=armor_stand,tag=new_bullet] run function skill:bullet/setting
		function skill:calculate_damage/run
		
		data modify entity @s ArmorItems[3].tag.bullet_list append value {}
		execute store result entity @s ArmorItems[3].tag.bullet_list[-1].bullet_id int 1 run scoreboard players get #BULLET_ID number
		data modify entity @s ArmorItems[3].tag.bullet_list[-1].damage_record set from entity @s ArmorItems[3].tag.damage_record
		data modify entity @s ArmorItems[3].tag.bullet_list[-1].damage_info set from storage skill:main damage_info
	
		execute if score #DID_HIT temp matches 1 run function ARG(_PATH)add_debuff
		
		tag @s remove target
		scoreboard players add @s bullet_targeted 1
		scoreboard players set #DID_HIT_ENEMY temp 1
	}
	
	folder bullet_hit()
	{
		func run()
		{
			data modify storage skill:main temp set value []
			function ARG(_PATH)pop_bullet_list
			
			data modify storage skill:main new_queue set value []
			function ARG(__PATH)merge_schedule/run
			data modify entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue prepend from storage skill:main new_queue[]
			execute store result score @s ARG(skill_id)_eid run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
			
			data remove entity @s ArmorItems[3].tag.bullet_list[0]
			data modify entity @s ArmorItems[3].tag.bullet_list prepend from storage skill:main temp[]
		}
		
		func pop_bullet_list()
		{
			execute store result score #CUR_BULLET_ID temp run data get entity @s ArmorItems[3].tag.bullet_list[0].bullet_id
			execute unless score #CUR_BULLET_ID temp = #BULLET_ID temp run function ARG(_PATH)check_next
		}
		
		func check_next()
		{
			data modify storage skill:main temp append from entity @s ArmorItems[3].tag.bullet_list[0]
			data remove entity @s ArmorItems[3].tag.bullet_list[0]
			function ARG(_PATH)pop_bullet_list
		}
	}
	
	folder merge_schedule() from while_loop("if data storage skill:main new_schedule[0]")
	{
		func execute()
		{
			execute store result score #LEFT temp run data get storage skill:main new_schedule[0]
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
			function ARG(__PATH)merge_ori_schedule/run
			
			data modify storage skill:main new_queue append value {time:0,damage:0,attacker:[I;0,0,0,0],knock_back:[]}
			execute store result storage skill:main new_queue[-1].time int 1 run scoreboard players get #LEFT temp
			data modify storage skill:main new_queue[-1].damage set from entity @s ArmorItems[3].tag.bullet_list[0].damage_record[0]
			data modify storage skill:main new_queue[-1].attacker set from entity @s ArmorItems[3].tag.bullet_list[0].damage_info.attacker
			data modify storage skill:main new_queue[-1].attacker_id set from entity @s ArmorItems[3].tag.bullet_list[0].damage_info.attacker_id
			data modify storage skill:main new_queue[-1].knock_back set from entity @s ArmorItems[3].tag.bullet_list[0].damage_info.knock_back
			
			data remove storage skill:main new_schedule[0]
			data remove entity @s ArmorItems[3].tag.bullet_list[0].damage_record[0]
		}
	}
	
	folder merge_ori_schedule() from while_loop("if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] if score #RIGHT temp < #LEFT temp")
	{
		func execute()
		{
			data modify storage skill:main new_queue append from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		}
	}
	
	func add_debuff();
	func summon_bullet_sample() as virtual
	{
		# first bullet should have "first_bullet" tag
		# last bullet should have "last_bullet" tag
		summon minecraft:armor_stand ~ ~ ~ {Tags:["first_bullet","new_bullet","bullet"],CustomName:'{"text":"2","font":"space:default"}',ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1,tag:{appear_delay:16,max_distance:5,skill_id:1,bullet_model:123,CustomModelData:1}}],Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Fire:32767s,CustomNameVisible:0}
		summon minecraft:armor_stand ~ ~ ~ {Tags:["last_bullet","new_bullet","bullet"],CustomName:'{"text":"2","font":"space:default"}',ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1,tag:{appear_delay:19,max_distance:5,skill_id:1,bullet_model:123,CustomModelData:1}}],Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Fire:32767s,CustomNameVisible:0}
	}
}



import 0 as virtual
import 1 as virtual
import 2 as virtual
import 3 as virtual
import 4 as virtual
# import 5 as virtual

namespace skill()
{
	folder 0() from 0();
	folder 1() from 1();
	folder 2() from 2();
	folder 3() from 3();
	folder 4() from 4();
	# folder 5() from 5();
	
	func install()
	{
		scoreboard objectives add right_click minecraft.used:minecraft.carrot_on_a_stick
		scoreboard objectives add base_model dummy
		scoreboard objectives add status dummy
		scoreboard objectives add motion_x dummy
		scoreboard objectives add motion_z dummy
		
		scoreboard objectives add level dummy
		scoreboard objectives add avoidability dummy
		scoreboard objectives add weapon_defense dummy
		scoreboard objectives add magic_defense dummy
		scoreboard objectives add base_accuracy dummy
		
		scoreboard objectives add crit_rate dummy
		scoreboard objectives add crit_damage dummy
		scoreboard objectives add addi_crit_rate dummy
		scoreboard objectives add addi_crit_damage dummy
		
		scoreboard objectives add kb dummy
		scoreboard objectives add kb_time dummy
		scoreboard objectives add pushed_time dummy
		scoreboard objectives add freeze_time dummy
		scoreboard objectives add poison_time dummy
		scoreboard objectives add next_poison dummy
		scoreboard objectives add poison_damage dummy
		scoreboard objectives add poison_particle dummy
		scoreboard objectives add action_time dummy
		scoreboard objectives add attack_times dummy
		
		scoreboard objectives add hurt_sound dummy
		scoreboard objectives add die_sound dummy
		
		scoreboard objectives add target_id dummy
		scoreboard objectives add skill_id dummy
		scoreboard objectives add bullet_targeted dummy
		```
		for weapon in mastery_weapons:
			print(f"scoreboard objectives add {weapon}_mastery dummy")
			print(f"scoreboard objectives add {weapon}_accuracy dummy")
		
		for skill in skill_ids:
			print(f"scoreboard objectives add {skill}_level dummy")
			print(f"scoreboard objectives add {skill}_eid dummy")
		```
		# function ARG(_PATH)1/install
		function ARG(_PATH)2/install
		# function ARG(_PATH)3/install
		# function ARG(_PATH)4/install
		# function ARG(_PATH)5/install
	}
	
	folder loop()
	{
		func schedule_1d()
		{
			scoreboard players set #BULLET_ID number 1
		}
	}
	
	folder main()
	{
		func run()
		{
			execute as @e[type=area_effect_cloud,scores={type=1}] run function ARG(_PATH)font_effect_update
			execute as @e[type=armor_stand,tag=bullet] run function skill:bullet/check
			execute as @e[type=armor_stand,tag=model_animation] run function ARG(_PATH)model_animation_update
			execute as @e[type=armor_stand,tag=afterimage] run function skill:afterimage/update
			execute as @e[type=zombified_piglin,tag=enemy] run function ARG(_PATH)enemy/run
			execute as @a[scores={action_time=1..}] run function ARG(_PATH)action/countdown
			
			# used skill check
			execute as @a[scores={right_click=1..}] at @s run function skill:check_skill/run
		}
		
		func font_effect_update()
		{
			execute store result score #GLOBAL temp run data get entity @s Age
			scoreboard players operation #GLOBAL temp %= #10 const
			execute if score #GLOBAL temp matches 0 run data remove entity @s Tags[0]
			
			data modify storage skill:main effect_font set from entity @s Tags[0]
			data modify block 0 0 0 Text1 set value '[{"nbt":"effect_font","storage":"skill:main","interpret":true},{"text":"F","font":"space:default"},{"score":{"name":"#GLOBAL","objective":"temp"}},{"text":"F","font":"space:default"}]'
			data modify entity @s CustomName set from block 0 0 0 Text1
		}
		
		func model_animation_update()
		{
			execute store result score #GLOBAL temp run scoreboard players add @s life 1
			execute store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players operation #GLOBAL temp += @s base_model
			
			execute if score @s life = @s max_life run kill @s
		}
		
		folder enemy()
		{
			func run()
			{
				execute unless score @s[tag=!dead] kb_time matches 1.. run function ARG(_PATH)status_change/run
				execute if entity @s[tag=color_changed] run function ARG(_PATH)status_change/color/check
				
				execute if score @s kb_time matches 1.. run function ARG(_PATH)kb/countdown
				execute if score @s pushed_time matches 1.. run function ARG(_PATH)push_countdown
				execute if score @s bullet_targeted matches 1.. at @s run function ARG(_PATH)move_bullets
			}
			
			folder status_change()
			{
				func run()
				{
					scoreboard players set #GLOBAL temp 0
					execute if data entity @s {OnGround:0b} run scoreboard players set #GLOBAL temp 3
					execute if score #GLOBAL temp matches 0 run function ARG(_PATH)check_motion
					
					execute unless score @s status = #GLOBAL temp run function ARG(_PATH)change
				}
				
				func check_motion()
				{
					execute store result score @s motion_x run data get entity @s Motion[0] 100
					execute store result score @s motion_z run data get entity @s Motion[2] 100
					execute store success score #GLOBAL temp if score @s motion_x matches 0 if score @s motion_z matches 0
				}
				
				func change()
				{
					execute store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players operation #GLOBAL temp += @s base_model
					scoreboard players operation @s status = #GLOBAL temp
				}
				
				folder color()
				{
					func check()
					{
						execute if score @s freeze_time matches 1.. run function ARG(_PATH)freeze/run
						execute if score @s poison_time matches 1.. at @s run function ARG(_PATH)poison/run
						
						```
						raise Warning("TODO: check all other color change effects")
						```
						# execute unless score @s freeze_time matches 1.. unless score @s poison_time matches 1.. unless score @s burn_time matches 1.. run tag @s remove color_changed
						execute unless score @s freeze_time matches 1.. unless score @s poison_time matches 1.. run tag @s remove color_changed
						execute if entity @s[tag=!color_changed] run data modify entity @s ArmorItems[3].tag.CustomPotionColor set value -1
					}
					
					func other_color_check()
					{
						data modify entity @s[scores={freeze_time=1..}] ArmorItems[3].tag.CustomPotionColor set value 12580095
						data modify entity @s[scores={poison_time=1..}] ArmorItems[3].tag.CustomPotionColor set value 2779438
					}
					
					folder freeze()
					{
						func run()
						{
							scoreboard players remove @s freeze_time 1
							execute if score @s freeze_time matches 0 run function ARG(_PATH)reset
							
						}
						
						func reset()
						{
							scoreboard players reset @s freeze_time
							function ARG(__PATH)other_color_check
						}
					}
					
					folder poison()
					{
						func run()
						{
							scoreboard players remove @s next_poison 1
							scoreboard players remove @s poison_particle 1
							execute if score @s poison_particle matches 0 run function ARG(_PATH)show_particle
							execute if score @s next_poison matches 0 run function ARG(_PATH)next
						}
						
						func show_particle()
						{
							execute positioned ~ ~0.8 ~ run function skill:summon_font_effect/2101005mob
							scoreboard players set @s poison_particle 7
						}
						
						func next()
						{
							scoreboard players remove @s poison_time 1
							scoreboard players set @s next_poison 20
							
							execute if entity @s[tag=!dead] run function ARG(_PATH)damage
							
							execute if score @s poison_time matches 0 run function ARG(_PATH)reset
						}
						
						func damage()
						{
							function skill:mob_effect/play_hurt_sound/run
							
							scoreboard players operation @s hp -= @s poison_damage
							scoreboard players operation @s hp > #1 const
							
							scoreboard players operation @s display_number = @s poison_damage
							scoreboard players set @s display_num_type 0
							execute positioned ~ ~0.4 ~ run function number_display:show
							
							scoreboard players set @s[scores={hp=1}] poison_time 0
						}
						
						func reset()
						{
							scoreboard players reset @s next_poison
							scoreboard players reset @s poison_time
							function ARG(__PATH)other_color_check
						}
					}
				}
			}
			
			folder kb()
			{
				func countdown()
				{
					scoreboard players remove @s kb_time 1
					execute if score @s kb_time matches 0 run function ARG(_PATH)reset
				}
			
				func reset()
				{
					function ARG(__PATH)status_change/run
					data modify entity @s[tag=!dead] ArmorItems[3].tag.AttributeModifiers[{Name:"move_control"}].Amount set value 0.0
					scoreboard players reset @s kb_time
				}
			}
			
			func push_countdown()
			{
				scoreboard players remove @s pushed_time 1
				scoreboard players reset @s[scores={pushed_time=0}] pushed_time
			}
			
			func move_bullets()
			{
				scoreboard players operation #GLOBAL temp = @s number
				execute as @e[type=armor_stand,tag=bullet,scores={life=0..}] if score @s target_id = #GLOBAL temp run function skill:bullet/move
			}
		}
		
		folder action()
		{
			func countdown()
			{
				scoreboard players remove @s action_time 1
				execute if score @s action_time matches 0 run function ARG(_PATH)reset
			}
			
			func reset()
			{
				attribute @s minecraft:generic.movement_speed modifier remove 5b908c48-54cb-4388-aa76-82f61b02032d
				scoreboard players reset @s action_time
			}
		}
	}
	
	folder player()
	{
		func reset_mastery()
		{
			```
			for weapon in mastery_weapons:
				print(f"scoreboard players set @s {weapon}_mastery 10")
			```
		}
	}
	
	folder bullet()
	{
		func setting()
		{
			execute facing entity @s eyes positioned as @s run tp @s ~ ~ ~ ~180 0
			
			scoreboard players operation @s number = #BULLET_ID number
			scoreboard players operation @s target_id = #GLOBAL temp
			execute store result score @s life run data get entity @s ArmorItems[3].tag.appear_delay -1
			execute store result score @s skill_id run data get entity @s ArmorItems[3].tag.skill_id
			tag @s remove new_bullet
		}
		
		func no_target_setting()
		{
			tp @s ~ ~ ~ ~ 0
			execute store result score @s life run data get entity @s ArmorItems[3].tag.appear_delay -1
			execute store result score @s max_life run data get entity @s ArmorItems[3].tag.max_distance
			tag @s remove new_bullet
		}
		
		func check()
		{
			scoreboard players add @s life 1
			execute if score @s life matches 0 run function ARG(_PATH)appear
			# no target bullet
			execute if score @s life matches 0.. unless score @s target_id matches -2147483648.. at @s run function ARG(_PATH)wander
		}
		
		func appear()
		{
			data modify entity @s ArmorItems[3].tag.CustomModelData set from entity @s ArmorItems[3].tag.bullet_model
			data modify entity @s CustomNameVisible set value 1
		}
		
		func wander()
		{
			execute if score @s life > @s max_life run kill @s
			tp @s ^ ^ ^1
		}
		
		func move()
		{
			execute if entity @s[distance=..0.7] run function ARG(_PATH)hit
			execute facing entity @s eyes positioned as @s run tp @s ^ ^ ^-1
		}
		
		func hit()
		{
			execute if entity @s[tag=first_bullet] run function ARG(_PATH)append_scheduler
			execute if entity @s[tag=last_bullet] as @e[type=zombified_piglin,tag=enemy] if score @s number = #GLOBAL temp run scoreboard players remove @s bullet_targeted 1
			kill @s
		}
		
		func append_scheduler()
		{
			scoreboard players operation #BULLET_ID temp = @s number
			data modify storage skill:main new_schedule set value []
			function ARG(_PATH)find_parent_skill/run
		}
		
		folder find_parent_skill()
		{
			```
			def bs_bullet_skill(id_list, start, end):
				if len(id_list) == 1:
					print("func run()")
					print("{")
					print(f"\texecute if score @s skill_id matches {id_list[0][1]} run function skill:{id_list[0][0][0]}/{id_list[0][0][1]}/{id_list[0][0][2]}/{id_list[0][0][3:]}/append_scheduler")
					print(f"\texecute if score @s skill_id matches {id_list[0][1]} as @e[type=zombified_piglin,tag=enemy] if score @s number = #GLOBAL temp run function skill:{id_list[0][0][0]}/{id_list[0][0][1]}/{id_list[0][0][2]}/{id_list[0][0][3:]}/bullet_hit/run")
					print("}")
					return
				
				if start == end:
					return
				
				mid = (start + end) // 2
				mid_right = mid + 1
				
				if start == 0 and end == len(id_list) - 1:
					print("func run()")
				else:
					print(f"func {start}_{end}()")
				print("{")
				if start == mid:
					print(f"\texecute if score @s skill_id matches {id_list[start][1]} run function skill:{id_list[start][0][0]}/{id_list[start][0][1]}/{id_list[start][0][2]}/{id_list[start][0][3:]}/append_scheduler")
					print(f"\texecute if score @s skill_id matches {id_list[start][1]} as @e[type=zombified_piglin,tag=enemy] if score @s number = #GLOBAL temp run function skill:{id_list[start][0][0]}/{id_list[start][0][1]}/{id_list[start][0][2]}/{id_list[start][0][3:]}/bullet_hit/run")
				else:
					print(f"\texecute if score @s skill_id matches {id_list[start][1]}..{id_list[mid][1]} run function ARG(_PATH){start}_{mid}")
				if mid_right == end:
					print(f"\texecute if score @s skill_id matches {id_list[end][1]} run function skill:{id_list[end][0][0]}/{id_list[end][0][1]}/{id_list[end][0][2]}/{id_list[end][0][3:]}/append_scheduler")
					print(f"\texecute if score @s skill_id matches {id_list[end][1]} as @e[type=zombified_piglin,tag=enemy] if score @s number = #GLOBAL temp run function skill:{id_list[end][0][0]}/{id_list[end][0][1]}/{id_list[end][0][2]}/{id_list[end][0][3:]}/bullet_hit/run")
				else:
					print(f"\texecute if score @s skill_id matches {id_list[mid_right][1]}..{id_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
				print("}")
				
				bs_bullet_skill(id_list, start, mid)
				bs_bullet_skill(id_list, mid_right, end)
			
			with open(PROJ_DIR + "/../skill_bullet_ids.csv") as f:
				skill_bullet_ids = f.read().split("\n")
				for i in range(len(skill_bullet_ids)):
					skill_bullet_ids[i] = skill_bullet_ids[i].split(",")
					skill_bullet_ids[i][1] = int(skill_bullet_ids[i][1])
			
			bs_bullet_skill(skill_bullet_ids, 0, len(skill_bullet_ids) - 1)
			```
		}
	}
	
	folder check_skill()
	{
		func run()
		{
			execute store result score #USING_SKILL temp run data get entity @s[nbt={SelectedItem:{id:"minecraft:carrot_on_a_stick"}}] SelectedItem.tag.CustomModelData
			function ARG(_PATH)binary_search/run
			scoreboard players reset @s right_click
		}
		
		folder binary_search()
		{
			```
			def binary_search_skill(skill_list, start, end):
				if len(skill_list) == 1:
					print("func run()")
					print("{")
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[0][1]} run function skill:{skill_list[0][0][0]}/{skill_list[0][0][1]}/{skill_list[0][0][2]}/{skill_list[0][0][3:]}/check")
					print("}")
					return
				
				if start == end:
					return
				
				mid = (start + end) // 2
				mid_right = mid + 1
				
				if start == 0 and end == len(skill_list) - 1:
					print("func run()")
				else:
					print(f"func {start}_{end}()")
				print("{")
				if start == mid:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[start][1]} run function skill:{skill_list[start][0][0]}/{skill_list[start][0][1]}/{skill_list[start][0][2]}/{skill_list[start][0][3:]}/check")
				else:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[start][1]}..{skill_list[mid][1]} run function ARG(_PATH){start}_{mid}")
				if mid_right == end:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[end][1]} run function skill:{skill_list[end][0][0]}/{skill_list[end][0][1]}/{skill_list[end][0][2]}/{skill_list[end][0][3:]}/check")
				else:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[mid_right][1]}..{skill_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
				print("}")
				
				binary_search_skill(skill_list, start, mid)
				binary_search_skill(skill_list, mid_right, end)
			
			with open(PROJ_DIR + "/../skill_icons.csv") as f:
				skill_models = f.read().split("\n")
				for i in range(len(skill_models)):
					skill_models[i] = skill_models[i].split(",")
					skill_models[i][1] = int(skill_models[i][1])
			
			binary_search_skill(skill_models, 0, len(skill_models) - 1)
			```
		}
	}
	
	folder check_weapon()
	{
		func check_empty()
		{
			scoreboard players set #ACCEPTED_WEAPON temp 0
			
			execute store result score #USED_WEAPON temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_type
			execute if score #USED_WEAPON temp matches 0 run tellraw @s {"translate":"warning.skill.no_weapon","color":"red"}
		}
		
		folder single_hand()
		{
			func run()
			{
				function ARG(__PATH)check_empty
				execute if score #USED_WEAPON temp matches 1.. run function ARG(_PATH)check
			}
			
			func check()
			{
				scoreboard players operation #ACCEPTED_WEAPON temp = #USED_WEAPON temp
				scoreboard players operation #ACCEPTED_WEAPON temp %= #2 const
				execute if score #ACCEPTED_WEAPON temp matches 0 run tellraw @s {"translate":"warning.skill.wrong_weapon","color":"red"}
			}
		}
		
		```
		def check_weapon_range(range_string):
			print(f'''
			func run()
			{{
				function ARG(__PATH)check_empty
				execute if score #USED_WEAPON temp matches 1.. run function ARG(_PATH)check
			}}
			
			func check()
			{{
				execute store success score #ACCEPTED_WEAPON temp if score #USED_WEAPON temp matches {range_string}
				execute if score #ACCEPTED_WEAPON temp matches 0 run tellraw @s {{"translate":"warning.skill.wrong_weapon","color":"red"}}
			}}''')
		```
		
		folder dagger()
		{
			```
			check_weapon_range("23")
			```
		}
		
		folder claw()
		{
			```
			check_weapon_range("24")
			```
		}
	}

	folder enemy_search()
	{
		folder search_front() from for_loop().for("#DISTANCE temp", "if score #FOUND_ENEMY temp < #MAX_ENEMY temp positioned ^ ^ ^0.5")
		{
			func search()
			{
				scoreboard players set #FOUND_ENEMY temp 0
				execute at @s rotated ~ 0 positioned ^ ^ ^0.5 run function ARG(_PATH)run
			}
			
			func execute()
			{
				execute as @e[type=minecraft:zombified_piglin,tag=enemy,tag=!dead,distance=..2] run function ARG(_PATH)pre_mark
				execute if score #FOUND_ENEMY temp >= #MAX_ENEMY temp run function ARG(_PATH)order_mark
			}
			
			func pre_mark()
			{
				scoreboard players add #FOUND_ENEMY temp 1
				tag @s add temp_mark
			}
			
			func order_mark()
			{
				scoreboard players set #FOUND_ENEMY temp 0
				execute at @s as @e[type=zombified_piglin,tag=temp_mark,sort=nearest] run function ARG(_PATH)try_mark
				tag @e[type=zombified_piglin,tag=temp_mark] remove temp_mark
			}
			
			func try_mark()
			{
				execute if score #FOUND_ENEMY temp < #MAX_ENEMY temp run tag @s add target
				scoreboard players add #FOUND_ENEMY temp 1
			}
		}
	}
	
	folder damage_formula()
	{
		func spell()
		{
			# magic attack
			execute store result score #MAGIC_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.magic_attack
			scoreboard players operation #MAGIC_ATTACK temp += @s INT
			scoreboard players operation #INT temp = @s INT
			scoreboard players operation #INT temp *= #5 const
			
			scoreboard players operation #MAX_DAMAGE temp = #MAGIC_ATTACK temp
			scoreboard players operation #MAX_DAMAGE temp *= #MAGIC_ATTACK temp
			scoreboard players operation #MAGIC_ATTACK temp *= #1000 const
			scoreboard players operation #MAX_DAMAGE temp += #MAGIC_ATTACK temp
			
			scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
			scoreboard players operation #MIN_DAMAGE temp *= #9 const
			scoreboard players operation #MIN_DAMAGE temp *= #SKILL_MASTERY temp
			scoreboard players operation #MIN_DAMAGE temp /= #1000 const
			
			scoreboard players operation #MAX_DAMAGE temp /= #30 const
			scoreboard players operation #MAX_DAMAGE temp += #INT temp
			scoreboard players operation #MAX_DAMAGE temp *= #SPELL_ATTACK temp
			scoreboard players operation #MAX_DAMAGE temp /= #1000 const
			
			scoreboard players operation #MIN_DAMAGE temp /= #30 const
			scoreboard players operation #MIN_DAMAGE temp += #INT temp
			scoreboard players operation #MIN_DAMAGE temp *= #SPELL_ATTACK temp
			scoreboard players operation #MIN_DAMAGE temp /= #1000 const
			
			# accuracy
			scoreboard players operation #INT temp /= #50 const
			scoreboard players operation #ACCURACY temp = @s LUK
			scoreboard players operation #ACCURACY temp /= #10 const
			scoreboard players operation #ACCURACY temp += #INT temp
			
			# write values
			execute store result storage skill:main damage[0].max_damage int 1 run scoreboard players get #MAX_DAMAGE temp
			execute store result storage skill:main damage[0].min_damage int 1 run scoreboard players get #MIN_DAMAGE temp
			execute store result storage skill:main damage[0].accuracy int 1 run scoreboard players get #ACCURACY temp
			execute store result storage skill:main damage[0].player_level int 1 run scoreboard players get @s level
			execute store result storage skill:main damage[0].crit_rate int 1 run scoreboard players get @s addi_crit_rate
			execute store result storage skill:main damage[0].crit_damage int 1 run scoreboard players get @s addi_crit_damage
		}
		
		folder accuracy()
		{
			func job_check()
			{
				execute if entity @s[tag=!archer,tag=!thief,tag=!pirate] run function ARG(_PATH)war_mag_beg
				execute if entity @s[tag=brawler] run function ARG(_PATH)brawler
				execute unless entity @s[tag=!archer,tag=!thief,tag=!pirate] if entity @s[tag=!brawler] run function ARG(_PATH)bow_thief_pirate
			}
			
			# warrior / magician / beginner
			func war_mag_beg()
			{
				scoreboard players operation #LUK temp = @s LUK
				scoreboard players operation #LUK temp *= #5 const
				scoreboard players operation #ACCURACY temp = @s DEX
				scoreboard players operation #ACCURACY temp *= #8 const
				scoreboard players operation #ACCURACY temp += #LUK temp
				scoreboard players operation #ACCURACY temp /= #10 const
				
				scoreboard players operation #ACCURACY temp += @s base_accuracy
			}
			
			# one punch
			func brawler()
			{
				scoreboard players operation #LUK temp = @s LUK
				scoreboard players operation #LUK temp *= #5 const
				scoreboard players operation #ACCURACY temp = @s DEX
				scoreboard players operation #ACCURACY temp *= #9 const
				scoreboard players operation #ACCURACY temp += #LUK temp
				scoreboard players operation #ACCURACY temp /= #10 const
				
				scoreboard players operation #ACCURACY temp += @s base_accuracy
			}
			
			# include gunslingers
			func bow_thief_pirate()
			{
				scoreboard players operation #LUK temp = @s LUK
				scoreboard players operation #LUK temp *= #3 const
				scoreboard players operation #ACCURACY temp = @s DEX
				scoreboard players operation #ACCURACY temp *= #6 const
				scoreboard players operation #ACCURACY temp += #LUK temp
				scoreboard players operation #ACCURACY temp /= #10 const
				
				scoreboard players operation #ACCURACY temp += @s base_accuracy
			}
		}
		
		func addi_crit()
		{
			scoreboard players operation #CRIT_RATE temp += @s addi_crit_rate
			scoreboard players operation #CRIT_DAMAGE temp += @s addi_crit_damage
			scoreboard players add #CRIT_DAMAGE temp 100
		}
		
		func write_values()
		{
			execute store result storage skill:main damage[0].max_damage int 1 run scoreboard players get #MAX_DAMAGE temp
			execute store result storage skill:main damage[0].min_damage int 1 run scoreboard players get #MIN_DAMAGE temp
			execute store result storage skill:main damage[0].accuracy int 1 run scoreboard players get #ACCURACY temp
			execute store result storage skill:main damage[0].player_level int 1 run scoreboard players get @s level
			execute store result storage skill:main damage[0].crit_rate int 1 run scoreboard players get #CRIT_RATE temp
			execute store result storage skill:main damage[0].crit_damage int 1 run scoreboard players get #CRIT_DAMAGE temp
		}
		
		folder claw()
		{
			func normal()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += #BULLET_DAMAGE temp
				
				scoreboard players operation #MAX_DAMAGE temp = @s LUK
				scoreboard players operation #MAX_DAMAGE temp *= #36 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s claw_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				function ARG(_PATH)other_formula
			}
			
			func lucky_seven()
			{
				# weapon attack
				execute store result score #MAX_DAMAGE temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				scoreboard players operation #MAX_DAMAGE temp += #BULLET_DAMAGE temp
				scoreboard players operation #MAX_DAMAGE temp *= @s LUK
				scoreboard players operation #MAX_DAMAGE temp /= #20 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp /= #2 const
				
				function ARG(_PATH)other_formula
			}
			
			func punch()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				scoreboard players operation #MAX_DAMAGE temp = @s LUK
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp /= #10 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #150 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #150 const
				
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s claw_accuracy
				
				# reset crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				
				function ARG(__PATH)write_values
			}
			
			func other_formula()
			{
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s claw_accuracy
				
				# crit
				scoreboard players operation #CRIT_RATE temp = @s crit_rate
				scoreboard players operation #CRIT_DAMAGE temp = @s crit_damage
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder dagger()
		{
			func thief()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				
				scoreboard players operation #MAX_DAMAGE temp = @s LUK
				scoreboard players operation #MAX_DAMAGE temp *= #36 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s dagger_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s dagger_accuracy
				
				function ARG(_PATH)other_formula
			}
			
			func non_thief()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #4 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				execute if entity @s[tag=!archer,tag=!pirate] run function ARG(__PATH)accuracy/war_mag_beg
				execute if entity @s[tag=brawler] run function ARG(__PATH)accuracy/brawler
				execute unless entity @s[tag=!archer,tag=!pirate] if entity @s[tag=!brawler] run function ARG(__PATH)accuracy/bow_thief_pirate
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder bow()
		{
			func normal()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += #BULLET_DAMAGE temp
				
				scoreboard players operation #MAX_DAMAGE temp = @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #34 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s bow_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# crit
				scoreboard players operation #CRIT_RATE temp = @s crit_rate
				scoreboard players operation #CRIT_DAMAGE temp = @s crit_damage
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(_PATH)other_formula
			}
			
			func power_knock_back()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				
				scoreboard players operation #MAX_DAMAGE temp = @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #34 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #150 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #150 const
				
				# reset crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s bow_accuracy
				
				function ARG(__PATH)write_values
			}
		}
		
		folder crossbow()
		{
			func normal()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += #BULLET_DAMAGE temp
				
				scoreboard players operation #MAX_DAMAGE temp = @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #36 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s crossbow_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# crit
				scoreboard players operation #CRIT_RATE temp = @s crit_rate
				scoreboard players operation #CRIT_DAMAGE temp = @s crit_damage
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(_PATH)other_formula
			}
			
			func power_knock_back()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				
				scoreboard players operation #MAX_DAMAGE temp = @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #34 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #150 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #150 const
				
				# reset crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s crossbow_accuracy
				
				function ARG(__PATH)write_values
			}
		}
		
		folder spear()
		{
			func stab()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #5 const
				
				function ARG(_PATH)other_formula
			}
			
			func swing()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #3 const
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s spear_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s spear_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder polearm()
		{
			func swing()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #5 const
				
				function ARG(_PATH)other_formula
			}
			
			func stab()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #3 const
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s polearm_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s polearm_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder sword()
		{
			func one_hand()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #4 const
				
				function ARG(_PATH)other_formula
			}
			
			func two_hand()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #46 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s sword_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s sword_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder axe()
		{
			folder one_hand()
			{
				func swing()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #44 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
				
				func stab()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #32 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
			}
			
			folder two_hand()
			{
				func swing()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #48 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
				
				func stab()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #34 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
			}
			
			func other_formula()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s axe_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s axe_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder blunt()
		{
			folder one_hand()
			{
				func swing()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #44 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
				
				func stab()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #32 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
			}
			
			folder two_hand()
			{
				func swing()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #48 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
				
				func stab()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #34 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
			}
			
			func other_formula()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s blunt_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s blunt_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		# wand formula == staff formula
		folder staff()
		{
			func swing()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #44 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				function ARG(_PATH)other_formula
			}
			
			func stab()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #32 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# weapon attack
				execute store result score #WEAPON_ATTACK temp run data get entity @s Inventory[{Slot:-106b}].tag.weapon_attack
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
	}

	folder calculate_damage()
	{
		func run()
		{
			data modify entity @s ArmorItems[3].tag.damage_record set value []
			# copy damage list
			data modify storage skill:main damage_copy set from storage skill:main damage
			scoreboard players set #SAME_DAMAGE temp 0
			scoreboard players set #NUMBER_HEIGHT temp 0
			scoreboard players set #DID_HIT temp 0
			function ARG(_PATH)traverse_damages/run
			
			execute if score @s hp matches ..0 run function ARG(_PATH)record_dead
		}
		
		func record_dead()
		{
			data merge entity @s {Attributes:[{Name:"generic.attack_damage",Base:0.0},{Name:"generic.movement_speed",Base:0.0}]}
			loot spawn ~ ~ ~ kill @s
			```
			raise Warning("TODO: give exp to killer player")
			```
			tag @s add dead
		}
		
		folder traverse_damages() from while_loop("if data storage skill:main damage_copy[0]")
		{
			func execute()
			{
				execute unless score #SAME_DAMAGE temp matches 1 run function ARG(_PATH)record_value
				data remove storage skill:main damage_copy[0]
				
				data modify entity @s ArmorItems[3].tag.damage_record append value {number:0,crit:0}
				execute store result entity @s ArmorItems[3].tag.damage_record[-1].height int 1 run scoreboard players add #NUMBER_HEIGHT temp 1
				
				function main:rand_rate
				execute if score #HIT_RATE temp > #RAND_RESULT temp run function ARG(_PATH)deal_damage
			}
			
			func record_value()
			{
				execute store result score #MIN_DAMAGE temp run data get storage skill:main damage_copy[0].min_damage
				execute store result score #MAX_DAMAGE temp run data get storage skill:main damage_copy[0].max_damage
				execute store result score #BASE_PERCENT temp run data get storage skill:main damage_copy[0].base_percent
				execute store result score #CRIT_RATE temp run data get storage skill:main damage_copy[0].crit_rate
				execute store result score #CRIT_DAMAGE temp run data get storage skill:main damage_copy[0].crit_damage
				scoreboard players operation #CRIT_DAMAGE temp += #BASE_PERCENT temp
				execute store result score #LEVEL_DIFFERENCE temp run data get storage skill:main damage_copy[0].player_level -1
				scoreboard players operation #LEVEL_DIFFERENCE temp += @s level
				scoreboard players operation #LEVEL_DIFFERENCE temp > #0 const
				# ATTRIBUTE 0 = weapon attack; 1 = magic attack; 2 = fire; 3 = poison; 4 = ice; 5 = lightning; 6 = holy
				execute store result score #ATTRIBUTE temp run data get storage skill:main damage_copy[0].attribute
				execute if score #ATTRIBUTE temp matches 2.. run function ARG(_PATH)attribute_multiply/run
				# Calculate defense and hit rate
				execute if score #ATTRIBUTE temp matches 0 run function ARG(_PATH)weapon_formula
				execute if score #ATTRIBUTE temp matches 1.. run function ARG(_PATH)magic_formula
				
				execute store success score #SAME_DAMAGE temp run data modify storage skill:main damage_copy[0] set from storage skill:main damage_copy[1]
			}
			
			func weapon_formula()
			{
				# defense
				scoreboard players operation #DEFENSE temp = @s weapon_defense
				scoreboard players operation #DEFENSE temp /= #2 const
				
				scoreboard players set #LEVEL_PUNISH temp 100
				scoreboard players operation #LEVEL_PUNISH temp -= #LEVEL_DIFFERENCE temp
				scoreboard players operation #MAX_DAMAGE temp *= #LEVEL_PUNISH temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				scoreboard players operation #MAX_DAMAGE temp -= #DEFENSE temp
				
				scoreboard players operation #MIN_DAMAGE temp *= #LEVEL_PUNISH temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				scoreboard players operation #DEFENSE temp *= #6 const
				scoreboard players operation #DEFENSE temp /= #5 const
				scoreboard players operation #MIN_DAMAGE temp -= #DEFENSE temp
				
				# hit rate
				execute store result score #HIT_RATE temp run data get storage skill:main damage_copy[0].accuracy 100000
				scoreboard players operation #LEVEL_DIFFERENCE temp *= #66 const
				scoreboard players add #LEVEL_DIFFERENCE temp 1835
				scoreboard players operation #LEVEL_DIFFERENCE temp *= @s avoidability
				scoreboard players operation #HIT_RATE temp /= #LEVEL_DIFFERENCE temp
				scoreboard players remove #HIT_RATE temp 100
			}
			
			func magic_formula()
			{
				# defense
				scoreboard players operation #DEFENSE temp = @s magic_defense
				scoreboard players operation #DEFENSE temp /= #2 const
				
				scoreboard players set #LEVEL_PUNISH temp 100
				scoreboard players operation #LEVEL_PUNISH temp += #LEVEL_DIFFERENCE temp
				scoreboard players operation #DEFENSE temp *= #LEVEL_PUNISH temp
				scoreboard players operation #DEFENSE temp /= #100 const
				scoreboard players operation #MAX_DAMAGE temp -= #DEFENSE temp
				
				scoreboard players operation #DEFENSE temp *= #6 const
				scoreboard players operation #DEFENSE temp /= #5 const
				scoreboard players operation #MIN_DAMAGE temp -= #DEFENSE temp
				
				# hit rate
				scoreboard players operation #LEVEL_DIFFERENCE temp *= #4 const
				scoreboard players add #LEVEL_DIFFERENCE temp 100
				scoreboard players operation #MAX_ACCURACY temp = @s avoidability
				scoreboard players add #MAX_ACCURACY temp 1
				scoreboard players operation #MAX_ACCURACY temp *= #LEVEL_DIFFERENCE temp
				scoreboard players operation #MAX_ACCURACY temp /= #100 const
				
				scoreboard players operation #MIN_ACCURACY temp = #MAX_ACCURACY temp
				scoreboard players operation #MIN_ACCURACY temp *= #41 const
				scoreboard players operation #MIN_ACCURACY temp /= #100 const
				
				execute store result score #ACCURACY temp run data get storage skill:main damage_copy[0].accuracy
				scoreboard players set #HIT_RATE temp 0
				execute if score #ACCURACY temp >= #MAX_ACCURACY temp run scoreboard players set #HIT_RATE temp 100
				execute if score #ACCURACY temp < #MAX_ACCURACY temp if score #ACCURACY temp >= #MIN_ACCURACY temp run function ARG(_PATH)magic_hit_rate
			}
			
			func magic_hit_rate()
			{
				scoreboard players operation #ACCURACY temp -= #MIN_ACCURACY temp
				scoreboard players add #ACCURACY temp 1
				scoreboard players operation #ACCURACY temp *= #100 const
				
				scoreboard players operation #MAX_ACCURACY temp -= #MIN_ACCURACY temp
				scoreboard players add #MAX_ACCURACY temp 1
				
				execute store result score #HIT_RATE temp run scoreboard players operation #ACCURACY temp /= #MAX_ACCURACY temp
				scoreboard players operation #HIT_RATE temp *= #HIT_RATE temp
				scoreboard players operation #HIT_RATE temp *= #-7 const
				scoreboard players operation #HIT_RATE temp /= #1000 const
				
				scoreboard players operation #ACCURACY temp *= #17 const
				scoreboard players operation #ACCURACY temp /= #10 const
				
				scoreboard players operation #HIT_RATE temp += #ACCURACY temp
			}
			
			func deal_damage()
			{
				scoreboard players operation #MAX_DAMAGE_FINAL temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE_FINAL temp = #MIN_DAMAGE temp
				
				execute if score #CRIT_RATE temp matches 1.. run function main:rand_rate
				execute if score #CRIT_RATE temp > #RAND_RESULT temp run function ARG(_PATH)crit_multiply
				execute unless score #CRIT_RATE temp > #RAND_RESULT temp run function ARG(_PATH)skill_multiply
				
				scoreboard players set @s display_number 0
				execute unless score #MAX_DAMAGE_FINAL temp = #MIN_DAMAGE_FINAL temp run function ARG(_PATH)rand_damage
				scoreboard players add @s display_number 1
				scoreboard players operation @s display_number < #99999 const
				scoreboard players operation @s display_number > #1 const
				
				scoreboard players operation @s hp -= @s display_number
				execute store result entity @s ArmorItems[3].tag.damage_record[-1].number int 1 run scoreboard players get @s display_number
				
				scoreboard players set #DID_HIT temp 1
			}
			
			folder attribute_multiply()
			{
				func run()
				{
					execute if score #ATTRIBUTE temp matches 2 run function ARG(_PATH)fire
					execute if score #ATTRIBUTE temp matches 3 run function ARG(_PATH)poison
					execute if score #ATTRIBUTE temp matches 4 run function ARG(_PATH)ice
					execute if score #ATTRIBUTE temp matches 5 run function ARG(_PATH)lightning
					execute if score #ATTRIBUTE temp matches 6 run function ARG(_PATH)holy
				}
				
				func fire()
				{
					execute if entity @s[tag=fire_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=fire_weakness] run function ARG(_PATH)weakness
				}
				
				func poison()
				{
					execute if entity @s[tag=poison_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=poison_weakness] run function ARG(_PATH)weakness
				}
				
				func ice()
				{
					execute if entity @s[tag=ice_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=ice_weakness] run function ARG(_PATH)weakness
				}
				
				func lightning()
				{
					execute if entity @s[tag=lightning_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=lightning_weakness] run function ARG(_PATH)weakness
				}
				
				func holy()
				{
					execute if entity @s[tag=holy_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=holy_weakness] run function ARG(_PATH)weakness
				}
	
				func resist()
				{
					scoreboard players operation #MIN_DAMAGE temp *= #50 const
					scoreboard players operation #MAX_DAMAGE temp *= #50 const
					function ARG(_PATH)divide_back
				}
				
				func weakness()
				{
					scoreboard players operation #MIN_DAMAGE temp *= #150 const
					scoreboard players operation #MAX_DAMAGE temp *= #150 const
					function ARG(_PATH)divide_back
				}
				
				func divide_back()
				{
					scoreboard players operation #MIN_DAMAGE temp /= #100 const
					scoreboard players operation #MAX_DAMAGE temp /= #100 const
				}
			}
			
			func crit_multiply()
			{
				scoreboard players operation #MAX_DAMAGE_FINAL temp *= #CRIT_DAMAGE temp
				scoreboard players operation #MAX_DAMAGE_FINAL temp /= #100 const
				scoreboard players operation #MIN_DAMAGE_FINAL temp *= #CRIT_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE_FINAL temp /= #100 const
				data modify entity @s ArmorItems[3].tag.damage_record[-1].crit set value 1
			}
			
			func skill_multiply()
			{
				scoreboard players operation #MAX_DAMAGE_FINAL temp *= #BASE_PERCENT temp
				scoreboard players operation #MAX_DAMAGE_FINAL temp /= #100 const
				scoreboard players operation #MIN_DAMAGE_FINAL temp *= #BASE_PERCENT temp
				scoreboard players operation #MIN_DAMAGE_FINAL temp /= #100 const
			}
			
			func rand_damage() from random().generate("#MIN_DAMAGE_FINAL temp", "#MAX_DAMAGE_FINAL temp", "@s display_number");
		}
	}
	
	folder mob_effect()
	{
		folder debuff()
		{
			func freeze()
			{
				tag @s add color_changed
				execute store result score @s kb_time run scoreboard players operation @s freeze_time = #FREEZE_TIME temp
				scoreboard players add @s kb_time 12
				
				data modify entity @s ArmorItems[3].tag.CustomPotionColor set value 12580095
				
				execute store result score #GLOBAL temp run scoreboard players set @s status 2
				execute store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players operation #GLOBAL temp += @s base_model
				
				data modify entity @s ArmorItems[3].tag.AttributeModifiers[{Name:"move_control"}].Amount set value -1.0
			}
			
			func poison()
			{
				tag @s add color_changed
				scoreboard players operation @s poison_time = #POISON_TIME temp
				scoreboard players operation @s poison_damage = @s hp_max
				scoreboard players operation @s poison_damage /= #POISON_HP_RATE temp
				
				execute unless score @s next_poison matches 1.. run scoreboard players set @s poison_particle 7
				execute unless score @s next_poison matches 1.. run scoreboard players set @s next_poison 20
				
				data modify entity @s ArmorItems[3].tag.CustomPotionColor set value 2779438
			}
		}
		
		func dead()
		{
			scoreboard players operation #GLOBAL temp = @s number
			execute as @e[type=armor_stand,tag=bullet] if score @s target_id = #GLOBAL temp run kill @s
			
			function ARG(_PATH)play_die_sound/run
			kill @s
		}
		
		folder play_hurt_sound()
		{
			```
			def bs_hurt_sound(sound_list, start, end):
				if len(sound_list) == 1:
					print("func run()")
					print("{")
					print(f"\texecute if score @s hurt_sound matches {sound_list[0][1]} run playsound minecraft:mob.hurt.{sound_list[0][0]} hostile @a ~ ~ ~ 1 1 0")
					print("}")
					return
				
				if start == end:
					return
				
				mid = (start + end) // 2
				mid_right = mid + 1
				
				if start == 0 and end == len(sound_list) - 1:
					print("func run()")
				else:
					print(f"func {start}_{end}()")
				print("{")
				if start == mid:
					print(f"\texecute if score @s hurt_sound matches {sound_list[start][1]} run playsound minecraft:mob.hurt.{sound_list[start][0]} hostile @a ~ ~ ~ 1 1 0")
				else:
					print(f"\texecute if score @s hurt_sound matches {sound_list[start][1]}..{sound_list[mid][1]} run function ARG(_PATH){start}_{mid}")
				if mid_right == end:
					print(f"\texecute if score @s hurt_sound matches {sound_list[end][1]} run playsound minecraft:mob.hurt.{sound_list[end][0]} hostile @a ~ ~ ~ 1 1 0")
				else:
					print(f"\texecute if score @s hurt_sound matches {sound_list[mid_right][1]}..{sound_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
				print("}")
				
				bs_hurt_sound(sound_list, start, mid)
				bs_hurt_sound(sound_list, mid_right, end)
			
			with open(PROJ_DIR + "/../hurt_sounds.csv") as f:
				hurt_sounds = f.read().split("\n")
				for i in range(len(hurt_sounds)):
					hurt_sounds[i] = hurt_sounds[i].split(",")
					hurt_sounds[i][1] = int(hurt_sounds[i][1])
			
			bs_hurt_sound(hurt_sounds, 0, len(hurt_sounds) - 1)
			```
		}
		
		folder play_die_sound()
		{
			```
			def bs_die_sound(sound_list, start, end):
				if len(sound_list) == 1:
					print("func run()")
					print("{")
					print(f"\texecute if score @s die_sound matches {sound_list[0][1]} run playsound minecraft:mob.die.{sound_list[0][0]} hostile @a ~ ~ ~ 1 1 0")
					print("}")
					return
				
				if start == end:
					return
				
				mid = (start + end) // 2
				mid_right = mid + 1
				
				if start == 0 and end == len(sound_list) - 1:
					print("func run()")
				else:
					print(f"func {start}_{end}()")
				print("{")
				if start == mid:
					print(f"\texecute if score @s die_sound matches {sound_list[start][1]} run playsound minecraft:mob.die.{sound_list[start][0]} hostile @a ~ ~ ~ 1 1 0")
				else:
					print(f"\texecute if score @s die_sound matches {sound_list[start][1]}..{sound_list[mid][1]} run function ARG(_PATH){start}_{mid}")
				if mid_right == end:
					print(f"\texecute if score @s die_sound matches {sound_list[end][1]} run playsound minecraft:mob.die.{sound_list[end][0]} hostile @a ~ ~ ~ 1 1 0")
				else:
					print(f"\texecute if score @s die_sound matches {sound_list[mid_right][1]}..{sound_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
				print("}")
				
				bs_die_sound(sound_list, start, mid)
				bs_die_sound(sound_list, mid_right, end)
			
			with open(PROJ_DIR + "/../die_sounds.csv") as f:
				die_sounds = f.read().split("\n")
				for i in range(len(die_sounds)):
					die_sounds[i] = die_sounds[i].split(",")
					die_sounds[i][1] = int(die_sounds[i][1])
			
			bs_die_sound(die_sounds, 0, len(die_sounds) - 1)
			```
		}
	}
		
	folder summon_font_effect()
	{
		```
		font_root_path = os.path.dirname(os.path.abspath(PROJ_DIR)) + "/MapleCraft resource pack/assets/skill/font"
		for root, dirs, files in os.walk(font_root_path):
			for name in files:
				if name == "summon.txt":
					func_name = ""
					recursive_path = root
					for i in range(3):
						func_name = os.path.basename(recursive_path) + func_name
						recursive_path = os.path.dirname(recursive_path)
						
					print(f"func {func_name}()")
					print("{")
					with open(os.path.join(root, name), "r") as f:
						print(f.read())
					print("}")
					
					break
		```
	}
	
	folder afterimage()
	{
		folder claw()
		{
			func swing()
			{
				scoreboard players set #RANGE_MAX temp 3
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000000
				function ARG(__PATH)summon_model
			}
		}
		
		folder dagger()
		{
			func swing()
			{
				scoreboard players set #RANGE_MAX temp 3
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000003
				function ARG(__PATH)summon_model
			}
			
			func stab()
			{
				scoreboard players set #RAND_RANGE_RESULT temp 1000006
				function ARG(__PATH)summon_model
			}
		}
		
		func summon_model()
		{
			execute rotated ~ 0 run summon minecraft:armor_stand ^ ^ ^0.7 {Tags:["afterimage","new"],Invisible:1,Invulnerable:1,NoGravity:1,Marker:1,Fire:32767s,ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1b,tag:{CustomModelData:1}}]}
			execute as @e[type=armor_stand,tag=new] run function ARG(_PATH)model_set
		}
		
		func model_set()
		{
			execute positioned as @s run tp @s ~ ~ ~ ~ ~
			scoreboard players set @s life 8
			scoreboard players operation @s base_model = #RAND_RANGE_RESULT temp
			tag @s remove new
		}

		func update()
		{
			scoreboard players remove @s life 1
			execute if score @s life matches 0 store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players get @s base_model
			kill @s[scores={life=-4}]
		}
	}
	
	func show_num_at_height()
	{
		scoreboard players remove #NUMBER_HEIGHT temp 1
		execute if score #NUMBER_HEIGHT temp matches -1 run function number_display:show
		execute if score #NUMBER_HEIGHT temp matches 0.. positioned ~ ~0.4 ~ run function ARG(_PATH)show_num_at_height
	}
	
	
	
	func test_mob()
	{
		execute rotated ~ 0 positioned ^ ^ ^5 align y run summon zombified_piglin ~ ~ ~ {Tags:["new","enemy","holy_weakness"],ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1b,tag:{CustomModelData:10000,CustomPotionColor:-1,Unbreakable:1,AttributeModifiers:[{Name:"move_control",AttributeName:"generic.movement_speed",Amount:0.0,Operation:0,UUID:[I;0,1,0,1]}]}}],ArmorDropChances:[0.0,0.0,0.0,0.0],Silent:1,PersistenceRequired:1,Attributes:[{Name:"generic.attack_damage",Base:9.5}],OnGround:1b,Team:"enemy"}
		execute rotated ~ 0 positioned ^ ^ ^5 align y run summon zombified_piglin ~ ~ ~ {Tags:["new","enemy","holy_weakness"],ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1b,tag:{CustomModelData:10000,CustomPotionColor:-1,Unbreakable:1,AttributeModifiers:[{Name:"move_control",AttributeName:"generic.movement_speed",Amount:0.0,Operation:0,UUID:[I;0,1,0,1]}]}}],ArmorDropChances:[0.0,0.0,0.0,0.0],Silent:1,PersistenceRequired:1,Attributes:[{Name:"generic.attack_damage",Base:9.5}],OnGround:1b,Team:"enemy"}
		execute rotated ~ 0 positioned ^ ^ ^5 align y run summon zombified_piglin ~ ~ ~ {Tags:["new","enemy","holy_weakness"],ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1b,tag:{CustomModelData:10000,CustomPotionColor:-1,Unbreakable:1,AttributeModifiers:[{Name:"move_control",AttributeName:"generic.movement_speed",Amount:0.0,Operation:0,UUID:[I;0,1,0,1]}]}}],ArmorDropChances:[0.0,0.0,0.0,0.0],Silent:1,PersistenceRequired:1,Attributes:[{Name:"generic.attack_damage",Base:9.5}],OnGround:1b,Team:"enemy"}
		
		scoreboard players set @e[type=zombified_piglin,tag=new] level 24
		scoreboard players set @e[type=zombified_piglin,tag=new] hp_max 500
		scoreboard players set @e[type=zombified_piglin,tag=new] hp 500
		scoreboard players set @e[type=zombified_piglin,tag=new] avoidability 8
		scoreboard players set @e[type=zombified_piglin,tag=new] weapon_defense 20
		scoreboard players set @e[type=zombified_piglin,tag=new] magic_defense 30
		scoreboard players set @e[type=zombified_piglin,tag=new] kb 1
		scoreboard players set @e[type=zombified_piglin,tag=new] hurt_sound 1
		scoreboard players set @e[type=zombified_piglin,tag=new] die_sound 2
		scoreboard players set @e[type=zombified_piglin,tag=new] base_model 10000
		scoreboard players set @e[type=zombified_piglin,tag=new] status 0
		
		execute as @e[type=zombified_piglin,tag=new] store result score @s number run scoreboard players add #MOB_ID number 1
		tag @e[type=zombified_piglin,tag=new] remove new
	}
}