import loop
import ../utils
import ../mob

```
skill_ids = []
mastery_colors = [2228479, 5570815, 7799039, 11141375, 14483711, 16711901, 16711799, 16711714, 16711680]

mastery_weapons = ["claw", "dagger", "bow", "cbow", "spear", "polearm", "sword", "axe", "blunt"]

def append_scheduler(delay_range, base_delay, skill_path):
	print("func append_scheduler()")
	print("{")
	print("		execute store result score #GLOBAL hit_distance run data get storage skill:main temp[0]")
	print("		function ARG(_PATH)schedulers/delay0/check")
	print("}")
	
	print("folder schedulers()")
	print("{")
	for i in range(delay_range):
		print(f"folder delay{i}()")
		print("	{")
		print("		func check()")
		print("		{")
		print(f"		execute if score #GLOBAL hit_distance matches {i} run function ARG(_PATH)run")
		if i < delay_range - 1:
			print(f"	execute if score #GLOBAL hit_distance matches {i+1}.. run function ARG(__PATH)delay{i+1}/check")
		print("		}")
		
		print("		func run()")
		print("		{")
		print(f"		data modify storage skill:main new_schedule append value {{delay:{i},time:0}}")
		print(f"		execute store result storage skill:main new_schedule[-1].time int 1 run schedule function {skill_path}hit_effect {base_delay+i}t append")
		if i < delay_range - 1:
			print("		data remove storage skill:main temp[0]")
			print("		execute store result score #GLOBAL hit_distance run data get storage skill:main temp[0]")
			
		print("		}")
		print("	}")
	print("}")
```

namespace attack_skill_template(skill_id) as virtual
{
	# functions to override:
	#	check => check whether to use the skill or not
	#	cast_effect => visual and audio effects on casting skill
	#	mark_target => tag all target
	#	set_numeric => calculate all numbers related to damage and write to global storage
	#	add_debuff => set all debuff numbers as the hit mob
	#	effect => visual and audio effects with display_number as damage
	#	append_scheduler => see "append_scheduler_sample"
	
	```
	skill_ids.append("ARG(skill_id)")
	```
	
	func run()
	{
		```
		# reset final attack
		if "ARG(skill_id)" != "1000006":
			print("scoreboard players reset @s f_attack_skill")
		```
		function skill:use_constraint
		```
		if "ARG(skill_id)" == "6001001":
			print("execute if score #NO_AFTERIMAGE temp matches 0 run data modify storage skill:main damage set value [{min_damage:0,max_damage:0,accuracy:0,player_level:0,crit_rate:0,crit_damage:0,base_percent:100,attribute:0}]")
		else:
			print("data modify storage skill:main damage set value [{min_damage:0,max_damage:0,accuracy:0,player_level:0,crit_rate:0,crit_damage:0,base_percent:100,attribute:0}]")
		```
		data modify storage skill:main damage_info.hit_effect set value 0
		
		function ARG(_PATH)set_numeric
		function ARG(_PATH)cast_effect
		```
		if "ARG(skill_id)" not in ["3201005", "6001001", "6001003"]:
			print("function ARG(_PATH)mark_target")
		```
		
		execute if score #FOUND_ENEMY temp matches 1.. run function ARG(_PATH)did_hit
		```
		if "ARG(skill_id)" in ["3201005", "1000006", "2221006", "3221001"]:
			print("scoreboard players reset #AFTER_MODIFIER_NUM temp")
		```
	}
	
	func did_hit()
	{
		scoreboard players set #EXP_GAIN temp 0
		```
		# mp eater
		if "ARG(skill_id)"[0] == "2":
			print("function skill:2/1/0/0000/set_numeric")
		```
		data modify storage skill:main damage_info.attacker set from entity @s UUID
		execute store result storage skill:main damage_info.attacker_id int 1 run scoreboard players get @s number
		```
		print("execute positioned 250.0 0.0 0.0 rotated ~ 0 run summon marker ^ ^ ^0.2 {UUID:%s}" %UUID_LIST["knockback"])
		```
		data modify storage skill:main damage_info.knock_back set from entity 00000000-0000-0005-0000-000000000005 Pos
		execute store result score #GLOBAL temp run data get storage skill:main damage_info.knock_back[0] 10000
		execute store result storage skill:main damage_info.knock_back[0] double 0.0001 run scoreboard players remove #GLOBAL temp 2500000
		kill 00000000-0000-0005-0000-000000000005
		
		data modify storage skill:main new_schedule set value []
		function ARG(_PATH)append_scheduler
		```
		if "ARG(skill_id)" in ["3101003","6001003"]:
			print("data modify storage skill:main damage_info.power_knock_back set from storage skill:main damage_info.knock_back")
			print("execute store result storage skill:main damage_info.power_knock_back[0] double 0.0007 run data get storage skill:main damage_info.power_knock_back[0] 10000")
			print("execute store result storage skill:main damage_info.power_knock_back[2] double 0.0007 run data get storage skill:main damage_info.power_knock_back[2] 10000")
		```
		execute as @e[type=ocelot,tag=target] at @s run function ARG(_PATH)hit
		```
		# mp eater
		if "ARG(skill_id)"[0] == "2":
			print("execute if score #TOTAL_ABSORB temp matches 1.. run function skill:2/1/0/0000/cast_effect")
		```
		function skill:hunt_exp
	}
	
	func hit_effect()
	{
		execute store result score #GLOBAL ARG(skill_id)_eid run time query gametime
		execute as @e[type=ocelot] if score @s ARG(skill_id)_eid = #GLOBAL ARG(skill_id)_eid at @s run function ARG(_PATH)perform_effect
	}
	
	func perform_effect()
	{
		scoreboard players remove @s queuing_effect 1
		
		execute store result score @s display_number run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.number
		execute store result score @s display_num_type run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.crit
		execute store result score #NUMBER_HEIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.height
		execute store result score #HIT_EFFECT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].hit_effect
		execute if entity @s[tag=!no_anger] run function ARG(_PATH)set_angry_at
		
		execute store result score #GLOBAL temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker_id
		```
		print("execute as @a if score @s number = #GLOBAL temp at @s run summon marker ~ ~ ~ {UUID:%s}" %UUID_LIST["face_effect"])
		```
		execute facing entity 00000000-0000-0004-0000-000000000004 feet run function ARG(_PATH)facing_effect
		kill 00000000-0000-0004-0000-000000000004
		
		function skill:show_num_at_height
		
		execute if score @s hp matches ..0 unless score @s queuing_effect matches 1.. run function skill:mob_effect/dead
		data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
		execute unless data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] run scoreboard players reset @s ARG(skill_id)_eid
		execute store result score #GLOBAL temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		execute if score #GLOBAL temp = @s ARG(skill_id)_eid run function ARG(_PATH)perform_effect
		execute if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] run scoreboard players operation @s ARG(skill_id)_eid = #GLOBAL temp
	}
	
	func set_angry_at()
	{
		function skill:rand_anger_time

		data modify storage skill:main damage_info.attacker set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker
		execute on controller run function skill:set_mob_target
	}
	
	func facing_effect()
	{
		```
		if "ARG(skill_id)" in ["3101003","6001003"]:
			print("scoreboard players set #DID_KNOCKBACK temp 1")
			print("execute if score @s kb > @s display_number unless data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].force_knock run scoreboard players set #DID_KNOCKBACK temp 0")
			print("execute unless score @s pushed_time matches 0.. if score #DID_KNOCKBACK temp matches 1 run function ARG(_PATH)knock_back")
		else:
			print("execute unless score @s pushed_time matches 0.. if score @s kb <= @s display_number run function ARG(_PATH)knock_back")
		```
		scoreboard players operation #DEFAULT_SIZE temp = @s default_width
		function ARG(_PATH)forward_effect/run
	}
	
	folder forward_effect()
	{
		func run()
		{
			scoreboard players remove #DEFAULT_SIZE temp 1
			execute if score #DEFAULT_SIZE temp matches -1 run function ARG(_PATH)forward
			execute if score #DEFAULT_SIZE temp matches 0.. positioned ^ ^ ^0.4 run function ARG(_PATH)run
		}
		
		func forward()
		{
			execute if score @s display_number matches 1.. if score #HIT_EFFECT temp matches 1 positioned ^ ^ ^0.5 run function skill:afterimage/hit/mace
			execute if score @s display_number matches 1.. if score #HIT_EFFECT temp matches 2 positioned ^ ^ ^0.5 run function skill:afterimage/hit/sword
			function ARG(__PATH)effect
		}
	}
	
	func knock_back()
	{
		scoreboard players set @s pushed_time 12
		scoreboard players operation @s kb_time > @s pushed_time
		execute if score @s status matches ..3 run scoreboard players set @s status 1
		function skill:sync_knockback/run
		
		# face attacker player
		tp @s ~ ~ ~ ~ ~
		
		data modify entity @s Motion set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].knock_back
	}
	
	func hit()
	{
		function skill:calculate_damage/run
		```
		if "ARG(skill_id)" in ["3101003","6001003"]:
			print("execute if entity @s[tag=!dead] run function random:rand_rate")
		
		# add debuff even if no hit
		if "ARG(skill_id)" in ["4201004"]:
			print("function ARG(_PATH)add_debuff")
		else:
			print("execute if score #DID_HIT temp matches 1 run function ARG(_PATH)add_debuff")

		# mp eater
		if "ARG(skill_id)"[0] == "2":
			print("execute if score #ABSORB_RATE temp matches 1.. if score @s[tag=!boss] mp matches 1.. run function skill:2/1/0/0000/try_absorb")
		```
		
		data modify storage skill:main new_queue set value []
		data modify storage skill:main temp set from storage skill:main new_schedule
		function ARG(_PATH)merge_schedule/run
		data modify entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue prepend from storage skill:main new_queue[]
		execute store result score @s ARG(skill_id)_eid run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		
		scoreboard players set @s hit_distance 0
		scoreboard players set @s hit_order 0
		tag @s remove first_target
		tag @s remove target
	}
	
	folder merge_schedule() from while_loop("if data storage skill:main temp[0]")
	{
		func execute()
		{
			execute store result score #EFFECT_DELAY temp run data get storage skill:main temp[0].delay
			execute if score #EFFECT_DELAY temp = @s hit_distance run function ARG(_PATH)merge
			
			data remove storage skill:main temp[0]
		}
		
		func merge()
		{
			execute store result score #LEFT temp run data get storage skill:main temp[0].time
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
			function ARG(__PATH)merge_ori_schedule/run
			```
			if "ARG(skill_id)" in ["3101003","6001003"]:
				print("scoreboard players operation #SELF_KNOCKBACK_RATE temp = #SKILL_KNOCKBACK_RATE temp")
				print("execute store result score #THIS_DAMAGE temp run data get entity @s ArmorItems[3].tag.damage_record[0].number")
				print("execute if score @s kb <= #THIS_DAMAGE temp run scoreboard players operation #SELF_KNOCKBACK_RATE temp += #KNOCKBACK_RATE temp")
			```
			data modify storage skill:main new_queue append value {}
			execute store result storage skill:main new_queue[-1].time int 1 run scoreboard players get #LEFT temp
			data modify storage skill:main new_queue[-1].damage set from entity @s ArmorItems[3].tag.damage_record[0]
			data modify storage skill:main new_queue[-1].attacker set from storage skill:main damage_info.attacker
			data modify storage skill:main new_queue[-1].attacker_id set from storage skill:main damage_info.attacker_id
			data modify storage skill:main new_queue[-1].hit_effect set from storage skill:main damage_info.hit_effect
			
			data modify storage skill:main new_queue[-1].knock_back set from storage skill:main damage_info.knock_back
			```
			if "ARG(skill_id)" in ["3101003","6001003"]:
				print("execute if score #RAND_RESULT number < #SELF_KNOCKBACK_RATE temp if entity @s[tag=!boss] run data modify storage skill:main new_queue[-1].knock_back set from storage skill:main damage_info.power_knock_back")
				print("execute if score #RAND_RESULT number < #SELF_KNOCKBACK_RATE temp if entity @s[tag=!boss] run data modify storage skill:main new_queue[-1].force_knock set value 1b")
			```
			data remove entity @s ArmorItems[3].tag.damage_record[0]
			scoreboard players add @s queuing_effect 1
		}
	}
	
	folder merge_ori_schedule() from while_loop("if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] if score #RIGHT temp < #LEFT temp")
	{
		func execute()
		{
			data modify storage skill:main new_queue append from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		}
	}
	
	func add_debuff();
	func append_scheduler_sample() as virtual
	{
		data modify storage skill:main new_schedule append value 0
		execute store result storage skill:main new_schedule[-1] int 1 run schedule function ARG(_PATH)hit_effect 6t append
		data modify storage skill:main new_schedule append value 0
		execute store result storage skill:main new_schedule[-1] int 1 run schedule function ARG(_PATH)hit_effect 9t append
	}
}

namespace bullet_skill_template(skill_id) as virtual
{
	# functions to override:
	#	check => check whether to use the skill or not
	#	mark_target => tag all target
	#	cast_effect => visual and audio effects on casting skill
	#	set_numeric => calculate all numbers related to damage and write to global storage
	#	add_debuff => set all debuff numbers as the hit mob (optional)
	#	effect => visual and audio effects with display_number as damage
	#	append_scheduler => see "append_scheduler_sample"
	
	```
	skill_ids.append("ARG(skill_id)")
	```
	
	func run()
	{
		```
		# reset final attack
		if "ARG(skill_id)" != "3000006":
			print("scoreboard players reset @s f_attack_skill")
		```
		function skill:use_constraint
		
		data modify storage skill:main damage set value [{min_damage:0,max_damage:0,accuracy:0,player_level:0,crit_rate:0,crit_damage:0,base_percent:100,attribute:0}]
		data modify storage skill:main damage_info.hit_effect set value 0
		
		function ARG(_PATH)summon_bullet
		function ARG(_PATH)set_numeric
		function ARG(_PATH)cast_effect
		```
		if "ARG(skill_id)" not in ["3101005", "3001004", "3001005", "4101005", "4001344", "6001002"]:
			print("function ARG(_PATH)mark_target")
		```
		
		scoreboard players add #BULLET_ID number 1
		execute if score #FOUND_ENEMY temp matches 1.. run function ARG(_PATH)did_hit
		execute if score #FOUND_ENEMY temp matches 0 as @e[type=armor_stand,tag=new_bullet] run function skill:bullet/no_target_setting
	}
	
	func did_hit()
	{
		scoreboard players set #EXP_GAIN temp 0
		```
		# mp eater
		if "ARG(skill_id)"[0] == "2" or "ARG(skill_id)" == "0001000":
			print("function skill:2/1/0/0000/set_numeric")
		```
		data modify storage skill:main damage_info.attacker set from entity @s UUID
		execute store result storage skill:main damage_info.attacker_id int 1 run scoreboard players get @s number
		```
		print("execute positioned 250.0 0.0 0.0 rotated ~ 0 run summon marker ^ ^ ^0.2 {UUID:%s}" %UUID_LIST["knockback"])
		```
		data modify storage skill:main damage_info.knock_back set from entity 00000000-0000-0005-0000-000000000005 Pos
		execute store result score #GLOBAL temp run data get storage skill:main damage_info.knock_back[0] 10000
		execute store result storage skill:main damage_info.knock_back[0] double 0.0001 run scoreboard players remove #GLOBAL temp 2500000
		kill 00000000-0000-0005-0000-000000000005
		
		execute as @e[type=ocelot,tag=target] at @s run function ARG(_PATH)hit
		```
		if "ARG(skill_id)" == "4101005":
			print("scoreboard players operation @s hp += #DRAIN_AMOUNT temp")
			print("scoreboard players operation @s hp < @s hp_max")
			print("function bar_display:change/hp/recovered")
		elif "ARG(skill_id)"[0] == "2" or "ARG(skill_id)" == "0001000":
			print("execute if score #TOTAL_ABSORB temp matches 1.. run function skill:2/1/0/0000/cast_effect")
		```
		function skill:hunt_exp
	}
	
	func hit_effect()
	{
		execute store result score #GLOBAL ARG(skill_id)_eid run time query gametime
		execute as @e[type=ocelot] if score @s ARG(skill_id)_eid = #GLOBAL ARG(skill_id)_eid at @s run function ARG(_PATH)perform_effect
	}
	
	func perform_effect()
	{
		scoreboard players remove @s queuing_effect 1
		
		execute store result score @s display_number run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.number
		execute store result score @s display_num_type run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.crit
		execute store result score #NUMBER_HEIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage.height
		execute store result score #HIT_EFFECT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].hit_effect
		execute if entity @s[tag=!no_anger] run function ARG(_PATH)set_angry_at
		
		execute store result score #GLOBAL temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker_id
		```
		print("execute as @a if score @s number = #GLOBAL temp at @s run summon marker ~ ~ ~ {UUID:%s}" %UUID_LIST["face_effect"])
		```
		execute facing entity 00000000-0000-0004-0000-000000000004 feet run function ARG(_PATH)facing_effect
		kill 00000000-0000-0004-0000-000000000004
		
		function skill:show_num_at_height
		
		execute if score @s hp matches ..0 unless score @s queuing_effect matches 1.. run function skill:mob_effect/dead
		data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
		execute unless data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] run scoreboard players reset @s ARG(skill_id)_eid
		execute store result score #GLOBAL temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		execute if score #GLOBAL temp = @s ARG(skill_id)_eid run function ARG(_PATH)perform_effect
		execute if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] run scoreboard players operation @s ARG(skill_id)_eid = #GLOBAL temp
	}
	
	func set_angry_at()
	{
		function skill:rand_anger_time

		data modify storage skill:main damage_info.attacker set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].attacker
		execute on controller run function skill:set_mob_target
	}
	
	func facing_effect()
	{
		execute unless score @s pushed_time matches 0.. if score @s kb <= @s display_number run function ARG(_PATH)knock_back
		scoreboard players operation #DEFAULT_SIZE temp = @s default_width
		function ARG(_PATH)forward_effect/run
	}
	
	folder forward_effect()
	{
		func run()
		{
			scoreboard players remove #DEFAULT_SIZE temp 1
			execute if score #DEFAULT_SIZE temp matches -1 run function ARG(_PATH)forward
			execute if score #DEFAULT_SIZE temp matches 0.. positioned ^ ^ ^0.4 run function ARG(_PATH)run
		}
		
		func forward()
		{
			execute if score @s display_number matches 1.. if score #HIT_EFFECT temp matches 1 positioned ^ ^ ^0.5 run function skill:afterimage/hit/mace
			execute if score @s display_number matches 1.. if score #HIT_EFFECT temp matches 2 positioned ^ ^ ^0.5 run function skill:afterimage/hit/sword
			function ARG(__PATH)effect
		}
	}
	
	func knock_back()
	{
		scoreboard players set @s pushed_time 12
		scoreboard players operation @s kb_time > @s pushed_time
		execute if score @s status matches ..3 run scoreboard players set @s status 1
		function skill:sync_knockback/run
		
		# face attacker player
		tp @s ~ ~ ~ ~ ~
		
		data modify entity @s Motion set from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].knock_back
	}
	
	func hit()
	{
		scoreboard players operation #GLOBAL temp = @s number
		
		scoreboard players set #BULLET_AMOUNT temp 0
		execute as @e[type=armor_stand,tag=new_bullet] run function skill:bullet/setting
		
		function skill:calculate_damage/run
		execute if score #DID_HIT temp matches 1 run function ARG(_PATH)add_debuff
		```
		# mp eater
		if "ARG(skill_id)"[0] == "2" or "ARG(skill_id)" == "0001000":
			print("execute if score #ABSORB_RATE temp matches 1.. if score @s[tag=!boss] mp matches 1.. run function skill:2/1/0/0000/try_absorb")
		```
		scoreboard players add @s queuing_effect 1
		data modify entity @s ArmorItems[3].tag.bullet_list append value {}
		execute store result entity @s ArmorItems[3].tag.bullet_list[-1].bullet_id int 1 run scoreboard players get #BULLET_ID number
		data modify entity @s ArmorItems[3].tag.bullet_list[-1].damage_record set from entity @s ArmorItems[3].tag.damage_record
		data modify entity @s ArmorItems[3].tag.bullet_list[-1].damage_info set from storage skill:main damage_info
		
		tag @s remove target
		tag @s remove first_target
		scoreboard players operation @s bullet_targeted += #BULLET_AMOUNT temp
	}
	
	folder bullet_hit()
	{
		func run()
		{
			data modify storage skill:main temp set value []
			function ARG(_PATH)pop_bullet_list
			
			scoreboard players remove @s queuing_effect 1
			data modify storage skill:main new_queue set value []
			function ARG(__PATH)merge_schedule/run
			data modify entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue prepend from storage skill:main new_queue[]
			execute store result score @s ARG(skill_id)_eid run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
			
			data remove entity @s ArmorItems[3].tag.bullet_list[0]
			data modify entity @s ArmorItems[3].tag.bullet_list prepend from storage skill:main temp[]
		}
		
		func pop_bullet_list()
		{
			execute store result score #CUR_BULLET_ID temp run data get entity @s ArmorItems[3].tag.bullet_list[0].bullet_id
			execute unless score #CUR_BULLET_ID temp = #BULLET_ID temp run function ARG(_PATH)check_next
		}
		
		func check_next()
		{
			data modify storage skill:main temp append from entity @s ArmorItems[3].tag.bullet_list[0]
			data remove entity @s ArmorItems[3].tag.bullet_list[0]
			function ARG(_PATH)pop_bullet_list
		}
	}
	
	```
	# 3101005 uses its own merge_schedule function
	if "ARG(skill_id)" != "3101005":
		print('''
	folder merge_schedule() from while_loop("if data storage skill:main new_schedule[0]")
	{
		func execute()
		{
			execute store result score #LEFT temp run data get storage skill:main new_schedule[0].time
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
			function ARG(__PATH)merge_ori_schedule/run
			
			data modify storage skill:main new_queue append value {time:0,damage:0,attacker:[I;0,0,0,0],knock_back:[]}
			execute store result storage skill:main new_queue[-1].time int 1 run scoreboard players get #LEFT temp
			data modify storage skill:main new_queue[-1].damage set from entity @s ArmorItems[3].tag.bullet_list[0].damage_record[0]
			data modify storage skill:main new_queue[-1].attacker set from entity @s ArmorItems[3].tag.bullet_list[0].damage_info.attacker
			data modify storage skill:main new_queue[-1].attacker_id set from entity @s ArmorItems[3].tag.bullet_list[0].damage_info.attacker_id
			data modify storage skill:main new_queue[-1].hit_effect set from entity @s ArmorItems[3].tag.bullet_list[0].damage_info.hit_effect
			data modify storage skill:main new_queue[-1].knock_back set from entity @s ArmorItems[3].tag.bullet_list[0].damage_info.knock_back
			
			data remove storage skill:main new_schedule[0]
			data remove entity @s ArmorItems[3].tag.bullet_list[0].damage_record[0]
			scoreboard players add @s queuing_effect 1
		}
	}
	''')
	```
	
	folder merge_ori_schedule() from while_loop("if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] if score #RIGHT temp < #LEFT temp")
	{
		func execute()
		{
			data modify storage skill:main new_queue append from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		}
	}
	
	func add_debuff();
	func summon_bullet_sample() as virtual
	{
		# first bullet should have "first_bullet" tag
		summon minecraft:armor_stand ~ ~ ~ {Tags:["first_bullet","new_bullet","bullet"],CustomName:'{"text":"2","font":"space:default"}',ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1,tag:{appear_delay:16,max_distance:5,skill_id:1,bullet_model:123,CustomModelData:1}}],Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Fire:32767s,CustomNameVisible:0}
		summon minecraft:armor_stand ~ ~ ~ {Tags:["new_bullet","bullet"],CustomName:'{"text":"2","font":"space:default"}',ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1,tag:{appear_delay:19,max_distance:5,skill_id:1,bullet_model:123,CustomModelData:1}}],Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Fire:32767s,CustomNameVisible:0}
	}
}

namespace cd_counter(skill_id) as virtual
{
	func add()
	{
		scoreboard players add #ARG(skill_id)_CD_PEOPLE temp 1
		execute if score #ARG(skill_id)_CD_PEOPLE temp matches 1 run schedule function ARG(_PATH)loop 1s
	}
	
	func loop()
	{
		execute as @a if score @s ARG(skill_id)_cd matches 1.. run function ARG(_PATH)countdown
		execute if score #ARG(skill_id)_CD_PEOPLE temp matches 1.. run schedule function ARG(_PATH)loop 1s
	}
	
	func countdown()
	{
		scoreboard players remove @s ARG(skill_id)_cd 1
		execute if score @s ARG(skill_id)_cd matches 0 run scoreboard players remove #ARG(skill_id)_CD_PEOPLE temp 1
	}
}

namespace booster_skill_template(skill_id, weapon, icon) as virtual
{
	func check()
	{
		```
		if "ARG(skill_id)"[0] == "4":
			print("execute unless score @s action_time matches 1.. if score @s ARG(skill_id)_level matches 1.. unless score @s invis_buff_time matches 1.. run function ARG(_PATH)other_check")
		else:
			print("execute unless score @s action_time matches 1.. if score @s ARG(skill_id)_level matches 1.. run function ARG(_PATH)other_check")
		```
	}
	
	func other_check()
	{
		function skill:check_weapon/ARG(weapon)/run
		execute if score #ACCEPTED_WEAPON temp matches 1.. if score @s hp <= @s ARG(skill_id)_mp run tellraw @s {"translate":"warning.skill.lack_hp","font":"minecraft:uniform","color":"#efb7ab"}
		execute if score #ACCEPTED_WEAPON temp matches 1.. if score @s hp > @s ARG(skill_id)_mp run function ARG(_PATH)mp_check
	}
	
	func mp_check()
	{
		execute if score @s mp < @s ARG(skill_id)_mp run tellraw @s {"translate":"warning.skill.lack_mp","font":"minecraft:uniform","color":"#efb7ab"}
		execute if score @s mp >= @s ARG(skill_id)_mp run function ARG(_PATH)cast_effect
	}
	
	func cast_effect()
	{
		function skill:use_constraint
		
		function skill:buff/boost/run
		
		# set this buff values
		scoreboard players operation @s boost_buff_time = @s ARG(skill_id)_time
		```
		print(f"attribute @s minecraft:generic.luck modifier add {simple_buff_info_dict['boost']['uuid']} ARG(icon) 0 add")
		```
		# VVV since we got mp change below, no need to update the bar display VVV
		# tag @s add hp_mp_varying
		
		scoreboard players operation #BIND_PLAYER number = @s number
		execute summon text_display run function skill:summon_font_effect/1101004effect
		playsound minecraft:skill.1101004 player @a ~ ~ ~ 1 1 0
		
		scoreboard players operation @s hp -= @s ARG(skill_id)_mp
		scoreboard players operation @s mp -= @s ARG(skill_id)_mp
		function bar_display:change/hp/dropped
		function bar_display:change/mp/dropped
		
		scoreboard players set @s action_time 12
	}
	
	folder levels()
	{
		func add()
		{
			scoreboard players add @s ARG(skill_id)_level 1
			function ARG(_PATH)check
			function skill:window/after_addition
		}
		
		func check()
		{
			scoreboard players operation @s ARG(skill_id)_time = @s ARG(skill_id)_level
			scoreboard players operation @s ARG(skill_id)_time *= #10 const
			scoreboard players set @s ARG(skill_id)_mp 30
			scoreboard players operation @s ARG(skill_id)_mp -= @s ARG(skill_id)_level
		}
		
		func set_description()
		{
			data modify block 250 0 0 Text1 set value '""'
			data modify storage ui:main temp set value [0, 0, 0, 0, 0, 0]
			execute store result storage ui:main temp[0] int 1 run scoreboard players get @s ARG(skill_id)_level
			execute store result storage ui:main temp[1] int 1 run scoreboard players get @s ARG(skill_id)_mp
			execute store result storage ui:main temp[2] int 1 run scoreboard players get @s ARG(skill_id)_time
			
			execute if score @s ARG(skill_id)_level matches ..19 run function ARG(_PATH)get_next_level
			execute if score @s ARG(skill_id)_level matches 1.. run data modify block 250 0 0 Text1 set value '[{"translate":"skill.description.level.current","with":[{"nbt":"temp[0]","storage":"ui:main"}]},{"translate":"skill.description.level.ARG(skill_id)","with":[{"nbt":"temp[1]","storage":"ui:main"},{"nbt":"temp[2]","storage":"ui:main"}]},{"nbt":"Text1","block":"250 0 0","interpret":true}]'
			data modify storage ui:main skill_level_info append from block 250 0 0 Text1
		}
		
		func get_next_level()
		{
			scoreboard players add @s ARG(skill_id)_level 1
			
			function ARG(_PATH)check
			execute store result storage ui:main temp[3] int 1 run scoreboard players get @s ARG(skill_id)_level
			execute store result storage ui:main temp[4] int 1 run scoreboard players get @s ARG(skill_id)_mp
			execute store result storage ui:main temp[5] int 1 run scoreboard players get @s ARG(skill_id)_time
			data modify block 250 0 0 Text1 set value '[{"translate":"skill.description.level.next","with":[{"nbt":"temp[3]","storage":"ui:main"}]},{"translate":"skill.description.level.ARG(skill_id)","with":[{"nbt":"temp[4]","storage":"ui:main"},{"nbt":"temp[5]","storage":"ui:main"}]}]'
			
			scoreboard players remove @s ARG(skill_id)_level 1
			execute store result score @s ARG(skill_id)_mp run data get storage ui:main temp[1]
			execute store result score @s ARG(skill_id)_time run data get storage ui:main temp[2]
			execute if score @s ARG(skill_id)_level matches 1.. run data modify block 250 0 0 Text1 set value '["\\n",{"nbt":"Text1","block":"250 0 0","interpret":true}]'
		}
	}
}


import buff as virtual
import skill_window as virtual
import 0 as virtual
import 1 as virtual
import 2 as virtual
import 3 as virtual
import 4 as virtual
# import 5 as virtual

namespace skill()
{
	folder buff() from buff();
	folder window() from skill_window();
	folder 0() from 0();
	folder 1() from 1();
	folder 2() from 2();
	folder 3() from 3();
	folder 4() from 4();
	# folder 5() from 5();
	
	# for auto attack
	folder 6()
	{
		folder 0()
		{
			folder 0()
			{
				folder 1000()
				{
					func check()
					{
						execute unless score @s action_time matches 0.. run function ARG(_PATH)invisible_check
					}
					
					func invisible_check()
					{
						execute unless score @s invis_buff_time matches 1.. run function ARG(_PATH)rope_check
						execute if score @s invis_buff_time matches 1.. run function skill:4/0/0/1003/cancel
					}
					
					func rope_check()
					{
						scoreboard players set #GLOBAL temp 0
						execute if block ~0.3 ~-0.4 ~0.3 #minecraft:climbable if block ~0.3 ~-0.4 ~-0.3 #minecraft:climbable if block ~-0.3 ~-0.4 ~0.3 #minecraft:climbable if block ~-0.3 ~-0.4 ~-0.3 #minecraft:climbable run scoreboard players set #GLOBAL temp 1
						execute if score #GLOBAL temp matches 0 unless block ~0.3 ~ ~0.3 #minecraft:climbable unless block ~0.3 ~ ~-0.3 #minecraft:climbable unless block ~-0.3 ~ ~0.3 #minecraft:climbable unless block ~-0.3 ~ ~-0.3 #minecraft:climbable run function ARG(_PATH)weapon_check
					}
				
					func weapon_check()
					{
						function skill:check_weapon/check_empty
						execute if score #USED_WEAPON temp matches 1.. run function ARG(_PATH)box/check
					}
					
					folder box()
					{
						func check()
						{
							# 預設弓、弩、拳套攻擊範圍
							scoreboard players set #DISTANCE temp 2
							scoreboard players set #SEARCH_HEIGHT temp 0
							scoreboard players set #NO_AFTERIMAGE temp 0
							# 遠距離武器要先確定會不會打到箱子，才知道要不要表演揮的特效，所以這邊先不做
							execute if score #USED_WEAPON temp matches 5.. unless score #USED_WEAPON temp matches 16..18 unless score #USED_WEAPON temp matches 24 run function ARG(_PATH)check_range
							
							data modify storage skill:main damage_info.attacker set from entity @s UUID
							function ARG(_PATH)search_box/search
							
							execute if score #FOUND_ENEMY temp matches 1 run function ARG(_PATH)cast_effect
							execute if score #FOUND_ENEMY temp matches 0 run function ARG(__PATH)attack_check
						}
						
						func check_range()
						{
							# afterimage 會寫傷害資料，要先建起來
							data modify storage skill:main damage set value [{min_damage:0,max_damage:0,accuracy:0,player_level:0,crit_rate:0,crit_damage:0,base_percent:100,attribute:0}]
							
							function skill:enemy_search/check_weapon_distance
							function skill:afterimage/warrior_swing/check
							scoreboard players set #NO_AFTERIMAGE temp 1
						}
						
						folder search_box() from for_loop().for("#DISTANCE temp", "if score #FOUND_ENEMY temp matches 0 positioned ^ ^ ^0.8")
						{
							func search()
							{
								scoreboard players set #CUR_DISTANCE temp 0
								scoreboard players set #FOUND_ENEMY temp 0
								```
								print("execute at @s rotated ~ 0 positioned ^ ^ ^100 run summon minecraft:marker ~ ~ ~ {UUID:%s}" %UUID_LIST["search"])
								```
								execute at @s rotated ~ 0 positioned ^ ^ ^-1.8 run function ARG(_PATH)run
								kill 00000000-0000-0003-0000-000000000003
							}
							
							func execute()
							{
								# 打箱子都是近距離攻擊，沒有 5 以上的 #DISTANCE
								# 高度偵測比一般攻擊低一點，因為沒有貓墊高
								execute if score #SEARCH_HEIGHT temp matches 0 positioned ~-1.8 ~-0.3 ~-1.8 as @e[type=interaction,tag=box,dx=2.6,dy=1.3,dz=2.6] on passengers unless score @s status matches 1.. positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)hit_check
								execute if score #SEARCH_HEIGHT temp matches 1 positioned ~-1.8 ~-0.3 ~-1.8 as @e[type=interaction,tag=box,dx=2.6,dy=2.1,dz=2.6] on passengers unless score @s status matches 1.. positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)hit_check
								execute if score #SEARCH_HEIGHT temp matches 2 positioned ~-1.8 ~-0.3 ~-1.8 as @e[type=interaction,tag=box,dx=2.6,dy=2.9,dz=2.6] on passengers unless score @s status matches 1.. positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)hit_check
								scoreboard players add #CUR_DISTANCE temp 1
							}
							
							func hit_check()
							{
								execute if score #FOUND_ENEMY temp matches 0 run function ARG(_PATH)hit
							}
							
							func hit()
							{
								execute unless score @s hp matches 0.. run function ARG(_PATH)setting
								
								scoreboard players set @s status 20
								scoreboard players remove @s hp 1
								execute if score @s hp matches 0 run data modify entity @s ArmorItems[3].tag.killer set from storage skill:main damage_info.attacker
								
								scoreboard players add #FOUND_ENEMY temp 1
							}
							
							func setting()
							{
								execute store result score @s hp run data get entity @s ArmorItems[3].tag.info.hp_max
								execute store result score @s hurt_sound run data get entity @s ArmorItems[3].tag.info.hurt_sound
								# die_sound 這邊不是死亡音效編號，是箱子破壞事件編號 (對應 function 自己播放音效)
								execute store result score @s die_sound run data get entity @s ArmorItems[3].tag.info.die_sound
								execute store result score @s base_model run data get entity @s ArmorItems[3].tag.CustomModelData
								scoreboard players remove @s base_model 1
							}
						}
						
						func cast_effect()
						{
							# melee *RANDOM* swing damage formula and default attack speed is done by afterimage functions
							execute if score #NO_AFTERIMAGE temp matches 0 run scoreboard players operation @s action_time = @s weapon_speed
							execute if score #NO_AFTERIMAGE temp matches 1 run scoreboard players operation @s action_time += @s weapon_speed
							scoreboard players remove @s[scores={boost_buff_time=1..}] action_time 1
							
							execute if score #USED_WEAPON temp matches 16 run function skill:afterimage/bow/swing
							execute if score #USED_WEAPON temp matches 18 run function skill:afterimage/crossbow/swing
							execute if score #USED_WEAPON temp matches 24 run function skill:afterimage/claw/stab
							# 近距離武器揮動特效上面為了抓攻擊高度已經做了，這邊不用再做
						}
						
						func update()
						{
							scoreboard players remove @s status 1
							execute store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players add @s base_model 1
							
							execute if score @s status matches 13 run function ARG(_PATH)hit_effect
							execute if score @s status matches 0 if score @s hp matches 0 run function ARG(_PATH)kill
						}
						
						func kill()
						{
							execute on vehicle run kill @s
							function main:deep_kill
						}
						
						func hit_effect()
						{
							execute if score @s hp matches 1.. run function skill:mob_effect/play_hurt_sound/run
							execute if score @s hp matches 0 run function ARG(_PATH)break_effect
						}
						
						func break_effect()
						{
							data modify storage skill:main damage_info.attacker set from entity @s ArmorItems[3].tag.killer
							
							loot spawn ~ ~1 ~ kill @s
							execute as @e[type=item,tag=!checked] at @s run function item:entity/check
							
							function ARG(_PATH)check_break_event/run
						}
						
						folder check_break_event()
						{
							```
							def bs_break_event(event_list, start, end):
								if len(event_list) == 1:
									print("func run()")
									print("{")
									print(f"\texecute if score @s die_sound matches {event_list[0][0]} run {event_list[0][1]}")
									print("}")
									return
								
								if start == end:
									return
								
								mid = (start + end) // 2
								mid_right = mid + 1
								
								if start == 0 and end == len(event_list) - 1:
									print("func run()")
								else:
									print(f"func {start}_{end}()")
								print("{")
								if start == mid:
									print(f"\texecute if score @s die_sound matches {event_list[start][0]} run {event_list[start][1]}")
								else:
									print(f"\texecute if score @s die_sound matches {event_list[start][0]}..{event_list[mid][0]} run function ARG(_PATH){start}_{mid}")
								if mid_right == end:
									print(f"\texecute if score @s die_sound matches {event_list[end][0]} run {event_list[end][1]}")
								else:
									print(f"\texecute if score @s die_sound matches {event_list[mid_right][0]}..{event_list[end][0]} run function ARG(_PATH){mid_right}_{end}")
								print("}")
								
								bs_break_event(event_list, start, mid)
								bs_break_event(event_list, mid_right, end)
							
							with open(PROJ_DIR + "/../box_events.csv") as f:
								break_events = f.read().split("\n")
								for i in range(len(break_events)):
									break_events[i] = break_events[i].split(",")
									break_events[i][0] = int(break_events[i][0])
							
							bs_break_event(break_events, 0, len(break_events) - 1)
							```
						}
					}
					
					func attack_check()
					{
						execute if score #NO_AFTERIMAGE temp matches 1 run function ARG(__PATH)1001/mark_target
						execute if score #USED_WEAPON temp matches 16..18 run function ARG(_PATH)archer_check
						execute if score #USED_WEAPON temp matches 24 run function ARG(_PATH)claw_check
					}
					
					func archer_check()
					{
						scoreboard players set #LACK_BULLET temp 0
						execute if score #USED_WEAPON temp matches 16 unless score @s bullet_item matches 21..25 run scoreboard players set #LACK_BULLET temp 1
						execute if score #USED_WEAPON temp matches 18 unless score @s bullet_item matches 26..30 run scoreboard players set #LACK_BULLET temp 1
						execute unless score @s bullet_amount matches 1.. run scoreboard players set #LACK_BULLET temp 1
						execute if score @s soul_buff_time matches 1.. if score @s 3101004_weapon = #USED_WEAPON temp run scoreboard players set #LACK_BULLET temp 0
						
						execute if score #LACK_BULLET temp matches 1 run function ARG(__PATH)1003/mark_target
						execute if score #LACK_BULLET temp matches 0 run function ARG(__PATH)1002/check_distance
					}
			
					func claw_check()
					{
						scoreboard players set #LACK_BULLET temp 0
						execute unless score @s bullet_item matches ..20 run scoreboard players set #LACK_BULLET temp 1
						execute unless score @s bullet_amount matches 1.. run scoreboard players set #LACK_BULLET temp 1
						
						execute if score #LACK_BULLET temp matches 1 run function ARG(__PATH)1001/mark_target
						execute if score #LACK_BULLET temp matches 0 run function ARG(__PATH)1002/check_distance
					}
				}
				
				# melee weapon normal attack
				folder 1001() from attack_skill_template(6001001)
				{
					func mark_target()
					{
						execute unless score #USED_WEAPON temp matches 24 run function skill:enemy_search/check_weapon_distance
						execute if score #USED_WEAPON temp matches 24 run scoreboard players set #DISTANCE temp 2
						
						scoreboard players set #MAX_ENEMY temp 1
						function skill:enemy_search/search_front/search
						
						function ARG(_PATH)run
					}
				
					func set_numeric()
					{
						# melee *RANDOM* swing damage formula and default attack speed is done by afterimage functions
						execute if score #NO_AFTERIMAGE temp matches 0 run scoreboard players operation @s action_time = @s weapon_speed
						execute if score #NO_AFTERIMAGE temp matches 1 run scoreboard players operation @s action_time += @s weapon_speed
						scoreboard players remove @s[scores={boost_buff_time=1..}] action_time 1
					}
				
					func cast_effect()
					{
						# 近距離武器揮動特效上面打箱子已經做了，這邊不用再做
						execute if score #USED_WEAPON temp matches 24 run function skill:afterimage/claw/stab
						
						# hit_effect: 0 => None, 1 => mace, 2 => sword
						data modify storage skill:main damage_info.hit_effect set value 1
						execute unless score #USED_WEAPON temp matches ..4 unless score #USED_WEAPON temp matches 9..10 unless score #USED_WEAPON temp matches 16..21 unless score #USED_WEAPON temp matches 24 run data modify storage skill:main damage_info.hit_effect set value 2
					}
					
					func effect()
					{
						function skill:mob_effect/play_hurt_sound/run
					}
				
					func append_scheduler()
					{
						data modify storage skill:main new_schedule append value {delay:0,time:0}
						execute store result storage skill:main new_schedule[-1].time int 1 run schedule function ARG(_PATH)hit_effect 7t append
					}
				}
				
				# bullet weapon normal attack
				folder 1002() from bullet_skill_template(6001002)
				{
					func check_distance()
					{
						function ARG(_PATH)mark_target
						execute unless score #FIRST_DISTANCE temp matches ..2 run function ARG(_PATH)run_shoot
						execute if score #FIRST_DISTANCE temp matches ..2 run function ARG(_PATH)run_swing
					}
					
					func run_shoot()
					{
						execute if score #USED_WEAPON temp matches 24 run function ARG(_PATH)run
						execute if score #USED_WEAPON temp matches 16..18 run function ARG(_PATH)check_on_ground
					}
					
					func check_on_ground()
					{
						execute if entity @s[nbt={OnGround:1b}] run function ARG(_PATH)run
						execute unless entity @s[nbt={OnGround:1b}] as @e[type=ocelot,tag=target] run function skill:enemy_search/clear
					}
					
					func run_swing()
					{
						execute if score #USED_WEAPON temp matches 24 run function skill:6/0/0/1001/run
						execute if score #USED_WEAPON temp matches 16..18 run function skill:6/0/0/1003/run
					}
					
					func mark_target()
					{
						execute if score #USED_WEAPON temp matches 16..18 run scoreboard players operation #DISTANCE temp = @s amazon_eyes_dist
						execute if score #USED_WEAPON temp matches 24 run scoreboard players operation #DISTANCE temp = @s keen_eyes_dist
						scoreboard players set #MAX_ENEMY temp 1
						function skill:enemy_search/search_front/search
					}
				
					func summon_bullet()
					{	
						scoreboard players operation #GLOBAL bullet_model = @s bullet_model
						execute if score @s soul_buff_time matches 1.. if score @s 3101004_weapon = #USED_WEAPON temp run scoreboard players set #GLOBAL bullet_model 3001
						scoreboard players operation #BULLET_DISTANCE temp = #DISTANCE temp
						scoreboard players remove #BULLET_DISTANCE temp 1
						
						execute if score #USED_WEAPON temp matches 16 rotated ~ 0 positioned ^ ^0.2 ^1 summon minecraft:armor_stand run function ARG(_PATH)set_bullet/bow
						execute if score #USED_WEAPON temp matches 18 rotated ~ 0 positioned ^ ^0.2 ^1 summon minecraft:armor_stand run function ARG(_PATH)set_bullet/crossbow
						execute if score #USED_WEAPON temp matches 24 rotated ~ 0 positioned ^ ^0.2 ^1 summon minecraft:armor_stand run function ARG(_PATH)set_bullet/claw
					}
					
					folder set_bullet()
					{
						func bow()
						{
							data merge entity @s {Tags:["first_bullet","new_bullet","bullet"],CustomName:'{"text":"2","font":"space:default"}',ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1,tag:{appear_delay:7,max_distance:10,skill_id:11,bullet_model:3101,CustomModelData:1}}],Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Fire:32767s,CustomNameVisible:0}
							function ARG(_PATH)base
						}

						func crossbow()
						{
							data merge entity @s {Tags:["first_bullet","new_bullet","bullet"],CustomName:'{"text":"2","font":"space:default"}',ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1,tag:{appear_delay:8,max_distance:10,skill_id:11,bullet_model:3201,CustomModelData:1}}],Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Fire:32767s,CustomNameVisible:0}
							function ARG(_PATH)base
						}

						func claw()
						{
							data merge entity @s {Tags:["first_bullet","new_bullet","bullet"],CustomName:'{"text":"2","font":"space:default"}',ArmorItems:[{},{},{},{id:"minecraft:potion",Count:1,tag:{appear_delay:7,max_distance:10,skill_id:11,bullet_model:4000,CustomModelData:1}}],Marker:1,Invisible:1,Invulnerable:1,NoGravity:1,Fire:32767s,CustomNameVisible:0}
							function ARG(_PATH)base
						}

						func base()
						{
							execute store result entity @s ArmorItems[3].tag.max_distance int 1 run scoreboard players get #BULLET_DISTANCE temp
							execute store result entity @s ArmorItems[3].tag.bullet_model int 1 run scoreboard players get #GLOBAL bullet_model
						}
					}
				
					func set_numeric()
					{
						execute if score #USED_WEAPON temp matches 16 run function skill:damage_formula/bow/normal
						execute if score #USED_WEAPON temp matches 18 run function skill:damage_formula/crossbow/normal
						execute if score #USED_WEAPON temp matches 24 run function skill:damage_formula/claw/normal
						
						scoreboard players remove @s bullet_amount 1
						execute if score @s soul_buff_time matches 1.. if score @s 3101004_weapon = #USED_WEAPON temp run scoreboard players add @s bullet_amount 1
						
						scoreboard players operation @s action_time = @s weapon_speed
						scoreboard players remove @s[scores={boost_buff_time=1..}] action_time 1
						scoreboard players add @s action_time 16
						execute if score #USED_WEAPON temp matches 18 run scoreboard players add @s action_time 1
					}
					
					func cast_effect()
					{
						execute if score #USED_WEAPON temp matches 16 run function ARG(_PATH)bow_effect
						execute if score #USED_WEAPON temp matches 18 run function ARG(_PATH)crossbow_effect
						execute if score #USED_WEAPON temp matches 24 run function ARG(_PATH)claw_effect
						
						# hit_effect: 0 => None, 1 => mace, 2 => sword
						data modify storage skill:main damage_info.hit_effect set value 1
					}
				
					func bow_effect()
					{
						function skill:afterimage/bow/shoot
						# soul arrow does not play arrow sound
						execute unless score #GLOBAL bullet_model matches 3001 run playsound minecraft:skill.attack.bow player @a ~ ~ ~ 1 1 0
					}
					
					func crossbow_effect()
					{
						function skill:afterimage/crossbow/shoot
						# soul arrow does not play arrow sound
						execute unless score #GLOBAL bullet_model matches 3001 run playsound minecraft:skill.attack.crossbow player @a ~ ~ ~ 1 1 0
					}
					
					func claw_effect()
					{
						function skill:afterimage/claw/swing
						playsound minecraft:skill.attack.throw player @a ~ ~ ~ 1 1 0
					}
				
					func effect()
					{
						function skill:mob_effect/play_hurt_sound/run
					}
					
					func append_scheduler()
					{
						data modify storage skill:main new_schedule append value {delay:0,time:0}
						execute store result storage skill:main new_schedule[-1].time int 1 run schedule function ARG(_PATH)hit_effect 1t append
					}
				}
				
				# bow/crossbow swing attack
				folder 1003() from attack_skill_template(6001003)
				{
					func mark_target()
					{
						scoreboard players set #DISTANCE temp 2
						scoreboard players set #SEARCH_HEIGHT temp 0
						scoreboard players set #MAX_ENEMY temp 1
						function skill:enemy_search/search_front/search
						
						function ARG(_PATH)run
					}
			
					func set_numeric()
					{
						# melee *RANDOM* swing damage formula and default attack speed is done by afterimage functions
						scoreboard players operation #KNOCKBACK_RATE temp = @s weapon_knock
						scoreboard players set #SKILL_KNOCKBACK_RATE temp 0
						
						scoreboard players operation @s action_time = @s weapon_speed
						scoreboard players remove @s[scores={boost_buff_time=1..}] action_time 1
					}
			
					func cast_effect()
					{
						execute if score #USED_WEAPON temp matches 16 run function skill:afterimage/bow/swing
						execute if score #USED_WEAPON temp matches 18 run function skill:afterimage/crossbow/swing
						
						# hit_effect: 0 => None, 1 => mace, 2 => sword
						data modify storage skill:main damage_info.hit_effect set value 1
					}
					
					func effect()
					{
						function skill:mob_effect/play_hurt_sound/run
					}
				
					func append_scheduler()
					{
						data modify storage skill:main new_schedule append value {delay:0,time:0}
						execute store result storage skill:main new_schedule[-1].time int 1 run schedule function ARG(_PATH)hit_effect 7t append
					}
				}
			}
		}
	}
	
	func install()
	{
		scoreboard objectives add right_click minecraft.used:minecraft.carrot_on_a_stick
		scoreboard objectives add base_model dummy
		scoreboard objectives add status dummy
		scoreboard objectives add motion_x dummy
		scoreboard objectives add motion_y dummy
		scoreboard objectives add motion_z dummy
		scoreboard objectives add rand_jump dummy
		# 0.4 block per unit
		scoreboard objectives add default_width dummy
		scoreboard objectives add default_height dummy
		
		scoreboard objectives add level dummy "LV"
		scoreboard objectives setdisplay belowName level
		
		scoreboard objectives add exp dummy
		scoreboard objectives add exp_max dummy
		scoreboard objectives add avoidability dummy
		scoreboard objectives add weapon_defense dummy
		scoreboard objectives add magic_defense dummy
		scoreboard objectives add base_accuracy dummy
		scoreboard objectives add base_avoid dummy
		scoreboard objectives add speed dummy
		scoreboard objectives add wdef_drop dummy
		
		scoreboard objectives add crit_rate dummy
		scoreboard objectives add crit_damage dummy
		scoreboard objectives add addi_crit_rate dummy
		scoreboard objectives add addi_crit_damage dummy
		
		scoreboard objectives add kb dummy
		scoreboard objectives add kb_time dummy
		scoreboard objectives add pushed_time dummy
		scoreboard objectives add freeze_time dummy
		scoreboard objectives add poison_time dummy
		scoreboard objectives add next_poison dummy
		scoreboard objectives add poison_damage dummy
		scoreboard objectives add stun_time dummy
		scoreboard objectives add threat_particle dummy
		scoreboard objectives add queuing_effect dummy
		scoreboard objectives add hit_order dummy
		scoreboard objectives add hit_distance dummy
		scoreboard objectives add action_time dummy
		scoreboard objectives add f_attack_skill dummy
		scoreboard objectives add f_attack_time dummy
		scoreboard objectives add f_attack_weapon dummy
		scoreboard objectives add f_attack_action dummy
		
		scoreboard objectives add action_frame_max dummy
		scoreboard objectives add action_frame dummy
		scoreboard objectives add action_frame_s dummy
		scoreboard objectives add move_frame dummy
		scoreboard objectives add stand_frame dummy
		scoreboard objectives add hurt_sound dummy
		scoreboard objectives add die_sound dummy
		
		scoreboard objectives add target_id dummy
		scoreboard objectives add skill_id dummy
		scoreboard objectives add bullet_targeted dummy
		scoreboard objectives add mob_hp_length dummy
		scoreboard objectives add show_hp_time dummy
		
		scoreboard players set #WORLD_EXP_RATE const 1
		scoreboard players set #WORLD_DROP_RATE const 1
		scoreboard players set #WORLD_MESO_RATE const 1
		```
		for weapon in mastery_weapons:
			print(f"scoreboard objectives add {weapon}_mastery dummy")
			print(f"scoreboard objectives add {weapon}_accuracy dummy")
			print(f"scoreboard objectives add {weapon}_color dummy")
		
		non_skill_attacks = set(["6001001", "6001002", "6001003", "1000006", "3000006"])
		for skill in skill_ids:
			if skill not in non_skill_attacks:
				print(f"scoreboard objectives add {skill}_level dummy")
			print(f"scoreboard objectives add {skill}_eid dummy")
		```
		scoreboard objectives add debuff_count dummy
		scoreboard objectives add blind_time dummy
		scoreboard objectives add seal_time dummy
		
		function ARG(_PATH)buff/install
		function ARG(_PATH)window/install
		function ARG(_PATH)0/install
		function ARG(_PATH)1/install
		function ARG(_PATH)2/install
		function ARG(_PATH)3/install
		function ARG(_PATH)4/install
		# function ARG(_PATH)5/install
	}
	
	folder loop()
	{
		func schedule_1s()
		{
			execute as @e[type=ocelot,tag=!dead] run function ARG(_PATH)enemy
			execute as @a[scores={debuff_count=1..}] at @s run function ARG(__PATH)update_negative/run
		}
		
		func enemy()
		{
			execute if score @s weaken_time matches 1.. run function skill:4/0/0/1002/mob/countdown
			execute if score @s 2101003_time matches 1.. run function skill:2/1/0/1003/mob/countdown
			execute if score @s show_hp_time matches 1.. run function skill:calculate_damage/update_hp_display/countdown
		}
		
		func schedule_1d()
		{
			scoreboard players set #BULLET_ID number 1
			execute as @e[type=zombified_piglin] run data modify entity @s AngerTime set value 2147483647
		}
	}
		
	folder update_negative()
	{
		func run()
		{
			execute if score @s blind_time matches 1.. run function ARG(_PATH)blind/update
			execute if score @s seal_time matches 1.. run function ARG(_PATH)seal/update
			
			execute if score #RESET_DEBUFF temp matches 1.. run function ARG(_PATH)reset
		}
		
		func reset()
		{
			scoreboard players operation #GLOBAL temp = @s number
			execute as @e[type=interaction,tag=player_pos,distance=..12] if score @s number = #GLOBAL temp run function ARG(_PATH)delete_icon
			
			scoreboard players reset #RESET_DEBUFF temp
		}
		
		func delete_icon()
		{
			# bit mask 處理，必須由大到小執行
			execute if score #RESET_DEBUFF temp matches 2.. run function ARG(_PATH)seal/delete_icon
			execute if score #RESET_DEBUFF temp matches 1.. run function ARG(_PATH)blind/delete_icon
		}
		
		folder blind()
		{
			func set_icon()
			{
				data merge entity @s {Tags:["blind"],item:{id:"minecraft:potion",Count:1b,tag:{CustomModelData:100,CustomPotionColor:24}},transformation:{scale:[1.15f,1.15f,1.15f]},billboard:"center"}
				function skill:bind_player
			}
			
			func update()
			{
				scoreboard players remove @s blind_time 1
				execute if score @s blind_time matches 0 run function ARG(_PATH)reset
			}
			
			func reset()
			{
				scoreboard players add #RESET_DEBUFF temp 1
				scoreboard players remove @s debuff_count 1
				scoreboard players reset @s blind_time
			}
			
			func delete_icon()
			{
				scoreboard players remove #RESET_DEBUFF temp 1
				execute on passengers run kill @s[tag=blind]
			}
		}
		
		folder seal()
		{
			func set_icon()
			{
				data merge entity @s {Tags:["seal"],item:{id:"minecraft:potion",Count:1b,tag:{CustomModelData:101,CustomPotionColor:24}},transformation:{scale:[1.6f,1.6f,1.6f]},billboard:"center"}
				function skill:bind_player
			}
			
			func update()
			{
				scoreboard players remove @s seal_time 1
				execute if score @s seal_time matches 0 run function ARG(_PATH)reset
			}
			
			func reset()
			{
				scoreboard players add #RESET_DEBUFF temp 2
				scoreboard players remove @s debuff_count 1
				scoreboard players reset @s seal_time
			}
			
			func delete_icon()
			{
				scoreboard players remove #RESET_DEBUFF temp 2
				execute on passengers run kill @s[tag=seal]
			}
		}
	}
	
	folder main()
	{
		func run()
		{
			execute as @e[type=text_display,scores={type=1}] run function ARG(_PATH)font_effect_update/check
			execute as @e[type=armor_stand,tag=bullet] run function skill:bullet/check
			execute as @e[type=item_display,tag=model_animation] run function ARG(_PATH)model_animation_update
			execute as @e[type=item_display,tag=afterimage] run function skill:afterimage/update
			execute as @e[type=zombie,tag=box,scores={status=1..}] at @s run function skill:6/0/0/1000/box/update
			execute as @e[type=ocelot,scores={spawn_alpha=1..}] run function ARG(_PATH)enemy/run
			execute as @e[type=magma_cube,tag=!original] unless predicate skill:riding_enemy run function main:deep_kill
			
			execute as @a[scores={action_time=1..}] run function ARG(_PATH)action/countdown
			execute as @a[scores={teleport_time=1..}] run function ARG(_PATH)tp_countdown
			execute as @a[tag=delay_tp] at @s run function skill:2/1/0/1002/move/horizon/run
			
			# used skill check
			execute as @a[scores={right_click=1..},tag=!dead] at @s run function skill:check_skill/run
		}
		
		folder font_effect_update()
		{
			func check()
			{
				execute store result score #GLOBAL temp run scoreboard players add @s life 1
				execute if score @s life < @s max_life run function ARG(_PATH)update
				execute if score @s life = @s max_life run kill @s
			}
			
			func update()
			{
				scoreboard players operation #GLOBAL temp %= #10 const
				execute if score #GLOBAL temp matches 0 run data remove entity @s Tags[0]
				
				data modify entity @s text set value '[{"nbt":"Tags[0]","entity":"@s","interpret":true},{"score":{"name":"#GLOBAL","objective":"temp"}}]'
			}
		}
		
		func model_animation_update()
		{
			execute store result score #GLOBAL temp run scoreboard players add @s life 1
			execute store result entity @s item.tag.CustomModelData int 1 run scoreboard players operation #GLOBAL temp += @s base_model
			
			execute if score @s life = @s max_life run kill @s
		}
		
		folder enemy()
		{
			func run()
			{
				# kb_time, push_time 是貓跟豬人同步的，顏色與 status 變更則由貓計算完傳數值給豬人
				scoreboard players set #STATUS temp -1
				
				execute unless score @s kb_time matches 1.. if entity @s[tag=!dead] run function ARG(_PATH)status_change/check
				execute if entity @s[tag=color_changed] run function ARG(_PATH)status_change/color/check
				execute if score @s stun_time matches 1.. run function ARG(_PATH)mob_effect/stun/countdown
				execute if score @s bullet_targeted matches 1.. at @s run function ARG(_PATH)move_bullets

				execute store result score #FACING temp run data get entity @s Rotation[0] 100
				execute on controller run function ARG(_PATH)piglin
				
				execute if score @s kb_time matches 1.. run function ARG(_PATH)kb/countdown
				execute if score @s pushed_time matches 1.. run function ARG(_PATH)push_countdown
			}
			
			func piglin()
			{
				# STATUS temp 先由貓計算結果，然後換豬人來取值
				execute if score #STATUS temp matches 0.. unless score @s status = #STATUS temp run function ARG(_PATH)status_change/change
				execute if score @s action_frame_max matches 2.. unless entity @s[scores={kb_time=1..,status=..3}] run function ARG(_PATH)status_change/update_frame
				
				execute store result entity @s Rotation[0] float 0.01 run scoreboard players get #FACING temp
				data modify entity @s Rotation[1] set value 0.0f
				
				execute if score @s kb_time matches 1.. run function ARG(_PATH)kb/countdown
			}
			
			folder status_change()
			{
				func check()
				{
					execute if data entity @s {OnGround:0b} run function ARG(_PATH)check_jump
					execute if score #STATUS temp matches -1 run function ARG(_PATH)check_motion
					
					execute unless score @s status = #STATUS temp run function ARG(_PATH)ocelot_change
					
					scoreboard players remove @s[tag=!no_jump,scores={status=2..}] rand_jump 1
					execute if score @s rand_jump matches 0 run function ARG(_PATH)force_jump/try
				}

				func ocelot_change()
				{
					execute if score @s[tag=ldpq_eye] status matches 1 run function quest:party_quest/ldpq/stages/4/eyes/face_after_hit
					scoreboard players set @s[tag=!no_jump] rand_jump 20
					scoreboard players operation @s status = #STATUS temp
				}
				
				folder force_jump()
				{
					func try()
					{
						scoreboard players set @s rand_jump 20
						execute unless score @s stun_time matches 1.. run function ARG(_PATH)case
					}
					
					func case()
					{
						execute unless score @s anger_time matches 1.. run function ARG(_PATH)rand_jump
						execute if entity @s[scores={anger_time=1..,status=3}] store result entity @s Motion[1] double 0.1 run scoreboard players get #5 const
					}
				
					func rand_jump()
					{
						function random:rand_rate
						execute if score #RAND_RESULT number matches ..9 store result entity @s Motion[1] double 0.1 run scoreboard players get #5 const
					}
				}
				
				func check_jump()
				{
					scoreboard players set #STATUS temp 0
					execute if entity @s[tag=no_jump] run function ARG(_PATH)prevent_jump
				}
				
				func prevent_jump()
				{
					execute store result score @s motion_y run data get entity @s Motion[1] 100
					execute if score @s motion_y matches 1.. run data modify entity @s Motion[1] set value 0.0
					scoreboard players set #STATUS temp -1
				}
				
				func check_motion()
				{
					execute store result score @s motion_x run data get entity @s Motion[0] 100
					execute store result score @s motion_z run data get entity @s Motion[2] 100
					scoreboard players set #STATUS temp 2
					execute if score @s motion_x matches 0 if score @s motion_z matches 0 run scoreboard players add #STATUS temp 1
				}
				
				func update_frame()
				{
					scoreboard players add @s action_frame 1
					execute if score @s action_frame = @s action_frame_max run function ARG(_PATH)loop_frame
					
					scoreboard players operation #STATUS temp = @s base_model
					scoreboard players operation #STATUS temp += @s action_frame_s
					execute store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players operation #STATUS temp += @s action_frame
					
					# 眼睛特殊處理
					execute if predicate skill:close_eye unless entity @s[tag=close_eye] run function quest:party_quest/ldpq/stages/4/eyes/close
					execute unless predicate skill:close_eye if entity @s[tag=close_eye] run function quest:party_quest/ldpq/stages/4/eyes/open
				}
				
				func loop_frame()
				{
					scoreboard players set @s action_frame 0
					# 技能動作播完如果還在 kb_time 則改播移動動作
					execute if score @s status matches 4.. run scoreboard players set @s action_frame_s 2
				}
				
				func change()
				{
					scoreboard players reset @s action_frame_max
					scoreboard players set @s action_frame_s 2
					execute if score #STATUS temp matches 2 if score @s move_frame matches 2.. run scoreboard players operation @s action_frame_max = @s move_frame
					execute if score #STATUS temp matches 3 if score @s stand_frame matches 2.. run scoreboard players operation @s action_frame_s += @s move_frame
					execute if score #STATUS temp matches 3 if score @s stand_frame matches 2.. run scoreboard players operation @s action_frame_max = @s stand_frame
					scoreboard players set @s action_frame -1
					
					scoreboard players operation @s status = #STATUS temp
					execute unless score @s action_frame_max matches 2.. store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players operation #STATUS temp += @s base_model
				}
				
				folder color()
				{
					func check()
					{
						execute if score @s freeze_time matches 1.. run function ARG(_PATH)freeze/run
						execute if score @s poison_time matches 1.. at @s run function ARG(_PATH)poison/run
						
						```
						raise Warning("TODO: check all other color change effects")
						```
						# execute unless score @s freeze_time matches 1.. unless score @s poison_time matches 1.. unless score @s burn_time matches 1.. run tag @s remove color_changed
						execute unless score @s freeze_time matches 1.. unless score @s poison_time matches 1.. run tag @s remove color_changed
						execute if entity @s[tag=!color_changed] on controller run data modify entity @s ArmorItems[3].tag.CustomPotionColor set value -1
					}
					
					func other_color_check()
					{
						scoreboard players set #GLOBAL temp 0
						execute if score @s freeze_time matches 1.. run scoreboard players set #GLOBAL temp 1
						execute if score @s poison_time matches 1.. run scoreboard players set #GLOBAL temp 2
						
						execute if score #GLOBAL temp matches 1 on controller run function skill:mob_effect/debuff/freeze_color
						execute if score #GLOBAL temp matches 2 on controller run function skill:mob_effect/debuff/poison_color
					}
					
					folder freeze()
					{
						func run()
						{
							scoreboard players remove @s freeze_time 1
							execute if score @s freeze_time matches 0 run function ARG(_PATH)reset
							
						}
						
						func reset()
						{
							scoreboard players reset @s freeze_time
							function ARG(__PATH)other_color_check
						}
					}
					
					folder poison()
					{
						func run()
						{
							scoreboard players remove @s next_poison 1
							execute if score @s next_poison matches 0 run function ARG(_PATH)next
						}
						
						func next()
						{
							scoreboard players remove @s poison_time 1
							scoreboard players set @s next_poison 20
							
							execute if entity @s[tag=!dead] run function ARG(_PATH)damage
							
							execute if score @s poison_time matches 0 run function ARG(_PATH)reset
						}
						
						func damage()
						{
							function skill:mob_effect/play_hurt_sound/run
							
							scoreboard players operation @s hp -= @s poison_damage
							scoreboard players operation @s hp > #1 const
							
							scoreboard players set #SILENT_UPDATE_HP temp 1
							function skill:calculate_damage/update_hp_display/run
							
							scoreboard players operation @s display_number = @s poison_damage
							scoreboard players set @s display_num_type 0
							scoreboard players operation #NUMBER_HEIGHT temp = @s default_height
							execute positioned ~ ~-0.4 ~ run function skill:show_num_at_height
							
							scoreboard players set @s[scores={hp=1}] poison_time 0
						}
						
						func reset()
						{
							scoreboard players reset @s next_poison
							scoreboard players reset @s poison_time
							execute on passengers run kill @s[type=item_display,tag=poison]
							function ARG(__PATH)other_color_check
						}
					}
				}
			}
			
			folder kb()
			{
				func countdown()
				{
					scoreboard players remove @s kb_time 1
					execute if score @s kb_time matches 0 run function ARG(_PATH)reset
				}
			
				func reset()
				{
					# 眼睛特殊處理，不需要豬人 AI 所以讓他保持 NoAI
					data modify entity @s[tag=!ldpq_eye] NoAI set value 0b
					scoreboard players reset @s kb_time
				}
			}
			
			func push_countdown()
			{
				scoreboard players remove @s pushed_time 1
				scoreboard players reset @s[scores={pushed_time=0}] pushed_time
				
				# 順便做懸崖檢查
				execute at @s[tag=!fly_enemy] rotated ~ 0 if block ^ ^-1 ^-1 #skill:passable run function ARG(_PATH)cliff_stop
			}

			func cliff_stop()
			{
				tp @s ^ ^0.2 ^0.7
				execute positioned as @s unless block ~ ~-1 ~ #skill:passable run data modify entity @s Motion set value [0.0,0.0,0.0]
				execute positioned as @s run function ARG(_PATH)force_land
			}

			func force_land()
			{
				execute unless block ~ ~-1 ~ #skill:passable align y run tp @s ~ ~0.1 ~
				execute if block ~ ~-1 ~ #skill:passable positioned ~ ~-1 ~ run function ARG(_PATH)force_land
			}
			
			folder mob_effect()
			{
				folder stun()
				{
					func countdown()
					{
						scoreboard players remove @s stun_time 1
						execute if score @s stun_time matches 0 run function ARG(_PATH)reset
					}
					
					func reset()
					{
						scoreboard players reset @s stun_time
						
						execute on passengers run kill @s[type=item_display,tag=stun]
						attribute @s minecraft:generic.movement_speed modifier remove 98fb435b-7645-4b76-8504-ee4f9e13fdec
					}
				}
			}
			
			func move_bullets()
			{
				scoreboard players set #HIT_BULLET temp 0
				scoreboard players operation #GLOBAL temp = @s number
				execute as @e[type=armor_stand,tag=bullet,scores={life=0..}] if score @s target_id = #GLOBAL temp run function skill:bullet/move
				scoreboard players operation @s bullet_targeted -= #HIT_BULLET temp
			}
		}
		
		folder action()
		{
			func countdown()
			{
				execute if score @s f_attack_time matches 1.. run function ARG(_PATH)final_attack/countdown
				scoreboard players remove @s action_time 1
				execute if score @s action_time matches 0 run function ARG(_PATH)reset
			}
			
			func reset()
			{
				attribute @s minecraft:generic.movement_speed modifier remove 5b908c48-54cb-4388-aa76-82f61b02032d
				effect clear @s minecraft:jump_boost
				execute if score @s jump_buff_num matches 1 run effect give @s minecraft:jump_boost infinite 0 true
				execute if score @s jump_buff_num matches 2 run effect give @s minecraft:jump_boost infinite 1 true
				scoreboard players reset @s action_time
			}
			
			folder final_attack()
			{
				func countdown()
				{
					scoreboard players remove @s f_attack_time 1
					execute if score @s f_attack_time matches 0 at @s run function ARG(_PATH)check
				}
				
				func check()
				{
					execute if score @s f_attack_weapon matches 5..14 run function skill:1/0/0/0006/pre_set
					execute if score @s f_attack_weapon matches 16..18 run function skill:3/0/0/0006/pre_set
					scoreboard players reset @s f_attack_time
				}
			}
		}
		
		func tp_countdown()
		{
			scoreboard players remove @s teleport_time 1
			scoreboard players reset @s[scores={teleport_time=0}] teleport_time
		}
	}
	
	func use_constraint()
	{
		# basic skill constraints
		scoreboard players operation @s next_hp_recover = @s hp_recover_time
		attribute @s minecraft:generic.movement_speed modifier add 5b908c48-54cb-4388-aa76-82f61b02032d skill_action -0.95 multiply
		effect give @s minecraft:jump_boost infinite 128 true
	}
	
	func hunt_exp()
	{
		```
		raise Warning("TODO: holy symbol rate calculation")
		```
		scoreboard players operation #EXP_GAIN temp *= #WORLD_EXP_RATE const
		execute if score @s level matches ..199 run scoreboard players operation @s exp += #EXP_GAIN temp
		scoreboard players reset #EXP_GAIN temp
		execute if score @s exp < @s exp_max run tag @s add hp_mp_varying
		execute if score @s exp >= @s exp_max run function stat:exp/level_up
	}
	
	folder player()
	{
		func reset_mastery()
		{
			```
			for weapon in mastery_weapons:
				print(f"scoreboard players set @s {weapon}_mastery 10")
				print(f"scoreboard players set @s {weapon}_color 255")
				print(f"scoreboard players set @s {weapon}_accuracy 0")
			```
		}
	
		func reset_all_skill()
		{
			scoreboard players reset @s 0001000_level
			scoreboard players reset @s 0001001_level
			scoreboard players reset @s 0001002_level
			scoreboard players set @s hp_recovery 10
			scoreboard players reset @s 1000000_level
			scoreboard players set @s addi_hp_level 0
			scoreboard players set @s addi_hp_point 0
			scoreboard players reset @s 1000001_level
			scoreboard players set @s hp_recover_time 10
			scoreboard players reset @s 1000002_level
			scoreboard players reset @s 1001003_level
			scoreboard players reset @s 1001004_level
			scoreboard players reset @s 1001005_level
			scoreboard players set @s mp_recovery 3
			scoreboard players reset @s 2000000_level
			scoreboard players set @s addi_mp_level 0
			scoreboard players set @s addi_mp_point 0
			scoreboard players reset @s 2000001_level
			scoreboard players reset @s 2001002_level
			scoreboard players reset @s 2001003_level
			scoreboard players reset @s 2001004_level
			scoreboard players reset @s 2001005_level
			scoreboard players set @s base_accuracy 0
			scoreboard players reset @s 3000000_level
			scoreboard players set @s crit_rate 0
			scoreboard players set @s crit_damage 0
			scoreboard players reset @s 3000001_level
			scoreboard players set @s amazon_eyes_dist 9
			scoreboard players reset @s 3000002_level
			scoreboard players reset @s 3001003_level
			scoreboard players reset @s 3001004_level
			scoreboard players reset @s 3001005_level
			scoreboard players set @s base_avoid 0
			scoreboard players reset @s 4000000_level
			scoreboard players set @s keen_eyes_dist 6
			scoreboard players reset @s 4000001_level
			scoreboard players reset @s 4001002_level
			scoreboard players reset @s 4001003_level
			scoreboard players reset @s 4001334_level
			scoreboard players reset @s 4001344_level
			
			function ARG(_PATH)reset_mastery
			scoreboard players reset @s 1100000_level
			scoreboard players reset @s 1100001_level
			scoreboard players set @s sword_final_rate 0
			scoreboard players reset @s 1100002_level
			scoreboard players set @s axe_final_rate 0
			scoreboard players reset @s 1100003_level
			scoreboard players reset @s 1101004_level
			scoreboard players reset @s 1101005_level
			scoreboard players reset @s 1101006_level
			scoreboard players reset @s 1101007_level
			scoreboard players reset @s 1200001_level
			scoreboard players set @s blunt_final_rate 0
			scoreboard players reset @s 1200003_level
			scoreboard players reset @s 1201005_level
			scoreboard players reset @s 1201006_level
			scoreboard players reset @s 1300000_level
			scoreboard players reset @s 1300001_level
			scoreboard players set @s spear_final_rate 0
			scoreboard players reset @s 1300002_level
			scoreboard players set @s p_arm_final_rate 0
			scoreboard players reset @s 1300003_level
			scoreboard players reset @s 1301004_level
			scoreboard players reset @s 1301005_level
			scoreboard players reset @s 1301006_level
			scoreboard players reset @s 1301007_level
			scoreboard players set @s 2100000_rate 0
			scoreboard players reset @s 2100000_level
			scoreboard players reset @s 2101001_level
			scoreboard players reset @s 2101002_level
			scoreboard players reset @s 2101003_level
			scoreboard players reset @s 2101004_level
			scoreboard players reset @s 2101005_level
			scoreboard players reset @s 2201004_level
			scoreboard players reset @s 2201005_level
			scoreboard players reset @s 2301002_level
			scoreboard players reset @s 2301003_level
			scoreboard players reset @s 2301004_level
			scoreboard players reset @s 2301005_level
			scoreboard players reset @s 3100000_level
			scoreboard players set @s bow_final_rate 0
			scoreboard players reset @s 3100001_level
			scoreboard players reset @s 3101002_level
			scoreboard players reset @s 3101003_level
			scoreboard players reset @s 3101004_level
			scoreboard players reset @s 3101005_level
			scoreboard players reset @s 3200000_level
			scoreboard players set @s cbow_final_rate 0
			scoreboard players reset @s 3200001_level
			scoreboard players reset @s 3201002_level
			scoreboard players reset @s 3201005_level
			scoreboard players reset @s 4100000_level
			scoreboard players reset @s 4100001_level
			scoreboard players reset @s 4100002_level
			scoreboard players reset @s 4101003_level
			scoreboard players reset @s 4101004_level
			scoreboard players reset @s 4101005_level
			scoreboard players reset @s 4200000_level
			scoreboard players reset @s 4201002_level
			scoreboard players reset @s 4201004_level
			scoreboard players reset @s 4201005_level
		}
	}
	
	folder bullet()
	{
		func setting()
		{
			execute facing entity @s eyes positioned as @s run tp @s ~ ~ ~ ~180 0
			scoreboard players add #BULLET_AMOUNT temp 1
			
			scoreboard players operation @s number = #BULLET_ID number
			scoreboard players operation @s target_id = #GLOBAL temp
			execute store result score @s life run data get entity @s ArmorItems[3].tag.appear_delay -1
			execute store result score @s skill_id run data get entity @s ArmorItems[3].tag.skill_id
			tag @s remove new_bullet
		}
		
		func no_target_setting()
		{
			execute positioned as @s run tp @s ~ ~ ~ ~ 0
			execute store result score @s life run data get entity @s ArmorItems[3].tag.appear_delay -1
			execute store result score @s max_life run data get entity @s ArmorItems[3].tag.max_distance
			tag @s remove new_bullet
		}
		
		func check()
		{
			scoreboard players add @s life 1
			execute if score @s life matches 0 run function ARG(_PATH)appear
			# no target bullet
			execute if score @s life matches 0.. unless score @s target_id matches -2147483648.. at @s run function ARG(_PATH)wander
		}
		
		func appear()
		{
			data modify entity @s ArmorItems[3].tag.CustomModelData set from entity @s ArmorItems[3].tag.bullet_model
			data modify entity @s CustomNameVisible set value 1
		}
		
		func wander()
		{
			execute if score @s life > @s max_life run kill @s
			tp @s ^ ^ ^0.8
		}
		
		func move()
		{
			execute if entity @s[distance=..0.8] run function ARG(_PATH)hit
			execute facing entity @s eyes positioned as @s run tp @s ^ ^ ^-0.8
		}
		
		func hit()
		{
			execute if entity @s[tag=first_bullet] run function ARG(_PATH)append_scheduler
			scoreboard players add #HIT_BULLET temp 1
			kill @s
		}
		
		func append_scheduler()
		{
			scoreboard players operation #BULLET_ID temp = @s number
			data modify storage skill:main new_schedule set value []
			function ARG(_PATH)find_parent_skill/run
		}
		
		folder find_parent_skill()
		{
			```
			def bs_bullet_skill(id_list, start, end):
				if len(id_list) == 1:
					print("func run()")
					print("{")
					print(f"\texecute if score @s skill_id matches {id_list[0][1]} run function skill:{id_list[0][0][0]}/{id_list[0][0][1]}/{id_list[0][0][2]}/{id_list[0][0][3:]}/append_scheduler")
					print(f"\texecute if score @s skill_id matches {id_list[0][1]} as @e[type=ocelot] if score @s number = #GLOBAL temp run function skill:{id_list[0][0][0]}/{id_list[0][0][1]}/{id_list[0][0][2]}/{id_list[0][0][3:]}/bullet_hit/run")
					print("}")
					return
				
				if start == end:
					return
				
				mid = (start + end) // 2
				mid_right = mid + 1
				
				if start == 0 and end == len(id_list) - 1:
					print("func run()")
				else:
					print(f"func {start}_{end}()")
				print("{")
				if start == mid:
					print(f"\texecute if score @s skill_id matches {id_list[start][1]} run function skill:{id_list[start][0][0]}/{id_list[start][0][1]}/{id_list[start][0][2]}/{id_list[start][0][3:]}/append_scheduler")
					print(f"\texecute if score @s skill_id matches {id_list[start][1]} as @e[type=ocelot] if score @s number = #GLOBAL temp run function skill:{id_list[start][0][0]}/{id_list[start][0][1]}/{id_list[start][0][2]}/{id_list[start][0][3:]}/bullet_hit/run")
				else:
					print(f"\texecute if score @s skill_id matches {id_list[start][1]}..{id_list[mid][1]} run function ARG(_PATH){start}_{mid}")
				if mid_right == end:
					print(f"\texecute if score @s skill_id matches {id_list[end][1]} run function skill:{id_list[end][0][0]}/{id_list[end][0][1]}/{id_list[end][0][2]}/{id_list[end][0][3:]}/append_scheduler")
					print(f"\texecute if score @s skill_id matches {id_list[end][1]} as @e[type=ocelot] if score @s number = #GLOBAL temp run function skill:{id_list[end][0][0]}/{id_list[end][0][1]}/{id_list[end][0][2]}/{id_list[end][0][3:]}/bullet_hit/run")
				else:
					print(f"\texecute if score @s skill_id matches {id_list[mid_right][1]}..{id_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
				print("}")
				
				bs_bullet_skill(id_list, start, mid)
				bs_bullet_skill(id_list, mid_right, end)
			
			with open(PROJ_DIR + "/../skill_bullet_ids.csv") as f:
				skill_bullet_ids = f.read().split("\n")
				for i in range(len(skill_bullet_ids)):
					skill_bullet_ids[i] = skill_bullet_ids[i].split(",")
					skill_bullet_ids[i][1] = int(skill_bullet_ids[i][1])
			
			bs_bullet_skill(skill_bullet_ids, 0, len(skill_bullet_ids) - 1)
			```
		}
	}
	
	folder check_skill()
	{
		func run()
		{
			# 快捷施放技能
			execute if score @s skill_id matches 1.. run scoreboard players operation #USING_SKILL temp = @s skill_id
			execute unless score @s skill_id matches 1.. store result score #USING_SKILL temp run data get entity @s[predicate=skill:use_carrot] SelectedItem.tag.CustomModelData
			
			execute if score @s seal_time matches 0.. unless score #USING_SKILL temp matches 199 run scoreboard players reset #USING_SKILL temp
			execute if score #USING_SKILL temp matches 1.. run function ARG(_PATH)binary_search/run
			scoreboard players reset @s right_click
			scoreboard players reset @s skill_id
		}
		
		folder binary_search()
		{
			```
			def binary_search_skill(skill_list, start, end):
				if len(skill_list) == 1:
					print("func run()")
					print("{")
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[0][1]} run function skill:{skill_list[0][0][0]}/{skill_list[0][0][1]}/{skill_list[0][0][2]}/{skill_list[0][0][3:]}/check")
					print("}")
					return
				
				if start == end:
					return
				
				mid = (start + end) // 2
				mid_right = mid + 1
				
				if start == 0 and end == len(skill_list) - 1:
					print("func run()")
				else:
					print(f"func {start}_{end}()")
				print("{")
				if start == mid:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[start][1]} run function skill:{skill_list[start][0][0]}/{skill_list[start][0][1]}/{skill_list[start][0][2]}/{skill_list[start][0][3:]}/check")
				else:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[start][1]}..{skill_list[mid][1]} run function ARG(_PATH){start}_{mid}")
				if mid_right == end:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[end][1]} run function skill:{skill_list[end][0][0]}/{skill_list[end][0][1]}/{skill_list[end][0][2]}/{skill_list[end][0][3:]}/check")
				else:
					print(f"\texecute if score #USING_SKILL temp matches {skill_list[mid_right][1]}..{skill_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
				print("}")
				
				binary_search_skill(skill_list, start, mid)
				binary_search_skill(skill_list, mid_right, end)
			
			with open(PROJ_DIR + "/../skill_icons.csv") as f:
				skill_models = f.read().split("\n")
				for i in range(len(skill_models)):
					skill_models[i] = skill_models[i].split(",")
					skill_models[i][1] = int(skill_models[i][1])
			
			binary_search_skill(skill_models, 0, len(skill_models) - 1)
			```
		}
	}
	
	folder check_weapon()
	{
		func check_empty()
		{
			scoreboard players set #ACCEPTED_WEAPON temp 0
			
			scoreboard players operation #USED_WEAPON temp = @s weapon_type
			execute if score #USED_WEAPON temp matches 0 run tellraw @s {"translate":"warning.skill.no_weapon","font":"minecraft:uniform","color":"#efb7ab"}
		}
		
		folder single_hand()
		{
			func run()
			{
				function ARG(__PATH)check_empty
				execute if score #USED_WEAPON temp matches 1.. run function ARG(_PATH)check
			}
			
			func check()
			{
				scoreboard players operation #ACCEPTED_WEAPON temp = #USED_WEAPON temp
				scoreboard players operation #ACCEPTED_WEAPON temp %= #2 const
				execute if score #ACCEPTED_WEAPON temp matches 0 run tellraw @s {"translate":"warning.skill.wrong_weapon","font":"minecraft:uniform","color":"#efb7ab"}
			}
		}
		
		```
		def check_weapon_range(range_string):
			print(f'''
			func run()
			{{
				function ARG(__PATH)check_empty
				execute if score #USED_WEAPON temp matches 1.. run function ARG(_PATH)check
			}}
			
			func check()
			{{
				execute store success score #ACCEPTED_WEAPON temp if score #USED_WEAPON temp matches {range_string}
				execute if score #ACCEPTED_WEAPON temp matches 0 run tellraw @s {{"translate":"warning.skill.wrong_weapon","font":"minecraft:uniform","color":"#efb7ab"}}
			}}''')
		
		type_id_dict = {
			"dagger": "23",
			"claw": "24",
			"archer": "16..18",
			"bow": "16",
			"crossbow": "18",
			"sword": "7..8",
			"axe": "5..6",
			"blunt": "9..10",
			"spear": "12",
			"polearm": "14"
		} # to avoid single bracelet in a line
		
		for t in type_id_dict:
			print(f"folder {t}()")
			print("{")
			check_weapon_range(type_id_dict[t])
			print("}")
		```
	}

	folder enemy_search()
	{
		func clear()
		{
			tag @s remove first_target
			tag @s remove target
		}
		
		func check_weapon_distance()
		{
			scoreboard players operation #DISTANCE temp = #USED_WEAPON temp
			# make single hand weapon %2 be 0
			scoreboard players add #DISTANCE temp 1
			scoreboard players operation #DISTANCE temp %= #2 const
			scoreboard players add #DISTANCE temp 2
			execute if score #USED_WEAPON temp matches 12..14 run scoreboard players add #DISTANCE temp 1
		}
		
		folder search_front() from for_loop().for("#DISTANCE temp", "if score #FOUND_ENEMY temp < #MAX_ENEMY temp positioned ^ ^ ^0.8")
		{
			func search()
			{
				scoreboard players reset #FIRST_DISTANCE temp
				scoreboard players set #CUR_DISTANCE temp 0
				scoreboard players set #FOUND_ENEMY temp 0
				```
				print("execute at @s rotated ~ 0 positioned ^ ^ ^100 run summon minecraft:marker ~ ~ ~ {UUID:%s}" %UUID_LIST["search"])
				```
				execute at @s rotated ~ 0 positioned ^ ^ ^-1.8 run function ARG(_PATH)run
				tag @e[type=interaction,tag=target] remove target
				kill 00000000-0000-0003-0000-000000000003
			}
			
			func execute()
			{
				# simulating sector detection, larger y axis detection on further distance
				execute if score #CUR_DISTANCE temp matches 5.. positioned ~-1.8 ~-1.2 ~-1.8 as @e[type=interaction,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=3.175,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				execute unless score #CUR_DISTANCE temp matches 5.. run function ARG(_PATH)check_height
				scoreboard players add #CUR_DISTANCE temp 1
			}
			
			func check_height()
			{
				execute if score #SEARCH_HEIGHT temp matches 0 positioned ~-1.8 ~-0.3 ~-1.8 as @e[type=interaction,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=1.575,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				execute if score #SEARCH_HEIGHT temp matches 1 positioned ~-1.8 ~-0.3 ~-1.8 as @e[type=interaction,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=2.375,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				execute if score #SEARCH_HEIGHT temp matches 2 positioned ~-1.8 ~-0.3 ~-1.8 as @e[type=interaction,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=3.175,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
			}
			
			func try_mark()
			{
				execute unless score #FIRST_DISTANCE temp matches 0.. run scoreboard players operation #FIRST_DISTANCE temp = #CUR_DISTANCE temp
				execute if score #FOUND_ENEMY temp < #MAX_ENEMY temp run function ARG(_PATH)mark
			}
			
			func mark()
			{
				execute on vehicle run tag @s add target
				tag @s add target
				scoreboard players add #FOUND_ENEMY temp 1
			}
		}
		
		folder search_front_pure_order() from for_loop().for("#DISTANCE temp", "if score #FOUND_ENEMY temp < #MAX_ENEMY temp positioned ^ ^ ^0.8")
		{
			func search()
			{
				scoreboard players set #CUR_DISTANCE temp 0
				scoreboard players set #FOUND_ENEMY temp 0
				data modify storage skill:main temp set value []
				```
				print("execute at @s rotated ~ 0 positioned ^ ^ ^100 run summon minecraft:marker ~ ~ ~ {UUID:%s}" %UUID_LIST["search"])
				```
				execute at @s rotated ~ 0 positioned ^ ^ ^-1.8 run function ARG(_PATH)run
				tag @e[type=interaction,tag=target] remove target
				kill 00000000-0000-0003-0000-000000000003
			}
			
			func execute()
			{
				# simulating sector detection, larger y axis detection on further distance
				execute if score #CUR_DISTANCE temp matches 5.. positioned ~-1.8 ~-1.2 ~-1.8 as @e[type=interaction,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=3.175,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				execute unless score #CUR_DISTANCE temp matches 5.. run function ARG(_PATH)check_height
				scoreboard players add #CUR_DISTANCE temp 1
			}
			
			func check_height()
			{
				execute if score #SEARCH_HEIGHT temp matches 0 positioned ~-1.8 ~-0.3 ~-1.8 as @e[type=interaction,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=1.575,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				execute if score #SEARCH_HEIGHT temp matches 1 positioned ~-1.8 ~-0.3 ~-1.8 as @e[type=interaction,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=2.375,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				execute if score #SEARCH_HEIGHT temp matches 2 positioned ~-1.8 ~-0.3 ~-1.8 as @e[type=interaction,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=3.175,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
			}
			
			func try_mark()
			{
				execute if score #FOUND_ENEMY temp < #MAX_ENEMY temp run function ARG(_PATH)mark_owner
			}
			
			func mark_owner()
			{
				execute on vehicle run function ARG(_PATH)mark
				tag @s add target
			}
			
			func mark()
			{
				execute if score #FOUND_ENEMY temp matches ..4 run function ARG(_PATH)record_dists
				
				tag @s add target
				execute store result score @s hit_distance run scoreboard players operation @s hit_order = #FOUND_ENEMY temp
				scoreboard players remove @s[scores={hit_distance=5}] hit_distance 1
				scoreboard players add #FOUND_ENEMY temp 1
			}
			
			func record_dists()
			{
				data modify storage skill:main temp append value 0
				execute store result storage skill:main temp[-1] int 1 run scoreboard players get #FOUND_ENEMY temp
			}
		}
		
		folder search_front_rec_dist() from for_loop().for("#DISTANCE temp", "if score #FOUND_ENEMY temp < #MAX_ENEMY temp positioned ^ ^ ^0.8")
		{
			func search()
			{
				scoreboard players reset #FIRST_DISTANCE temp
				scoreboard players set #CUR_DISTANCE temp 0
				scoreboard players set #GLOBAL hit_distance -1
				scoreboard players set #FOUND_ENEMY temp 0
				data modify storage skill:main temp set value []
				```
				print("execute at @s rotated ~ 0 positioned ^ ^ ^100 run summon minecraft:marker ~ ~ ~ {UUID:%s}" %UUID_LIST["search"])
				```
				execute at @s rotated ~ 0 positioned ^ ^ ^-1.8 run function ARG(_PATH)run
				tag @e[type=interaction,tag=target] remove target
				kill 00000000-0000-0003-0000-000000000003
			}
			
			func execute()
			{
				# simulating sector detection, larger y axis detection on further distance
				execute if score #CUR_DISTANCE temp matches 5.. positioned ~-1.8 ~-1.2 ~-1.8 as @e[type=interaction,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=3.175,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				execute unless score #CUR_DISTANCE temp matches 5.. run function ARG(_PATH)check_height
				scoreboard players add #CUR_DISTANCE temp 1
			}
			
			func check_height()
			{
				execute if score #SEARCH_HEIGHT temp matches 0 positioned ~-1.8 ~-0.3 ~-1.8 as @e[type=interaction,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=1.575,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				execute if score #SEARCH_HEIGHT temp matches 1 positioned ~-1.8 ~-0.3 ~-1.8 as @e[type=interaction,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=2.375,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
				execute if score #SEARCH_HEIGHT temp matches 2 positioned ~-1.8 ~-0.3 ~-1.8 as @e[type=interaction,tag=enemy,tag=!target,tag=!dead,dx=2.6,dy=3.175,dz=2.6] positioned as 00000000-0000-0003-0000-000000000003 unless entity @s[distance=100.2..] run function ARG(_PATH)try_mark
			}
			
			func record_first()
			{
				scoreboard players operation #FIRST_DISTANCE temp = #CUR_DISTANCE temp
				tag @s add first_target
			}
			
			func try_mark()
			{
				execute if score #FOUND_ENEMY temp < #MAX_ENEMY temp run function ARG(_PATH)mark_owner
			}
			
			func mark_owner()
			{
				execute on vehicle run function ARG(_PATH)mark
				tag @s add target
			}
			
			func mark()
			{
				execute unless score #FIRST_DISTANCE temp matches 0.. run function ARG(_PATH)record_first
				execute if score #GLOBAL hit_distance < #CUR_DISTANCE temp run function ARG(_PATH)record_dists
				
				tag @s add target
				scoreboard players operation @s hit_distance = #CUR_DISTANCE temp
				scoreboard players operation @s hit_order = #FOUND_ENEMY temp
				scoreboard players add #FOUND_ENEMY temp 1
			}
			
			func record_dists()
			{
				data modify storage skill:main temp append value 0
				execute store result storage skill:main temp[-1] int 1 run scoreboard players get #CUR_DISTANCE temp
				scoreboard players operation #GLOBAL hit_distance = #CUR_DISTANCE temp
			}
		}
	}
	
	folder damage_formula()
	{
		func spell()
		{
			# magic attack
			scoreboard players operation #MAGIC_ATTACK temp = @s weapon_mattack
			scoreboard players operation #MAGIC_ATTACK temp += @s matk_buff_num
			
			scoreboard players operation #MAGIC_ATTACK temp += @s INT
			scoreboard players operation #INT temp = @s INT
			scoreboard players operation #INT temp *= #5 const
			
			scoreboard players operation #MAX_DAMAGE temp = #MAGIC_ATTACK temp
			scoreboard players operation #MAX_DAMAGE temp *= #MAGIC_ATTACK temp
			scoreboard players operation #MAGIC_ATTACK temp *= #1000 const
			scoreboard players operation #MAX_DAMAGE temp += #MAGIC_ATTACK temp
			
			scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
			scoreboard players operation #MIN_DAMAGE temp *= #9 const
			scoreboard players operation #MIN_DAMAGE temp *= #SKILL_MASTERY temp
			scoreboard players operation #MIN_DAMAGE temp /= #1000 const
			
			scoreboard players operation #MAX_DAMAGE temp /= #30 const
			scoreboard players operation #MAX_DAMAGE temp += #INT temp
			scoreboard players operation #MAX_DAMAGE temp *= #SPELL_ATTACK temp
			scoreboard players operation #MAX_DAMAGE temp /= #1000 const
			
			scoreboard players operation #MIN_DAMAGE temp /= #30 const
			scoreboard players operation #MIN_DAMAGE temp += #INT temp
			scoreboard players operation #MIN_DAMAGE temp *= #SPELL_ATTACK temp
			scoreboard players operation #MIN_DAMAGE temp /= #1000 const
			
			# accuracy
			scoreboard players operation #INT temp /= #50 const
			scoreboard players operation #ACCURACY temp = @s LUK
			scoreboard players operation #ACCURACY temp /= #10 const
			scoreboard players operation #ACCURACY temp += #INT temp
			
			# write values
			execute store result storage skill:main damage[0].max_damage int 1 run scoreboard players get #MAX_DAMAGE temp
			execute store result storage skill:main damage[0].min_damage int 1 run scoreboard players get #MIN_DAMAGE temp
			execute store result storage skill:main damage[0].accuracy int 1 run scoreboard players get #ACCURACY temp
			execute store result storage skill:main damage[0].player_level int 1 run scoreboard players get @s level
			execute store result storage skill:main damage[0].crit_rate int 1 run scoreboard players get @s addi_crit_rate
			execute store result storage skill:main damage[0].crit_damage int 1 run scoreboard players get @s addi_crit_damage
		}
		
		func heal()
		{
			# target multiplier
			scoreboard players set #MULTIPLIER temp 500
			scoreboard players operation #MULTIPLIER temp /= #FOUND_ENEMY temp
			scoreboard players add #MULTIPLIER temp 150
			
			# magic attack
			scoreboard players operation #MAGIC_ATTACK temp = @s weapon_mattack
			scoreboard players operation #MAGIC_ATTACK temp += @s matk_buff_num
			
			scoreboard players operation #MAGIC_ATTACK temp += @s INT
			scoreboard players operation #MAGIC_ATTACK temp *= @s 2301002_level
			scoreboard players operation #MAGIC_ATTACK temp *= #MULTIPLIER temp
			scoreboard players operation #MAGIC_ATTACK temp /= #100 const
			
			scoreboard players operation #MIN_DAMAGE temp = @s INT
			scoreboard players operation #MIN_DAMAGE temp *= #3 const
			
			scoreboard players operation #MAX_DAMAGE temp = #MIN_DAMAGE temp
			scoreboard players operation #MAX_DAMAGE temp *= #4 const
			
			scoreboard players operation #MIN_DAMAGE temp /= #10 const
			scoreboard players operation #MIN_DAMAGE temp += @s LUK
			scoreboard players operation #MIN_DAMAGE temp *= #MAGIC_ATTACK temp
			scoreboard players operation #MIN_DAMAGE temp /= #10000 const
			
			scoreboard players operation #MAX_DAMAGE temp /= #10 const
			scoreboard players operation #MAX_DAMAGE temp += @s LUK
			scoreboard players operation #MAX_DAMAGE temp *= #MAGIC_ATTACK temp
			scoreboard players operation #MAX_DAMAGE temp /= #10000 const
			
			# recovery amount
			scoreboard players operation #MAX_HEAL_AMOUNT temp = #MAGIC_ATTACK temp
			scoreboard players operation #MAX_HEAL_AMOUNT temp *= #3 const
			scoreboard players operation #MAX_HEAL_AMOUNT temp /= #40 const
			
			scoreboard players operation #MIN_HEAL_AMOUNT temp = #MAGIC_ATTACK temp
			scoreboard players operation #MIN_HEAL_AMOUNT temp *= #45 const
			scoreboard players operation #MIN_HEAL_AMOUNT temp /= #1000 const
			
			# accuracy
			scoreboard players operation #INT temp = @s INT
			scoreboard players operation #INT temp /= #10 const
			scoreboard players operation #ACCURACY temp = @s LUK
			scoreboard players operation #ACCURACY temp /= #10 const
			scoreboard players operation #ACCURACY temp += #INT temp
			
			# write values
			execute store result storage skill:main damage[0].max_damage int 1 run scoreboard players get #MAX_DAMAGE temp
			execute store result storage skill:main damage[0].min_damage int 1 run scoreboard players get #MIN_DAMAGE temp
			execute store result storage skill:main damage[0].accuracy int 1 run scoreboard players get #ACCURACY temp
			execute store result storage skill:main damage[0].player_level int 1 run scoreboard players get @s level
			execute store result storage skill:main damage[0].crit_rate int 1 run scoreboard players get @s addi_crit_rate
			execute store result storage skill:main damage[0].crit_damage int 1 run scoreboard players get @s addi_crit_damage
		}
		
		folder accuracy()
		{
			func job_check()
			{
				execute if entity @s[tag=!archer,tag=!thief,tag=!pirate] run function ARG(_PATH)war_mag_beg
				execute if entity @s[tag=brawler] run function ARG(_PATH)brawler
				execute unless entity @s[tag=!archer,tag=!thief,tag=!pirate] if entity @s[tag=!brawler] run function ARG(_PATH)bow_thief_pirate
			}
			
			# warrior / magician / beginner
			func war_mag_beg()
			{
				scoreboard players operation #LUK temp = @s LUK
				scoreboard players operation #LUK temp *= #5 const
				scoreboard players operation #ACCURACY temp = @s DEX
				scoreboard players operation #ACCURACY temp *= #8 const
				scoreboard players operation #ACCURACY temp += #LUK temp
				scoreboard players operation #ACCURACY temp /= #10 const
				
				scoreboard players operation #ACCURACY temp += @s base_accuracy
				scoreboard players operation #ACCURACY temp += @s equip_accuracy
				scoreboard players operation #ACCURACY temp += @s accu_buff_num
			}
			
			# one punch
			func brawler()
			{
				scoreboard players operation #LUK temp = @s LUK
				scoreboard players operation #LUK temp *= #5 const
				scoreboard players operation #ACCURACY temp = @s DEX
				scoreboard players operation #ACCURACY temp *= #9 const
				scoreboard players operation #ACCURACY temp += #LUK temp
				scoreboard players operation #ACCURACY temp /= #10 const
				
				scoreboard players operation #ACCURACY temp += @s base_accuracy
				scoreboard players operation #ACCURACY temp += @s equip_accuracy
				scoreboard players operation #ACCURACY temp += @s accu_buff_num
			}
			
			# include gunslingers
			func bow_thief_pirate()
			{
				scoreboard players operation #LUK temp = @s LUK
				scoreboard players operation #LUK temp *= #3 const
				scoreboard players operation #ACCURACY temp = @s DEX
				scoreboard players operation #ACCURACY temp *= #6 const
				scoreboard players operation #ACCURACY temp += #LUK temp
				scoreboard players operation #ACCURACY temp /= #10 const
				
				scoreboard players operation #ACCURACY temp += @s base_accuracy
				scoreboard players operation #ACCURACY temp += @s equip_accuracy
				scoreboard players operation #ACCURACY temp += @s accu_buff_num
			}
		}
		
		func addi_crit()
		{
			scoreboard players operation #CRIT_RATE temp += @s addi_crit_rate
			scoreboard players operation #CRIT_DAMAGE temp += @s addi_crit_damage
			scoreboard players add #CRIT_DAMAGE temp 100
		}
		
		func write_values()
		{
			execute store result storage skill:main damage[0].max_damage int 1 run scoreboard players get #MAX_DAMAGE temp
			execute store result storage skill:main damage[0].min_damage int 1 run scoreboard players get #MIN_DAMAGE temp
			execute if score @s blind_time matches 0.. store result storage skill:main damage[0].accuracy int -1 run scoreboard players get #ACCURACY temp
			execute unless score @s blind_time matches 0.. store result storage skill:main damage[0].accuracy int 1 run scoreboard players get #ACCURACY temp
			execute store result storage skill:main damage[0].player_level int 1 run scoreboard players get @s level
			execute store result storage skill:main damage[0].crit_rate int 1 run scoreboard players get #CRIT_RATE temp
			execute store result storage skill:main damage[0].crit_damage int 1 run scoreboard players get #CRIT_DAMAGE temp
		}
		
		folder claw()
		{
			func normal()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				execute if score @s bullet_item matches ..20 run scoreboard players operation #WEAPON_ATTACK temp += @s bullet_damage
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s LUK
				scoreboard players operation #MAX_DAMAGE temp *= #36 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s claw_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				function ARG(_PATH)other_formula
			}
			
			func lucky_seven()
			{
				# weapon attack
				scoreboard players operation #MAX_DAMAGE temp = @s weapon_attack
				execute if score @s bullet_item matches ..20 run scoreboard players operation #MAX_DAMAGE temp += @s bullet_damage
				scoreboard players operation #MAX_DAMAGE temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp *= @s LUK
				scoreboard players operation #MAX_DAMAGE temp /= #20 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp /= #2 const
				
				function ARG(_PATH)other_formula
			}
			
			func punch()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s LUK
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp /= #10 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #150 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #150 const
				
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s claw_accuracy
				
				# reset crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				
				function ARG(__PATH)write_values
			}
			
			func other_formula()
			{
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s claw_accuracy
				
				# crit
				scoreboard players operation #CRIT_RATE temp = @s crit_rate
				scoreboard players operation #CRIT_DAMAGE temp = @s crit_damage
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder dagger()
		{
			func thief()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s LUK
				scoreboard players operation #MAX_DAMAGE temp *= #36 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s dagger_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s dagger_accuracy
				
				function ARG(_PATH)other_formula
			}
			
			func non_thief()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #4 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				execute if entity @s[tag=!archer,tag=!pirate] run function ARG(__PATH)accuracy/war_mag_beg
				execute if entity @s[tag=brawler] run function ARG(__PATH)accuracy/brawler
				execute unless entity @s[tag=!archer,tag=!pirate] if entity @s[tag=!brawler] run function ARG(__PATH)accuracy/bow_thief_pirate
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder bow()
		{
			func normal()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				execute unless score #GLOBAL bullet_model matches 3001 if score @s bullet_item matches 21..25 run scoreboard players operation #WEAPON_ATTACK temp += @s bullet_damage
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #34 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s bow_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# crit
				scoreboard players operation #CRIT_RATE temp = @s crit_rate
				scoreboard players operation #CRIT_DAMAGE temp = @s crit_damage
				
				function ARG(_PATH)other_formula
			}
			
			func power_knock_back()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #34 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #150 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #150 const
				
				# reset crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s bow_accuracy
				
				# additional crit
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder crossbow()
		{
			func normal()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				execute unless score #GLOBAL bullet_model matches 3001 if score @s bullet_item matches 26..30 run scoreboard players operation #WEAPON_ATTACK temp += @s bullet_damage
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #36 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s cbow_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# crit
				scoreboard players operation #CRIT_RATE temp = @s crit_rate
				scoreboard players operation #CRIT_DAMAGE temp = @s crit_damage
				
				function ARG(_PATH)other_formula
			}
			
			func power_knock_back()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MAX_DAMAGE temp = @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #34 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #150 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s STR
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #150 const
				
				# reset crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# accuracy
				function ARG(__PATH)accuracy/bow_thief_pirate
				scoreboard players operation #ACCURACY temp += @s cbow_accuracy
				
				# additional crit
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder spear()
		{
			func stab()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #5 const
				
				function ARG(_PATH)other_formula
			}
			
			func swing()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #3 const
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s spear_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s spear_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder polearm()
		{
			func swing()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #5 const
				
				function ARG(_PATH)other_formula
			}
			
			func stab()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #3 const
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s polearm_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s polearm_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder sword()
		{
			func one_hand()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #4 const
				
				function ARG(_PATH)other_formula
			}
			
			func two_hand()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #46 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s sword_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s sword_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder axe()
		{
			folder one_hand()
			{
				func swing()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #44 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
				
				func stab()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #32 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
			}
			
			folder two_hand()
			{
				func swing()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #48 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
				
				func stab()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #34 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
			}
			
			func other_formula()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s axe_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s axe_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		folder blunt()
		{
			folder one_hand()
			{
				func swing()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #44 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
				
				func stab()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #32 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
			}
			
			folder two_hand()
			{
				func swing()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #48 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
				
				func stab()
				{
					scoreboard players operation #MAX_DAMAGE temp = @s STR
					scoreboard players operation #MAX_DAMAGE temp *= #34 const
					scoreboard players operation #MAX_DAMAGE temp /= #10 const
					
					function ARG(__PATH)other_formula
				}
			}
			
			func other_formula()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp *= @s blunt_mastery
				scoreboard players operation #MIN_DAMAGE temp /= #1000 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				scoreboard players operation #ACCURACY temp += @s blunt_accuracy
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
		
		# wand formula == staff formula
		folder staff()
		{
			func swing()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #44 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				function ARG(_PATH)other_formula
			}
			
			func stab()
			{
				scoreboard players operation #MAX_DAMAGE temp = @s STR
				scoreboard players operation #MAX_DAMAGE temp *= #32 const
				scoreboard players operation #MAX_DAMAGE temp /= #10 const
				
				function ARG(_PATH)other_formula
			}
			
			func other_formula()
			{
				# weapon attack
				scoreboard players operation #WEAPON_ATTACK temp = @s weapon_attack
				scoreboard players operation #WEAPON_ATTACK temp += @s watk_buff_num
				
				scoreboard players operation #MIN_DAMAGE temp = #MAX_DAMAGE temp
				scoreboard players operation #MIN_DAMAGE temp *= #9 const
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				scoreboard players operation #MAX_DAMAGE temp += @s DEX
				scoreboard players operation #MAX_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				
				scoreboard players operation #MIN_DAMAGE temp += @s DEX
				scoreboard players operation #MIN_DAMAGE temp *= #WEAPON_ATTACK temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				
				# accuracy
				function ARG(__PATH)accuracy/job_check
				
				# crit
				scoreboard players set #CRIT_RATE temp 0
				scoreboard players set #CRIT_DAMAGE temp 0
				execute if score @s addi_crit_rate matches 1.. run function ARG(__PATH)addi_crit
				
				function ARG(__PATH)write_values
			}
		}
	}

	folder calculate_damage()
	{
		func run()
		{
			data modify entity @s ArmorItems[3].tag.damage_record set value []
			# copy damage list
			data modify storage skill:main damage_copy set from storage skill:main damage
			scoreboard players set #SAME_DAMAGE temp 0
			scoreboard players operation #NUMBER_HEIGHT temp = @s default_height
			scoreboard players remove #NUMBER_HEIGHT temp 1
			scoreboard players set #DID_HIT temp 0
			function ARG(_PATH)traverse_damages/run
			
			scoreboard players set #SILENT_UPDATE_HP temp 0
			execute if score #DID_HIT temp matches 1 run function ARG(_PATH)update_hp_display/run
			execute if score @s hp matches ..0 run function ARG(_PATH)record_dead
		}
		
		folder update_hp_display()
		{
			func run()
			{
				execute if entity @s[tag=!boss] run function ARG(_PATH)calculate
			}

			func calculate()
			{
				# for rounding
				scoreboard players operation #HP_CARRY temp = @s hp_max
				scoreboard players operation #HP_CARRY temp /= #92 const
				
				execute store result score #HP_LENGTH temp run scoreboard players operation @s hp > #0 const
				scoreboard players operation #HP_LENGTH temp += #HP_CARRY temp
				scoreboard players operation #HP_LENGTH temp *= #46 const
				scoreboard players operation #HP_LENGTH temp /= @s hp_max
				
				execute if score #SILENT_UPDATE_HP temp matches 0 if score @s mob_hp_length = #HP_LENGTH temp run function ARG(_PATH)show
				execute unless score @s mob_hp_length = #HP_LENGTH temp run function ARG(_PATH)update
			}
			
			func update()
			{
				scoreboard players operation @s mob_hp_length = #HP_LENGTH temp
				
				execute if score #HP_LENGTH temp matches ..11 run function ARG(_PATH)search/0_11
				execute if score #HP_LENGTH temp matches 12..23 run function ARG(_PATH)search/12_23
				execute if score #HP_LENGTH temp matches 24..35 run function ARG(_PATH)search/24_35
				execute if score #HP_LENGTH temp matches 36.. run function ARG(_PATH)search/36_46
				
				# 不顯示純刷新為2
				execute if score #SILENT_UPDATE_HP temp matches 1 unless score @s show_hp_time matches 1.. run scoreboard players set #SILENT_UPDATE_HP temp 2

				# 透過顏色控制 shader 調整顯示高度
				data modify storage bar:main mob_hp_color set from entity @s ArmorItems[3].tag.offset_color
				data modify block 250 0 0 Text1 set value '[{"nbt":"mob_hp_color","storage":"bar:main","interpret":true},{"text":"FF","font":"space:default"},{"nbt":"mob_hp","storage":"bar:main","font":"ui:mob_hp"},{"text":"FF","font":"space:default"}]'
				execute unless score #SILENT_UPDATE_HP temp matches 2 run data modify entity @s CustomName set from block 250 0 0 Text1
				data modify entity @s ArmorItems[3].tag.health_bar set from block 250 0 0 Text1
				
				execute if score #SILENT_UPDATE_HP temp matches 0 run scoreboard players set @s show_hp_time 5
			}
			
			func show()
			{
				execute unless score @s show_hp_time matches 1.. run data modify entity @s CustomName set from entity @s ArmorItems[3].tag.health_bar
				scoreboard players set @s show_hp_time 5
			}
			
			func countdown()
			{
				scoreboard players remove @s show_hp_time 1
				execute if score @s show_hp_time matches 0 run function ARG(_PATH)hide
			}
			
			func hide()
			{
				data modify entity @s CustomName set value '{"text":"2","font":"space:default"}'
				scoreboard players reset @s show_hp_time
			}
			
			folder search()
			{
				func 0_11()
				{
					execute if score #HP_LENGTH temp matches ..3 run function ARG(_PATH)0_3
					execute if score #HP_LENGTH temp matches 4..7 run function ARG(_PATH)4_7
					execute if score #HP_LENGTH temp matches 8.. run function ARG(_PATH)8_11
				}
				
				func 12_23()
				{
					execute if score #HP_LENGTH temp matches ..15 run function ARG(_PATH)12_15
					execute if score #HP_LENGTH temp matches 16..19 run function ARG(_PATH)16_19
					execute if score #HP_LENGTH temp matches 20.. run function ARG(_PATH)20_23
				}
				
				func 24_35()
				{
					execute if score #HP_LENGTH temp matches ..27 run function ARG(_PATH)24_27
					execute if score #HP_LENGTH temp matches 28..31 run function ARG(_PATH)28_31
					execute if score #HP_LENGTH temp matches 32.. run function ARG(_PATH)32_35
				}
				
				func 36_46()
				{
					execute if score #HP_LENGTH temp matches ..39 run function ARG(_PATH)36_39
					execute if score #HP_LENGTH temp matches 40..43 run function ARG(_PATH)40_43
					execute if score #HP_LENGTH temp matches 44.. run function ARG(_PATH)44_46
				}
				
				func 0_3()
				{
					execute if score #HP_LENGTH temp matches 0 run data modify storage bar:main mob_hp set value "0"
					execute if score #HP_LENGTH temp matches 1 run data modify storage bar:main mob_hp set value "1"
					execute if score #HP_LENGTH temp matches 2 run data modify storage bar:main mob_hp set value "2"
					execute if score #HP_LENGTH temp matches 3 run data modify storage bar:main mob_hp set value "3"
				}
				
				func 4_7()
				{
					execute if score #HP_LENGTH temp matches 4 run data modify storage bar:main mob_hp set value "4"
					execute if score #HP_LENGTH temp matches 5 run data modify storage bar:main mob_hp set value "5"
					execute if score #HP_LENGTH temp matches 6 run data modify storage bar:main mob_hp set value "6"
					execute if score #HP_LENGTH temp matches 7 run data modify storage bar:main mob_hp set value "7"
				}
				
				func 8_11()
				{
					execute if score #HP_LENGTH temp matches 8 run data modify storage bar:main mob_hp set value "8"
					execute if score #HP_LENGTH temp matches 9 run data modify storage bar:main mob_hp set value "9"
					execute if score #HP_LENGTH temp matches 10 run data modify storage bar:main mob_hp set value "A"
					execute if score #HP_LENGTH temp matches 11 run data modify storage bar:main mob_hp set value "B"
				}
				
				func 12_15()
				{
					execute if score #HP_LENGTH temp matches 12 run data modify storage bar:main mob_hp set value "C"
					execute if score #HP_LENGTH temp matches 13 run data modify storage bar:main mob_hp set value "D"
					execute if score #HP_LENGTH temp matches 14 run data modify storage bar:main mob_hp set value "E"
					execute if score #HP_LENGTH temp matches 15 run data modify storage bar:main mob_hp set value "F"
				}
				
				func 16_19()
				{
					execute if score #HP_LENGTH temp matches 16 run data modify storage bar:main mob_hp set value "G"
					execute if score #HP_LENGTH temp matches 17 run data modify storage bar:main mob_hp set value "H"
					execute if score #HP_LENGTH temp matches 18 run data modify storage bar:main mob_hp set value "I"
					execute if score #HP_LENGTH temp matches 19 run data modify storage bar:main mob_hp set value "J"
				}
				
				func 20_23()
				{
					execute if score #HP_LENGTH temp matches 20 run data modify storage bar:main mob_hp set value "K"
					execute if score #HP_LENGTH temp matches 21 run data modify storage bar:main mob_hp set value "L"
					execute if score #HP_LENGTH temp matches 22 run data modify storage bar:main mob_hp set value "M"
					execute if score #HP_LENGTH temp matches 23 run data modify storage bar:main mob_hp set value "N"
				}
				
				func 24_27()
				{
					execute if score #HP_LENGTH temp matches 24 run data modify storage bar:main mob_hp set value "O"
					execute if score #HP_LENGTH temp matches 25 run data modify storage bar:main mob_hp set value "P"
					execute if score #HP_LENGTH temp matches 26 run data modify storage bar:main mob_hp set value "Q"
					execute if score #HP_LENGTH temp matches 27 run data modify storage bar:main mob_hp set value "R"
				}
				
				func 28_31()
				{
					execute if score #HP_LENGTH temp matches 28 run data modify storage bar:main mob_hp set value "S"
					execute if score #HP_LENGTH temp matches 29 run data modify storage bar:main mob_hp set value "T"
					execute if score #HP_LENGTH temp matches 30 run data modify storage bar:main mob_hp set value "U"
					execute if score #HP_LENGTH temp matches 31 run data modify storage bar:main mob_hp set value "V"
				}
				
				func 32_35()
				{
					execute if score #HP_LENGTH temp matches 32 run data modify storage bar:main mob_hp set value "W"
					execute if score #HP_LENGTH temp matches 33 run data modify storage bar:main mob_hp set value "X"
					execute if score #HP_LENGTH temp matches 34 run data modify storage bar:main mob_hp set value "Y"
					execute if score #HP_LENGTH temp matches 35 run data modify storage bar:main mob_hp set value "Z"
				}
				
				func 36_39()
				{
					execute if score #HP_LENGTH temp matches 36 run data modify storage bar:main mob_hp set value "a"
					execute if score #HP_LENGTH temp matches 37 run data modify storage bar:main mob_hp set value "b"
					execute if score #HP_LENGTH temp matches 38 run data modify storage bar:main mob_hp set value "c"
					execute if score #HP_LENGTH temp matches 39 run data modify storage bar:main mob_hp set value "d"
				}
				
				func 40_43()
				{
					execute if score #HP_LENGTH temp matches 40 run data modify storage bar:main mob_hp set value "e"
					execute if score #HP_LENGTH temp matches 41 run data modify storage bar:main mob_hp set value "f"
					execute if score #HP_LENGTH temp matches 42 run data modify storage bar:main mob_hp set value "g"
					execute if score #HP_LENGTH temp matches 43 run data modify storage bar:main mob_hp set value "h"
				}
				
				func 44_46()
				{
					execute if score #HP_LENGTH temp matches 44 run data modify storage bar:main mob_hp set value "i"
					execute if score #HP_LENGTH temp matches 45 run data modify storage bar:main mob_hp set value "j"
					execute if score #HP_LENGTH temp matches 46 run data modify storage bar:main mob_hp set value "k"
				}
			}
		}
		
		func record_dead()
		{
			attribute @s minecraft:generic.movement_speed base set -100.0
			
			item replace entity @s weapon.mainhand with minecraft:potion{CustomModelData:1,Enchantments:[{id:"minecraft:looting",lvl:1}]}
			execute store result entity @s HandItems[0].tag.Enchantments[0].lvl int 1 run scoreboard players get #WORLD_DROP_RATE const
			loot spawn ~ ~1 ~ kill @s
			execute as @e[type=item,tag=!checked] at @s run function item:entity/check
			
			scoreboard players operation #EXP_GAIN temp += @s exp
			tag @s add dead

			execute on passengers run data modify entity @s[type=magma_cube] NoAI set value 1b
			execute on passengers run tag @s[type=interaction] remove enemy
		}
		
		folder traverse_damages() from while_loop("if data storage skill:main damage_copy[0]")
		{
			func execute()
			{
				execute unless score #SAME_DAMAGE temp matches 1 run function ARG(_PATH)record_value
				data remove storage skill:main damage_copy[0]
				
				data modify entity @s ArmorItems[3].tag.damage_record append value {number:0,crit:0}
				execute store result entity @s ArmorItems[3].tag.damage_record[-1].height int 1 run scoreboard players add #NUMBER_HEIGHT temp 1
				
				function random:rand_rate
				execute if score #HIT_RATE temp > #RAND_RESULT number run function ARG(_PATH)deal_damage
			}
			
			func record_value()
			{
				execute store result score #MIN_DAMAGE temp run data get storage skill:main damage_copy[0].min_damage
				execute store result score #MAX_DAMAGE temp run data get storage skill:main damage_copy[0].max_damage
				execute store result score #BASE_PERCENT temp run data get storage skill:main damage_copy[0].base_percent
				execute store result score #CRIT_RATE temp run data get storage skill:main damage_copy[0].crit_rate
				execute store result score #CRIT_DAMAGE temp run data get storage skill:main damage_copy[0].crit_damage
				scoreboard players operation #CRIT_DAMAGE temp += #BASE_PERCENT temp
				execute store result score #LEVEL_DIFFERENCE temp run data get storage skill:main damage_copy[0].player_level -1
				scoreboard players operation #LEVEL_DIFFERENCE temp += @s level
				scoreboard players operation #LEVEL_DIFFERENCE temp > #0 const
				# ATTRIBUTE 0 = weapon attack; 1 = magic attack; 2 = fire; 3 = poison; 4 = ice; 5 = lightning; 6 = holy
				execute store result score #ATTRIBUTE temp run data get storage skill:main damage_copy[0].attribute
				execute if score #ATTRIBUTE temp matches 2.. run function ARG(_PATH)attribute_multiply/run
				# Calculate defense and hit rate
				execute if score #ATTRIBUTE temp matches 0 run function ARG(_PATH)weapon_formula
				execute if score #ATTRIBUTE temp matches 1.. run function ARG(_PATH)magic_formula
				
				execute store success score #SAME_DAMAGE temp run data modify storage skill:main damage_copy[0] set from storage skill:main damage_copy[1]
			}
			
			func weapon_formula()
			{
				# defense
				scoreboard players operation #DEFENSE temp = @s weapon_defense
				scoreboard players operation #DEFENSE temp -= @s wdef_drop
				scoreboard players operation #DEFENSE temp /= #2 const
				
				scoreboard players set #LEVEL_PUNISH temp 100
				scoreboard players operation #LEVEL_PUNISH temp -= #LEVEL_DIFFERENCE temp
				scoreboard players operation #MAX_DAMAGE temp *= #LEVEL_PUNISH temp
				scoreboard players operation #MAX_DAMAGE temp /= #100 const
				scoreboard players operation #MAX_DAMAGE temp -= #DEFENSE temp
				
				scoreboard players operation #MIN_DAMAGE temp *= #LEVEL_PUNISH temp
				scoreboard players operation #MIN_DAMAGE temp /= #100 const
				scoreboard players operation #DEFENSE temp *= #6 const
				scoreboard players operation #DEFENSE temp /= #5 const
				scoreboard players operation #MIN_DAMAGE temp -= #DEFENSE temp
				
				# hit rate
				execute store result score #HIT_RATE temp run data get storage skill:main damage_copy[0].accuracy 100000
				execute store result score #IS_BLIND temp if score #HIT_RATE temp matches ..-1
				execute if score #IS_BLIND temp matches 1 run scoreboard players operation #HIT_RATE temp *= #-1 const
				
				scoreboard players operation #LEVEL_DIFFERENCE temp *= #66 const
				scoreboard players add #LEVEL_DIFFERENCE temp 1835
				scoreboard players operation #LEVEL_DIFFERENCE temp *= @s avoidability
				scoreboard players operation #HIT_RATE temp /= #LEVEL_DIFFERENCE temp
				scoreboard players remove #HIT_RATE temp 100
				
				execute if score #IS_BLIND temp matches 1 run scoreboard players operation #HIT_RATE temp /= #15 const
			}
			
			func magic_formula()
			{
				# defense
				scoreboard players operation #DEFENSE temp = @s magic_defense
				scoreboard players operation #DEFENSE temp /= #2 const
				
				scoreboard players set #LEVEL_PUNISH temp 100
				scoreboard players operation #LEVEL_PUNISH temp += #LEVEL_DIFFERENCE temp
				scoreboard players operation #DEFENSE temp *= #LEVEL_PUNISH temp
				scoreboard players operation #DEFENSE temp /= #100 const
				scoreboard players operation #MAX_DAMAGE temp -= #DEFENSE temp
				
				scoreboard players operation #DEFENSE temp *= #6 const
				scoreboard players operation #DEFENSE temp /= #5 const
				scoreboard players operation #MIN_DAMAGE temp -= #DEFENSE temp
				
				# hit rate
				scoreboard players operation #LEVEL_DIFFERENCE temp *= #4 const
				scoreboard players add #LEVEL_DIFFERENCE temp 100
				scoreboard players operation #MAX_ACCURACY temp = @s avoidability
				scoreboard players add #MAX_ACCURACY temp 1
				scoreboard players operation #MAX_ACCURACY temp *= #LEVEL_DIFFERENCE temp
				scoreboard players operation #MAX_ACCURACY temp /= #100 const
				
				scoreboard players operation #MIN_ACCURACY temp = #MAX_ACCURACY temp
				scoreboard players operation #MIN_ACCURACY temp *= #41 const
				scoreboard players operation #MIN_ACCURACY temp /= #100 const
				
				execute store result score #ACCURACY temp run data get storage skill:main damage_copy[0].accuracy
				scoreboard players set #HIT_RATE temp 0
				execute if score #ACCURACY temp >= #MAX_ACCURACY temp run scoreboard players set #HIT_RATE temp 100
				execute if score #ACCURACY temp < #MAX_ACCURACY temp if score #ACCURACY temp >= #MIN_ACCURACY temp run function ARG(_PATH)magic_hit_rate
			}
			
			func magic_hit_rate()
			{
				scoreboard players operation #ACCURACY temp -= #MIN_ACCURACY temp
				scoreboard players add #ACCURACY temp 1
				scoreboard players operation #ACCURACY temp *= #100 const
				
				scoreboard players operation #MAX_ACCURACY temp -= #MIN_ACCURACY temp
				scoreboard players add #MAX_ACCURACY temp 1
				
				execute store result score #HIT_RATE temp run scoreboard players operation #ACCURACY temp /= #MAX_ACCURACY temp
				scoreboard players operation #HIT_RATE temp *= #HIT_RATE temp
				scoreboard players operation #HIT_RATE temp *= #-7 const
				scoreboard players operation #HIT_RATE temp /= #1000 const
				
				scoreboard players operation #ACCURACY temp *= #17 const
				scoreboard players operation #ACCURACY temp /= #10 const
				
				scoreboard players operation #HIT_RATE temp += #ACCURACY temp
			}
			
			func deal_damage()
			{
				scoreboard players operation @s display_number = #MAX_DAMAGE temp
				execute unless score #MAX_DAMAGE temp = #MIN_DAMAGE temp run function ARG(_PATH)rand_damage
				
				execute if score #CRIT_RATE temp matches 1.. run function random:rand_rate
				execute if score #CRIT_RATE temp > #RAND_RESULT number run function ARG(_PATH)crit_multiply
				execute unless score #CRIT_RATE temp > #RAND_RESULT number run function ARG(_PATH)skill_multiply
				
				scoreboard players operation @s display_number < #99999 const
				scoreboard players operation @s display_number > #1 const
				
				execute if score #AFTER_MODIFIER_NUM temp matches 1.. run function ARG(_PATH)after_modify/set
				
				scoreboard players operation @s hp -= @s display_number
				execute store result entity @s ArmorItems[3].tag.damage_record[-1].number int 1 run scoreboard players get @s display_number
				
				scoreboard players set #DID_HIT temp 1
			}
			
			folder after_modify() from for_loop().for("@s hit_order", "")
			{
				func set()
				{
					scoreboard players operation @s display_number *= #AFTER_MODIFIER_SCALE_NUM temp
					scoreboard players operation @s display_number /= #AFTER_MODIFIER_SCALE_DENOM temp
					scoreboard players operation @s display_number *= #100 const
					function ARG(_PATH)run
					scoreboard players operation @s display_number /= #100 const
				}
				
				func execute()
				{
					scoreboard players operation @s display_number *= #AFTER_MODIFIER_NUM temp
					scoreboard players operation @s display_number /= #AFTER_MODIFIER_DENOM temp
				}
			}
			
			folder attribute_multiply()
			{
				func run()
				{
					execute if score #ATTRIBUTE temp matches 2 run function ARG(_PATH)fire
					execute if score #ATTRIBUTE temp matches 3 run function ARG(_PATH)poison
					execute if score #ATTRIBUTE temp matches 4 run function ARG(_PATH)ice
					execute if score #ATTRIBUTE temp matches 5 run function ARG(_PATH)lightning
					execute if score #ATTRIBUTE temp matches 6 run function ARG(_PATH)holy
				}
				
				func fire()
				{
					execute if entity @s[tag=fire_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=fire_weakness] run function ARG(_PATH)weakness
				}
				
				func poison()
				{
					execute if entity @s[tag=poison_s_resist] run function ARG(_PATH)strong_resist
					execute if entity @s[tag=poison_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=poison_weakness] run function ARG(_PATH)weakness
				}
				
				func ice()
				{
					execute if entity @s[tag=ice_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=ice_weakness] run function ARG(_PATH)weakness
				}
				
				func lightning()
				{
					execute if entity @s[tag=lightning_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=lightning_weakness] run function ARG(_PATH)weakness
				}
				
				func holy()
				{
					execute if entity @s[tag=holy_resist] run function ARG(_PATH)resist
					execute if entity @s[tag=holy_weakness] run function ARG(_PATH)weakness
				}
				
				func strong_resist()
				{
					scoreboard players set #MIN_DAMAGE temp 1
					scoreboard players set #MAX_DAMAGE temp 1
				}
	
				func resist()
				{
					scoreboard players operation #MIN_DAMAGE temp *= #50 const
					scoreboard players operation #MAX_DAMAGE temp *= #50 const
					function ARG(_PATH)divide_back
				}
				
				func weakness()
				{
					scoreboard players operation #MIN_DAMAGE temp *= #150 const
					scoreboard players operation #MAX_DAMAGE temp *= #150 const
					function ARG(_PATH)divide_back
				}
				
				func divide_back()
				{
					scoreboard players operation #MIN_DAMAGE temp /= #100 const
					scoreboard players operation #MAX_DAMAGE temp /= #100 const
				}
			}
			
			func crit_multiply()
			{
				scoreboard players operation @s display_number *= #CRIT_DAMAGE temp
				scoreboard players operation @s display_number /= #100 const
				data modify entity @s ArmorItems[3].tag.damage_record[-1].crit set value 1
			}
			
			func skill_multiply()
			{
				scoreboard players operation @s display_number *= #BASE_PERCENT temp
				scoreboard players operation @s display_number /= #100 const
			}
			
			func rand_damage() from random().generate("#MIN_DAMAGE temp", "#MAX_DAMAGE temp", "@s display_number");
		}
	}
	
	folder mob_effect()
	{
		folder debuff()
		{
			func freeze()
			{
				tag @s add color_changed

				execute store result score @s kb_time run scoreboard players operation @s freeze_time = #FREEZE_TIME temp
				scoreboard players add @s kb_time 12
				scoreboard players set @s status 1

				execute unless score @s freeze_time matches 1.. run scoreboard players set #SYNC_FREEZE_COLOR temp 1
				function skill:sync_knockback/run
				scoreboard players reset #SYNC_FREEZE_COLOR temp
			}

			func freeze_color()
			{
				data modify entity @s[tag=!objmc] ArmorItems[3].tag.CustomPotionColor set value 12580095
				data modify entity @s[tag=objmc] ArmorItems[3].tag.CustomPotionColor set value 150
			}
			
			func poison()
			{
				scoreboard players operation @s poison_time = #POISON_TIME temp
				scoreboard players operation @s poison_damage = @s hp_max
				scoreboard players operation @s poison_damage += #POISON_HP_RATE temp
				scoreboard players remove @s poison_damage 1
				scoreboard players operation @s poison_damage /= #POISON_HP_RATE temp
				
				execute unless score @s next_poison matches 1.. run function ARG(_PATH)set_poison
			}
			
			func set_poison()
			{
				tag @s add color_changed
				scoreboard players set @s next_poison 20
				execute on controller run function ARG(_PATH)poison_color
				
				scoreboard players operation #BIND_PLAYER number = @s number
				execute store result score #NUMBER_HEIGHT temp run data get entity @s ArmorItems[3].tag.bind_point
				execute positioned ~ ~0.2625 ~ summon item_display run function ARG(_PATH)bind_poison
			}
			
			func bind_poison()
			{
				data merge entity @s {Tags:["poison"],item:{id:"minecraft:potion",Count:1b,tag:{CustomModelData:102}},billboard:"center"}
				execute store result entity @s item.tag.CustomPotionColor int 1 run scoreboard players get #NUMBER_HEIGHT temp
				function skill:bind_mob
			}

			func poison_color()
			{
				data modify entity @s[tag=!objmc] ArmorItems[3].tag.CustomPotionColor set value 2779438
				data modify entity @s[tag=objmc] ArmorItems[3].tag.CustomPotionColor set value 151
			}
			
			func stun()
			{
				execute unless score @s stun_time matches 1.. run function ARG(_PATH)set_stun
				scoreboard players operation @s stun_time = #STUN_TIME temp
			}

			func set_stun()
			{
				attribute @s minecraft:generic.movement_speed modifier add 98fb435b-7645-4b76-8504-ee4f9e13fdec stun_control -100.0 add

				scoreboard players operation #BIND_PLAYER number = @s number
				execute store result score #NUMBER_HEIGHT temp run data get entity @s ArmorItems[3].tag.bind_point
				execute positioned ~ ~0.2625 ~ summon item_display run function ARG(_PATH)bind_stun
			}
			
			func bind_stun()
			{
				data merge entity @s {Tags:["stun"],item:{id:"minecraft:potion",Count:1b,tag:{CustomModelData:103}},billboard:"center"}
				execute store result entity @s item.tag.CustomPotionColor int 1 run scoreboard players get #NUMBER_HEIGHT temp
				function skill:bind_mob
			}
		}
		
		func dead()
		{
			scoreboard players operation #GLOBAL temp = @s number
			execute as @e[type=armor_stand,tag=bullet] if score @s target_id = #GLOBAL temp run kill @s
			
			function ARG(_PATH)play_die_sound/run
			execute if entity @s[tag=dead_effect] run function ARG(_PATH)dead_effect/check
			execute on passengers run kill @s
			kill @s
		}
		
		folder dead_effect()
		{
			func check()
			{
				execute if entity @s[tag=king_slime] run function ARG(_PATH)king_slime/run
				execute if entity @s[tag=objmc] run function ARG(_PATH)objmc/run
			}
			
			folder king_slime()
			{
				func run()
				{
					execute summon minecraft:marker run function ARG(_PATH)setting
				}

				func setting()
				{
					execute store result score @s skill_delay run schedule function ARG(_PATH)call_summon 20t append
					tag @s add dead_king_slime
				}
				
				func call_summon()
				{
					execute store result score #GLOBAL temp run time query gametime
					execute as @e[type=marker,tag=dead_king_slime] if score @s skill_delay = #GLOBAL temp at @s run function ARG(_PATH)summon
				}
				
				func summon()
				{
					```
					for i in range(10):
						print(spawn_mob("0210100", is_summon=True))
					```
					execute as @e[type=ocelot,tag=new_summon] run function mob:setting/run
					kill @s
				}
			}
			
			# objmc 不會有死亡的側倒動畫，要自己做
			folder objmc()
			{
				func run()
				{
					execute as @e[type=zombified_piglin] if score @s number = #GLOBAL temp run function ARG(_PATH)dead_anim
				}
				
				func dead_anim()
				{
					# 統一由基底 model + 4 當死亡動畫，長度 22 frame
					execute store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players add @s base_model 4
					# 計算 objmc 動畫起始時間
					execute store result score #MODEL_COLOR temp run time query gametime
					scoreboard players operation #MODEL_COLOR temp %= #24000 const
					scoreboard players operation #MODEL_COLOR temp %= #22 const
					scoreboard players operation #MODEL_COLOR temp *= #256 const
					execute store result entity @s ArmorItems[3].tag.CustomPotionColor int 1 run scoreboard players add #MODEL_COLOR temp 255
				}
			}
		}
		
		folder play_hurt_sound()
		{
			```
			def bs_hurt_sound(sound_list, start, end):
				if len(sound_list) == 1:
					print("func run()")
					print("{")
					print(f"\texecute if score @s hurt_sound matches {sound_list[0][1]} run playsound minecraft:mob.hurt.{sound_list[0][0]} player @a ~ ~ ~ 1 1 0")
					print("}")
					return
				
				if start == end:
					return
				
				mid = (start + end) // 2
				mid_right = mid + 1
				
				if start == 0 and end == len(sound_list) - 1:
					print("func run()")
				else:
					print(f"func {start}_{end}()")
				print("{")
				if start == mid:
					print(f"\texecute if score @s hurt_sound matches {sound_list[start][1]} run playsound minecraft:mob.hurt.{sound_list[start][0]} player @a ~ ~ ~ 1 1 0")
				else:
					print(f"\texecute if score @s hurt_sound matches {sound_list[start][1]}..{sound_list[mid][1]} run function ARG(_PATH){start}_{mid}")
				if mid_right == end:
					print(f"\texecute if score @s hurt_sound matches {sound_list[end][1]} run playsound minecraft:mob.hurt.{sound_list[end][0]} player @a ~ ~ ~ 1 1 0")
				else:
					print(f"\texecute if score @s hurt_sound matches {sound_list[mid_right][1]}..{sound_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
				print("}")
				
				bs_hurt_sound(sound_list, start, mid)
				bs_hurt_sound(sound_list, mid_right, end)
			
			with open(PROJ_DIR + "/../hurt_sounds.csv") as f:
				hurt_sounds = f.read().split("\n")
				for i in range(len(hurt_sounds)):
					hurt_sounds[i] = hurt_sounds[i].split(",")
					hurt_sounds[i][1] = int(hurt_sounds[i][1])
			
			bs_hurt_sound(hurt_sounds, 0, len(hurt_sounds) - 1)
			```
		}
		
		folder play_die_sound()
		{
			```
			def bs_die_sound(sound_list, start, end):
				if len(sound_list) == 1:
					print("func run()")
					print("{")
					print(f"\texecute if score @s die_sound matches {sound_list[0][1]} run playsound minecraft:mob.die.{sound_list[0][0]} player @a ~ ~ ~ 1 1 0")
					print("}")
					return
				
				if start == end:
					return
				
				mid = (start + end) // 2
				mid_right = mid + 1
				
				if start == 0 and end == len(sound_list) - 1:
					print("func run()")
				else:
					print(f"func {start}_{end}()")
				print("{")
				if start == mid:
					print(f"\texecute if score @s die_sound matches {sound_list[start][1]} run playsound minecraft:mob.die.{sound_list[start][0]} player @a ~ ~ ~ 1 1 0")
				else:
					print(f"\texecute if score @s die_sound matches {sound_list[start][1]}..{sound_list[mid][1]} run function ARG(_PATH){start}_{mid}")
				if mid_right == end:
					print(f"\texecute if score @s die_sound matches {sound_list[end][1]} run playsound minecraft:mob.die.{sound_list[end][0]} player @a ~ ~ ~ 1 1 0")
				else:
					print(f"\texecute if score @s die_sound matches {sound_list[mid_right][1]}..{sound_list[end][1]} run function ARG(_PATH){mid_right}_{end}")
				print("}")
				
				bs_die_sound(sound_list, start, mid)
				bs_die_sound(sound_list, mid_right, end)
			
			with open(PROJ_DIR + "/../die_sounds.csv") as f:
				die_sounds = f.read().split("\n")
				for i in range(len(die_sounds)):
					die_sounds[i] = die_sounds[i].split(",")
					die_sounds[i][1] = int(die_sounds[i][1])
			
			bs_die_sound(die_sounds, 0, len(die_sounds) - 1)
			```
		}
	}
	
	folder afterimage()
	{
		folder hit()
		{
			func mace()
			{
				scoreboard players set #RANGE_MAX temp 5
				function main:rand_range
				execute if score #RAND_RANGE_RESULT temp matches ..2 summon text_display run function skill:summon_font_effect/0000000mace0
				execute if score #RAND_RANGE_RESULT temp matches 3.. summon text_display run function skill:summon_font_effect/0000000mace1
			}
			
			func sword()
			{
				scoreboard players set #RANGE_MAX temp 5
				function main:rand_range
				execute if score #RAND_RANGE_RESULT temp matches ..2 summon text_display run function skill:summon_font_effect/0000000sword0
				execute if score #RAND_RANGE_RESULT temp matches 3.. summon text_display run function skill:summon_font_effect/0000000sword1
			}
		}
		
		folder final_swing()
		{
			func check()
			{
				execute if score #USED_WEAPON temp matches 5..8 run function ARG(_PATH)sword_axe
				execute if score #USED_WEAPON temp matches 9..14 run function ARG(_PATH)others
			}
			
			func sword_axe()
			{
				execute if score #USED_WEAPON temp matches 5 run function ARG(__PATH)oh_axe/final_attack/use
				execute if score #USED_WEAPON temp matches 6 run function ARG(__PATH)th_axe/final_attack/use
				execute if score #USED_WEAPON temp matches 7 run function ARG(__PATH)oh_sword/final_attack/use
				execute if score #USED_WEAPON temp matches 8 run function ARG(__PATH)th_sword/final_attack/use
			}
			
			func others()
			{
				execute if score #USED_WEAPON temp matches 9 run function ARG(__PATH)oh_blunt/final_attack/use
				execute if score #USED_WEAPON temp matches 12 run function ARG(__PATH)spear/final_attack/use
				execute if score #USED_WEAPON temp matches 14 run function ARG(__PATH)polearm/final_attack/use
				execute if score #USED_WEAPON temp matches 10 run function ARG(__PATH)th_blunt/final_attack/use
			}
		}
		
		folder warrior_swing()
		{
			func check()
			{
				execute if score #USED_WEAPON temp matches ..9 run function ARG(_PATH)case1
				execute if score #USED_WEAPON temp matches 10.. run function ARG(_PATH)case2
			}
			
			func case1()
			{
				execute if score #USED_WEAPON temp matches 5 run function ARG(__PATH)oh_axe/random
				execute if score #USED_WEAPON temp matches 6 run function ARG(__PATH)th_axe/random
				execute if score #USED_WEAPON temp matches 7 run function ARG(__PATH)oh_sword/random
				execute if score #USED_WEAPON temp matches 8 run function ARG(__PATH)th_sword/random
				execute if score #USED_WEAPON temp matches 9 run function ARG(__PATH)oh_blunt/random
			}
			
			func case2()
			{
				execute if score #USED_WEAPON temp matches 10 run function ARG(__PATH)th_blunt/random
				execute if score #USED_WEAPON temp matches 12 run function ARG(__PATH)spear/random
				execute if score #USED_WEAPON temp matches 14 run function ARG(__PATH)polearm/random
				execute if score #USED_WEAPON temp matches 19..21 run function ARG(__PATH)staff/swing
				execute if score #USED_WEAPON temp matches 23 run function ARG(__PATH)dagger/random
			}
		}
		
		folder claw()
		{
			func swing()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				scoreboard players set #RANGE_MAX temp 8
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000000
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s claw_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.punch player @a ~ ~ ~ 1 1 0
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s claw_color
			}
			
			func stab()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				scoreboard players set #RAND_RANGE_RESULT temp 1001009
				scoreboard players set #AFTERIMAGE_COLOR temp 255
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.punch player @a ~ ~ ~ 1 1 0
				function skill:damage_formula/claw/punch
				scoreboard players add @s action_time 16
			}
		}
		
		folder dagger()
		{
			func random()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				scoreboard players set #RANGE_MAX temp 14
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000021
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s dagger_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				execute if entity @s[tag=thief] run function skill:damage_formula/dagger/thief
				execute if entity @s[tag=!thief] run function skill:damage_formula/dagger/non_thief
				scoreboard players add @s action_time 15
			}
			
			func stab()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				scoreboard players set #RAND_RANGE_RESULT temp 1000030
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s dagger_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s dagger_color
			}
		}
		
		folder bow()
		{
			func swing()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				scoreboard players set #RANGE_MAX temp 5
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000015
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s bow_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				function skill:damage_formula/bow/power_knock_back
				scoreboard players add @s action_time 16
			}
			
			func shoot()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				scoreboard players set #RAND_RANGE_RESULT temp 1000096
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s bow_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				execute if score @s f_attack_skill matches 1.. if score @s bow_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			folder final_attack()
			{
				func try()
				{
					function random:rand_rate
					execute if score #RAND_RESULT number < @s bow_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 4
					
					scoreboard players add @s action_time 10
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s bow_color
			}
		}
		
		folder crossbow()
		{
			func swing()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				scoreboard players set #RANGE_MAX temp 5
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000012
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s cbow_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model_delay
				
				playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				function skill:damage_formula/crossbow/power_knock_back
				scoreboard players add @s action_time 17
			}
			
			func shoot()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				scoreboard players set #RAND_RANGE_RESULT temp 1000096
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s cbow_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model_delay
				
				playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				execute if score @s f_attack_skill matches 1.. if score @s cbow_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			folder final_attack()
			{
				func try()
				{
					function random:rand_rate
					execute if score #RAND_RESULT number < @s cbow_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					scoreboard players add @s action_time 10
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s cbow_color
			}
		}
		
		folder staff()
		{
			func swing()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				scoreboard players set #RAND_RANGE_RESULT temp 1001069
				scoreboard players set #AFTERIMAGE_COLOR temp 255
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				function skill:damage_formula/staff/swing
				scoreboard players add @s action_time 16
			}
		}
		
		folder polearm()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 14
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000036
				
				execute if score #RAND_RANGE_RESULT temp matches 1000036..1000044 run function ARG(_PATH)swing_formula
				execute if score #RAND_RANGE_RESULT temp matches 1000045..1000050 run function ARG(_PATH)stab_formula
				
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s polearm_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				playsound minecraft:skill.attack.polearm player @a ~ ~ ~ 1 1 0
				
				scoreboard players add @s action_time 15
				execute if score @s f_attack_skill matches 1.. if score @s p_arm_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			func swing_formula()
			{
				scoreboard players set #SEARCH_HEIGHT temp 2
				
				function skill:damage_formula/polearm/swing
				scoreboard players set #LAST_ACTION_TYPE temp 1
			}
			
			func stab_formula()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				function skill:damage_formula/polearm/stab
				scoreboard players set #LAST_ACTION_TYPE temp 2
			}
			
			folder final_attack()
			{
				func try()
				{
					function random:rand_rate
					execute if score #RAND_RESULT number < @s p_arm_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 1
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 1 run scoreboard players add @s action_time 1
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 5
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000106
				}
				
				func swing_formula()
				{
					scoreboard players set #SEARCH_HEIGHT temp 2
					function skill:damage_formula/polearm/swing
				}
				
				func stab_formula()
				{
					scoreboard players set #SEARCH_HEIGHT temp 0
					function skill:damage_formula/polearm/stab
				}
				
				func use()
				{
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
				
					execute if score #RAND_RANGE_RESULT temp matches 1000106..1000108 run function ARG(_PATH)swing_formula
					execute if score #RAND_RANGE_RESULT temp matches 1000109..1000111 run function ARG(_PATH)stab_formula
					
					scoreboard players set #AFTERIMAGE_COLOR temp 0
					execute if score @s polearm_mastery matches ..55 run function ARG(__PATH)set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.polearm player @a ~ ~ ~ 1 1 0
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s polearm_color
			}
		}
		
		folder spear()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 14
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000036
				
				execute if score #RAND_RANGE_RESULT temp matches 1000036..1000044 run function ARG(_PATH)swing_formula
				execute if score #RAND_RANGE_RESULT temp matches 1000045..1000050 run function ARG(_PATH)stab_formula
				
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s spear_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				playsound minecraft:skill.attack.spear player @a ~ ~ ~ 1 1 0
				
				scoreboard players add @s action_time 15
				execute if score @s f_attack_skill matches 1.. if score @s spear_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			func swing_formula()
			{
				scoreboard players set #SEARCH_HEIGHT temp 2
				
				function skill:damage_formula/spear/swing
				scoreboard players set #LAST_ACTION_TYPE temp 1
			}
			
			func stab_formula()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				function skill:damage_formula/spear/stab
				scoreboard players set #LAST_ACTION_TYPE temp 2
			}
			
			folder final_attack()
			{
				func try()
				{
					function random:rand_rate
					execute if score #RAND_RESULT number < @s spear_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 1
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 1 run scoreboard players add @s action_time 1
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 5
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000106
				}
				
				func swing_formula()
				{
					scoreboard players set #SEARCH_HEIGHT temp 2
					function skill:damage_formula/spear/swing
				}
				
				func stab_formula()
				{
					scoreboard players set #SEARCH_HEIGHT temp 0
					function skill:damage_formula/spear/stab
				}
				
				func use()
				{
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
				
					execute if score #RAND_RANGE_RESULT temp matches 1000106..1000108 run function ARG(_PATH)swing_formula
					execute if score #RAND_RANGE_RESULT temp matches 1000109..1000111 run function ARG(_PATH)stab_formula
					
					scoreboard players set #AFTERIMAGE_COLOR temp 0
					execute if score @s spear_mastery matches ..55 run function ARG(__PATH)set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.spear player @a ~ ~ ~ 1 1 0
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s spear_color
			}
		}
		
		folder oh_sword()
		{
			func random()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				scoreboard players set #RANGE_MAX temp 14
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000000
				
				execute if score #RAND_RANGE_RESULT temp matches 1000000..1000008 run scoreboard players set #LAST_ACTION_TYPE temp 1
				execute if score #RAND_RANGE_RESULT temp matches 1000009..1000014 run scoreboard players set #LAST_ACTION_TYPE temp 2
				
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s sword_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				function skill:damage_formula/sword/one_hand
				
				scoreboard players add @s action_time 16
				execute if score @s f_attack_skill matches 1.. if score @s sword_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			folder final_attack()
			{
				func try()
				{
					function random:rand_rate
					execute if score #RAND_RESULT number < @s sword_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 5
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000100
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 2 if score #RAND_RANGE_RESULT temp matches 1000103..1000105 run scoreboard players remove @s action_time 2
				}
				
				func use()
				{
					scoreboard players set #SEARCH_HEIGHT temp 0
					
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
					function skill:damage_formula/sword/one_hand
					
					scoreboard players set #AFTERIMAGE_COLOR temp 0
					execute if score @s sword_mastery matches ..55 run function ARG(__PATH)set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s sword_color
			}
		}
		
		folder oh_axe()
		{
			func random()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				scoreboard players set #RANGE_MAX temp 14
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000000
				
				execute if score #RAND_RANGE_RESULT temp matches 1000000..1000008 run function ARG(_PATH)swing_formula
				execute if score #RAND_RANGE_RESULT temp matches 1000009..1000014 run function ARG(_PATH)stab_formula
				
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s axe_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				playsound minecraft:skill.attack.sword_l player @a ~ ~ ~ 1 1 0
				
				scoreboard players add @s action_time 16
				execute if score @s f_attack_skill matches 1.. if score @s axe_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			func swing_formula()
			{
				function skill:damage_formula/axe/one_hand/swing
				scoreboard players set #LAST_ACTION_TYPE temp 1
			}
			
			func stab_formula()
			{
				function skill:damage_formula/axe/one_hand/stab
				scoreboard players set #LAST_ACTION_TYPE temp 2
			}
			
			folder final_attack()
			{
				func try()
				{
					function random:rand_rate
					execute if score #RAND_RESULT number < @s axe_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 5
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000100
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 2 if score #RAND_RANGE_RESULT temp matches 1000103..1000105 run scoreboard players remove @s action_time 2
				}
				
				func use()
				{
					scoreboard players set #SEARCH_HEIGHT temp 0
					
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
				
					execute if score #RAND_RANGE_RESULT temp matches 1000100..1000102 run function skill:damage_formula/axe/one_hand/swing
					execute if score #RAND_RANGE_RESULT temp matches 1000103..1000105 run function skill:damage_formula/axe/one_hand/stab
					
					scoreboard players set #AFTERIMAGE_COLOR temp 0
					execute if score @s axe_mastery matches ..55 run function ARG(__PATH)set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.sword_l player @a ~ ~ ~ 1 1 0
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s axe_color
			}
		}
		
		folder oh_blunt()
		{
			func random()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				
				scoreboard players set #RANGE_MAX temp 14
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000066
				
				execute if score #RAND_RANGE_RESULT temp matches 1000066..1000074 run function ARG(_PATH)swing_formula
				execute if score #RAND_RANGE_RESULT temp matches 1000075..1000080 run function ARG(_PATH)stab_formula
				
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s blunt_mastery matches ..55 run function ARG(_PATH)set_color
				function ARG(__PATH)summon_model
				playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				
				scoreboard players add @s action_time 16
				execute if score @s f_attack_skill matches 1.. if score @s blunt_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			func swing_formula()
			{
				function skill:damage_formula/blunt/one_hand/swing
				scoreboard players set #LAST_ACTION_TYPE temp 1
			}
			
			func stab_formula()
			{
				function skill:damage_formula/blunt/one_hand/stab
				scoreboard players set #LAST_ACTION_TYPE temp 2
			}
			
			folder final_attack()
			{
				func try()
				{
					function random:rand_rate
					execute if score #RAND_RESULT number < @s blunt_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 5
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000118
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 2 if score #RAND_RANGE_RESULT temp matches 1000121..1000123 run scoreboard players remove @s action_time 2
				}
				
				func use()
				{
					scoreboard players set #SEARCH_HEIGHT temp 0
					
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
				
					execute if score #RAND_RANGE_RESULT temp matches 1000118..1000120 run function skill:damage_formula/blunt/one_hand/swing
					execute if score #RAND_RANGE_RESULT temp matches 1000121..1000123 run function skill:damage_formula/blunt/one_hand/stab
					
					scoreboard players set #AFTERIMAGE_COLOR temp 0
					execute if score @s blunt_mastery matches ..55 run function ARG(__PATH)set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				}
			}
			
			func set_color()
			{
				scoreboard players add #RAND_RANGE_RESULT temp 1000
				scoreboard players operation #AFTERIMAGE_COLOR temp = @s blunt_color
			}
		}
		
		folder th_sword()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 14
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000081
				
				execute if score #RAND_RANGE_RESULT temp matches 1000081..1000089 run function ARG(_PATH)set_swing
				execute if score #RAND_RANGE_RESULT temp matches 1000090..1000095 run function ARG(_PATH)set_stab
				
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s sword_mastery matches ..55 run function ARG(__PATH)oh_sword/set_color
				function ARG(__PATH)summon_model
				
				playsound minecraft:skill.attack.sword_l player @a ~ ~ ~ 1 1 0
				function skill:damage_formula/sword/two_hand
				
				scoreboard players add @s action_time 16
				execute if score @s f_attack_skill matches 1.. if score @s sword_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			func set_swing()
			{
				execute if score #RAND_RANGE_RESULT temp matches ..1000083 run scoreboard players set #SEARCH_HEIGHT temp 1
				execute if score #RAND_RANGE_RESULT temp matches 1000084.. run scoreboard players set #SEARCH_HEIGHT temp 0
				scoreboard players set #LAST_ACTION_TYPE temp 1
			}
			
			func set_stab()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				scoreboard players set #LAST_ACTION_TYPE temp 2
			}
			
			folder final_attack()
			{
				func try()
				{
					function random:rand_rate
					execute if score #RAND_RESULT number < @s sword_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 5
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000124
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 2 if score #RAND_RANGE_RESULT temp matches 1000127..1000129 run scoreboard players remove @s action_time 2
				}
				
				func use()
				{
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
					
					execute if score #RAND_RANGE_RESULT temp matches 1000124..1000126 run scoreboard players set #SEARCH_HEIGHT temp 1
					execute if score #RAND_RANGE_RESULT temp matches 1000127..1000129 run scoreboard players set #SEARCH_HEIGHT temp 0
					
					function skill:damage_formula/sword/two_hand
					
					scoreboard players set #AFTERIMAGE_COLOR temp 0
					execute if score @s sword_mastery matches ..55 run function skill:afterimage/oh_sword/set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.sword_l player @a ~ ~ ~ 1 1 0
				}
			}
		}
		
		folder th_axe()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 14
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000051
				
				execute if score #RAND_RANGE_RESULT temp matches 1000051..1000059 run function ARG(_PATH)swing_formula
				execute if score #RAND_RANGE_RESULT temp matches 1000060..1000065 run function ARG(_PATH)stab_formula
				
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s axe_mastery matches ..55 run function ARG(__PATH)oh_axe/set_color
				function ARG(__PATH)summon_model
				playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				
				scoreboard players add @s action_time 16
				execute if score @s f_attack_skill matches 1.. if score @s axe_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			func swing_formula()
			{
				execute if score #RAND_RANGE_RESULT temp matches ..1000053 run scoreboard players set #SEARCH_HEIGHT temp 1
				execute if score #RAND_RANGE_RESULT temp matches 1000054.. run scoreboard players set #SEARCH_HEIGHT temp 0
				
				function skill:damage_formula/axe/two_hand/swing
				scoreboard players set #LAST_ACTION_TYPE temp 1
			}
			
			func stab_formula()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				function skill:damage_formula/axe/two_hand/stab
				scoreboard players set #LAST_ACTION_TYPE temp 2
			}
			
			folder final_attack()
			{
				func try()
				{
					function random:rand_rate
					execute if score #RAND_RESULT number < @s axe_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 5
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000112
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 2 if score #RAND_RANGE_RESULT temp matches 1000115..1000117 run scoreboard players remove @s action_time 2
				}
				
				func swing_formula()
				{
					scoreboard players set #SEARCH_HEIGHT temp 1
					function skill:damage_formula/axe/two_hand/swing
				}
				
				func stab_formula()
				{
					scoreboard players set #SEARCH_HEIGHT temp 0
					function skill:damage_formula/axe/two_hand/stab
				}
				
				func use()
				{
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
				
					execute if score #RAND_RANGE_RESULT temp matches 1000112..1000114 run function ARG(_PATH)swing_formula
					execute if score #RAND_RANGE_RESULT temp matches 1000115..1000117 run function ARG(_PATH)stab_formula
					
					scoreboard players set #AFTERIMAGE_COLOR temp 0
					execute if score @s axe_mastery matches ..55 run function skill:afterimage/oh_axe/set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.sword_s player @a ~ ~ ~ 1 1 0
				}
			}
		}
		
		folder th_blunt()
		{
			func random()
			{
				scoreboard players set #RANGE_MAX temp 14
				function main:rand_range
				scoreboard players add #RAND_RANGE_RESULT temp 1000051
				
				execute if score #RAND_RANGE_RESULT temp matches 1000051..1000059 run function ARG(_PATH)swing_formula
				execute if score #RAND_RANGE_RESULT temp matches 1000060..1000065 run function ARG(_PATH)stab_formula
				
				scoreboard players set #AFTERIMAGE_COLOR temp 0
				execute if score @s blunt_mastery matches ..55 run function ARG(__PATH)oh_blunt/set_color
				function ARG(__PATH)summon_model
				playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				
				scoreboard players add @s action_time 16
				execute if score @s f_attack_skill matches 1.. if score @s blunt_final_rate matches 1.. run function ARG(_PATH)final_attack/try
			}
			
			func swing_formula()
			{
				execute if score #RAND_RANGE_RESULT temp matches ..1000053 run scoreboard players set #SEARCH_HEIGHT temp 1
				execute if score #RAND_RANGE_RESULT temp matches 1000054.. run scoreboard players set #SEARCH_HEIGHT temp 0
				
				function skill:damage_formula/blunt/two_hand/swing
				scoreboard players set #LAST_ACTION_TYPE temp 1
			}
			
			func stab_formula()
			{
				scoreboard players set #SEARCH_HEIGHT temp 0
				function skill:damage_formula/blunt/two_hand/stab
				scoreboard players set #LAST_ACTION_TYPE temp 2
			}
			
			folder final_attack()
			{
				func try()
				{
					function random:rand_rate
					execute if score #RAND_RESULT number < @s blunt_final_rate run function ARG(_PATH)set
				}
				
				func set()
				{
					scoreboard players operation @s f_attack_time = @s action_time
					scoreboard players remove @s f_attack_time 2
					
					# set final attack action
					scoreboard players set #RANGE_MAX temp 5
					function main:rand_range
					execute store result score @s f_attack_action run scoreboard players add #RAND_RANGE_RESULT temp 1000112
					
					scoreboard players add @s action_time 10
					execute if score #LAST_ACTION_TYPE temp matches 2 if score #RAND_RANGE_RESULT temp matches 1000115..1000117 run scoreboard players remove @s action_time 2
				}
				
				func swing_formula()
				{
					scoreboard players set #SEARCH_HEIGHT temp 1
					function skill:damage_formula/blunt/two_hand/swing
				}
				
				func stab_formula()
				{
					scoreboard players set #SEARCH_HEIGHT temp 0
					function skill:damage_formula/blunt/two_hand/stab
				}
				
				func use()
				{
					scoreboard players operation #RAND_RANGE_RESULT temp = @s f_attack_action
				
					execute if score #RAND_RANGE_RESULT temp matches 1000112..1000114 run function ARG(_PATH)swing_formula
					execute if score #RAND_RANGE_RESULT temp matches 1000115..1000117 run function ARG(_PATH)stab_formula
					
					scoreboard players set #AFTERIMAGE_COLOR temp 0
					execute if score @s blunt_mastery matches ..55 run function skill:afterimage/oh_blunt/set_color
					function skill:afterimage/summon_model
					playsound minecraft:skill.attack.mace player @a ~ ~ ~ 1 1 0
				}
			}
		}
		
		func summon_model()
		{
			scoreboard players operation #BIND_PLAYER number = @s number
			execute rotated ~ 0 summon minecraft:item_display run function ARG(_PATH)model_set
		}
		
		func summon_model_delay()
		{
			scoreboard players operation #BIND_PLAYER number = @s number
			execute rotated ~ 0 summon minecraft:item_display run function ARG(_PATH)model_set_delay
		}
		
		func model_set()
		{
			data merge entity @s {Tags:["afterimage"],item:{id:"minecraft:potion",Count:1b,tag:{CustomModelData:1}},transformation:{scale:[0.625f,0.625f,0.625f],translation:[0.0f,1.6885f,-0.7f]},item_display:"head"}
			scoreboard players set @s life 8
			scoreboard players operation @s base_model = #RAND_RANGE_RESULT temp
			execute store result entity @s item.tag.CustomPotionColor int 1 run scoreboard players get #AFTERIMAGE_COLOR temp

			tp @s ~ ~ ~ ~180 0
			function skill:bind_player
		}
		
		func model_set_delay()
		{
			function ARG(_PATH)model_set
			scoreboard players set @s life 9
		}

		func update()
		{
			scoreboard players remove @s life 1
			execute if score @s life matches 0 run function ARG(_PATH)show
			kill @s[scores={life=..-4}]
		}
		
		func show()
		{
			execute store result entity @s item.tag.CustomModelData int 1 run scoreboard players get @s base_model
			
			execute store result score #GLOBAL temp run time query gametime
			scoreboard players operation #GLOBAL temp %= #24000 const
			scoreboard players operation #GLOBAL temp %= #6 const
			scoreboard players operation #GLOBAL temp *= #256 const
			execute store result score #AFTERIMAGE_COLOR temp run data get entity @s item.tag.CustomPotionColor
			execute store result entity @s item.tag.CustomPotionColor int 1 run scoreboard players operation #AFTERIMAGE_COLOR temp += #GLOBAL temp
		}
	}
	
	func show_num_at_height()
	{
		scoreboard players remove #NUMBER_HEIGHT temp 1
		execute if score #NUMBER_HEIGHT temp matches -1 run function number_display:show
		execute if score #NUMBER_HEIGHT temp matches 0.. positioned ~ ~0.33 ~ run function ARG(_PATH)show_num_at_height
	}
	
	folder sync_knockback()
	{
		func run()
		{
			scoreboard players operation #PUSH_TIME temp = @s push_time
			scoreboard players operation #KB_TIME temp = @s kb_time
			scoreboard players operation #STATUS temp = @s status
			
			execute on controller run function ARG(_PATH)sync
		}
		
		func sync()
		{
			scoreboard players operation @s push_time = #PUSH_TIME temp
			scoreboard players operation @s kb_time = #KB_TIME temp
			execute if score #STATUS temp matches 1 run function ARG(_PATH)hit_model
			# 冰凍的時候順便做顏色處理
			execute if score #SYNC_FREEZE_COLOR temp matches 1 run function skill:mob_effect/debuff/freeze_color
			
			# knock_back function 裡面已經設定好面向了
			tp @s ~ ~ ~ ~ ~
			
			data modify entity @s NoAI set value 1b
		}
		
		func hit_model()
		{
			scoreboard players set @s status 1
			execute store result entity @s ArmorItems[3].tag.CustomModelData int 1 run scoreboard players operation #STATUS temp += @s base_model
			# 次元怒目哀目開眼特殊處理
			execute if entity @s[tag=close_eye] run function quest:party_quest/ldpq/stages/4/eyes/hit
		}
	}
	
	func set_mob_target()
	{
		data modify entity @s AngryAt set from storage skill:main damage_info.attacker
		attribute @s minecraft:generic.follow_range base set 40.0
	}
	func rand_anger_time() from random().generate(10, 30, "@s anger_time");
	
	func interaction()
	{
		scoreboard players set @s[predicate=skill:use_carrot] right_click 1
		scoreboard players set @s[predicate=skill:use_fungus] right_click_item 1
		advancement revoke @s only skill:cast
	}
	
	func quick_cast()
	{
		scoreboard players set @s right_click 1
		scoreboard players set @s[scores={2101002_level=1..}] skill_id 59
		advancement revoke @s only skill:hit
	}
	
	# 呼叫前須先設定 #BIND_PLAYER number
	func bind_player()
	{
		execute as @e[type=interaction,tag=player_pos,distance=..12] if score @s number = #BIND_PLAYER number run tag @s add bind
		ride @s mount @e[type=interaction,tag=bind,limit=1]
		tag @e[type=interaction,tag=bind,limit=1] remove bind
	}
	
	# 呼叫前須先設定 #BIND_PLAYER number
	func bind_mob()
	{
		execute as @e[type=ocelot,distance=..12] if score @s number = #BIND_PLAYER number run tag @s add bind
		ride @s mount @e[type=ocelot,tag=bind,limit=1]
		tag @e[type=ocelot,tag=bind,limit=1] remove bind
	}
}