```
skill_ids = []
```
namespace attack_skill_template(skill_id) as virtual
{
	# functions to override:
	#	mark_target => tag all target
	#	cast_effect => visual and audio effects on casting skill
	#	set_numeric => calculate all numbers related to damage and write to global storage
	#	effect => visual and audio effects with ARG(skill_id)_effect_num as damage
	#	append_scheduler => see "append_scheduler_sample"
	```
	skill_ids.append(str(ARG(skill_id)))
	```
	
	func run()
	{
		function ARG(_PATH)mark_target
		function ARG(_PATH)cast_effect
		function ARG(_PATH)set_numeric
		
		data modify storage skill:main temp set value []
		function ARG(_PATH)append_scheduler
		
		execute as @e[tag=target] at @s run function ARG(_PATH)hit
	}
	
	func hit_effect()
	{
		execute store result score #GLOBAL ARG(skill_id)_effect_id run time query gametime
		execute as @e if score @s ARG(skill_id)_effect_id = #GLOBAL ARG(skill_id)_effect_id run function ARG(_PATH)perform_effect
	}
	
	func perform_effect()
	{
		scoreboard players reset @s ARG(skill_id)_effect_id
		execute if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] run function ARG(_PATH)pop_schedule
		function ARG(_PATH)effect
	}
	
	func pop_schedule()
	{
		execute store result score @s ARG(skill_id)_effect_id run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		execute store result score @s ARG(skill_id)_effect_num run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage
		data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
	}
	
	func hit()
	{
		function ARG(_PATH)calculate_damage
		
		execute if score @s ARG(skill_id)_effect_id matches 0.. run function ARG(_PATH)push_schedule
		data modify storage skill:main new_queue set value []
		function ARG(_PATH)merge_schedule/run
		data modify entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue prepend from storage skill:main new_queue[]
		function ARG(_PATH)pop_schedule
		
		tag @s remove target
	}
	
	folder merge_schedule() from while_loop("if data storage skill:main temp[0]")
	{
		func execute()
		{
			execute store result score #LEFT temp run data get storage skill:main temp[0]
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
			function ARG(__PATH)merge_ori_schedule/run
			
			data modify storage skill:main new_queue append value {time:0,damage:0}
			execute store result storage skill:main new_queue[-1].time int 1 run scoreboard players get #LEFT temp
			data modify storage skill:main new_queue[-1].damage set from entity @s ArmorItems[3].tag.damage_record[0]
			
			data remove storage skill:main temp[0]
			data remove entity @s ArmorItems[3].tag.damage_record[0]
		}
	}
	
	folder merge_ori_schedule() from while_loop("if data entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0] if score #RIGHT temp < #LEFT temp")
	{
		func execute()
		{
			data modify storage skill:main new_queue append from entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			data remove entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0]
			execute store result score #RIGHT temp run data get entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time
		}
	}
	
	func push_schedule()
	{
		data modify entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue prepend value {time:0, damage:0}
		execute store result entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].time int 1 run scoreboard players get @s ARG(skill_id)_effect_id
		execute store result entity @s ArmorItems[3].tag.ARG(skill_id)_effect_queue[0].damage int 1 run scoreboard players get @s ARG(skill_id)_effect_num
	}
	
	func append_scheduler_sample() as virtual
	{
		data modify storage skill:main temp append value 0
		execute store result storage skill:main temp[-1] int 1 run schedule function ARG(_PATH)hit_effect 6t append
		data modify storage skill:main temp append value 0
		execute store result storage skill:main temp[-1] int 1 run schedule function ARG(_PATH)hit_effect 9t append
	}
}



namespace skill()
{
	func install()
	{
		scoreboard objectives add action_time dummy
		scoreboard objectives add attack_times dummy
		```
		for skill in skill_ids:
			print(f"scoreboard objectives add {skill}_effect_id dummy")
			print(f"scoreboard objectives add {skill}_effect_num dummy")
		```
	}
	
	func main()
	{
		execute as @e[type=area_effect_cloud,scores={type=1}] run function ARG(_PATH)font_effect_update
		
		# summon font effect
		execute as @a[scores={temp=1..}] at @s run function ARG(_PATH)test_summon
	}
	
	func font_effect_update()
	{
		execute store result score #GLOBAL temp run data get entity @s Age
		scoreboard players operation #GLOBAL temp %= #10 const
		execute if score #GLOBAL temp matches 0 run data remove entity @s Tags[0]
		
		data modify storage skill:main effect_font set from entity @s Tags[0]
		data modify block 0 0 0 Text1 set value '[{"nbt":"effect_font","storage":"skill:main","interpret":true},{"text":"F","font":"space:default"},{"score":{"name":"#GLOBAL","objective":"temp"}},{"text":"F","font":"space:default"}]'
		data modify entity @s CustomName set from block 0 0 0 Text1
	}
	
	folder summon_font_effect()
	{
		```
		font_root_path = os.path.dirname(os.path.abspath(PROJ_DIR)) + "/MapleCraft resource pack/assets/skill/font"
		for root, dirs, files in os.walk(font_root_path):
			for name in files:
				if name == "summon.txt":
					func_name = ""
					recursive_path = root
					for i in range(3):
						func_name = os.path.basename(recursive_path) + func_name
						recursive_path = os.path.dirname(recursive_path)
						
					print(f"func {func_name}()")
					print("{")
					with open(os.path.join(root, name), "r") as f:
						print(f.read())
					print("}")
					
					break
		```
	}
	
	func test_summon()
	{
		execute positioned ^ ^ ^3 run function ARG(_PATH)summon_font_effect/2321008effect0
		scoreboard players reset @s temp
	}
}